#!/usr/local/bin/python

#
# decode FT8
#
# Robert Morris, AB1HL
#

import numpy
import wave
import scipy
import scipy.signal
import sys
import os
import math
import time
import copy
import calendar
import subprocess
import multiprocessing
import threading
import re
import random
from scipy.signal import lfilter
import ctypes
import weakaudio
import weakutil
import ctypes

#
# tuning parameters.
#
budget = 2 # max seconds of time for decoding.
coarse_fstep = 0.25 # coarse search granularity, FFT bins
coarse_tstep = 0.25 # coarse search granularity, symbol times
coarse_tminus = 1.5 # start search this many seconds before 0.5
coarse_tplus = 1.6 # end search this many seconds after 0.5
coarse_no    = 1 # number of best offsets to use per hz
fine_fstep = 0.5 # fraction of coarse_fstep
fine_tstep = 0.5 # fraction of coarse_tstep
start_adj = 0.1 # signals seem on avg to start this many seconds late.
ldpc_iters = 33 # how hard LDPC should work
softboost = 1.0 # log(prob) if #2 symbol has same bit value
do_subtract = 2 # 0 none, 1 once per unique decode, 2 three per unique, 3 once per decode
subtime = 0.4 # switch to subtracted samples this frac through budget
subgap = 1.25  # extra subtract()s this many hz on either side of main bin
subslop = 0.01 # search this fraction of a symbol to match subtraction symbols
contrast_weight = 0

# FT8 modulation and protocol definitions.
# 1920-point FFT at 12000 samples/second
#   yields 6.25 Hz spacing, 0.16 seconds/symbol
# encode chain:
#   75 bits
#   append 12 bits CRC (for 87 bits)
#   LDPC(174,87) yields 174 bits
#   that's 58 3-bit FSK-8 symbols
#   insert three 7-symbol Costas sync arrays
#     at symbol #s 0, 36, 72 of final signal
#   thus: 79 FSK-8 symbols
# total transmission time is 12.64 seconds
nsymbols = 79 # 79 FSK symbols per msg

# LDPC(174,87) parameters from WSJT-X.
# this is an indirection table that moves a
# codeword's 87 systematic (message) bits to the end.
colorder = [
  0, 1, 2, 3, 30, 4, 5, 6, 7, 8, 9, 10, 11, 32, 12, 40, 13, 14, 15, 16,
  17, 18, 37, 45, 29, 19, 20, 21, 41, 22, 42, 31, 33, 34, 44, 35, 47,
  51, 50, 43, 36, 52, 63, 46, 25, 55, 27, 24, 23, 53, 39, 49, 59, 38,
  48, 61, 60, 57, 28, 62, 56, 58, 65, 66, 26, 70, 64, 69, 68, 67, 74,
  71, 54, 76, 72, 75, 78, 77, 80, 79, 73, 83, 84, 81, 82, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103,
  104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
  118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
  132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145,
  146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
  160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173
  ]

# this is the LDPC(174,87) parity check matrix.
# 87 rows.
# each row describes one parity check.
# each number is an index into the codeword (1-origin).
# the codeword bits mentioned in each row must xor to zero.
# From WSJT-X's bpdecode174.f90.
Nm = [
    [ 1,   30,  60,  89,   118,  147,  0 ],
    [ 2,   31,  61,  90,   119,  147,  0 ],
    [ 3,   32,  62,  91,   120,  148,  0 ],
    [ 4,   33,  63,  92,   121,  149,  0 ],
    [ 2,   34,  64,  93,   122,  150,  0 ],
    [ 5,   33,  65,  94,   123,  148,  0 ],
    [ 6,   34,  66,  95,   124,  151,  0 ],
    [ 7,   35,  67,  96,   120,  152,  0 ],
    [ 8,   36,  68,  97,   125,  153,  0 ],
    [ 9,   37,  69,  98,   126,  152,  0 ],
    [ 10,  38,  70,  99,   127,  154,  0 ],
    [ 11,  39,  71,  100,  126,  155,  0 ],
    [ 12,  40,  61,  101,  128,  145,  0 ],
    [ 10,  33,  60,  95,   128,  156,  0 ],
    [ 13,  41,  72,  97,   126,  157,  0 ],
    [ 13,  42,  73,  90,   129,  156,  0 ],
    [ 14,  39,  74,  99,   130,  158,  0 ],
    [ 15,  43,  75,  102,  131,  159,  0 ],
    [ 16,  43,  71,  103,  118,  160,  0 ],
    [ 17,  44,  76,  98,   130,  156,  0 ],
    [ 18,  45,  60,  96,   132,  161,  0 ],
    [ 19,  46,  73,  83,   133,  162,  0 ],
    [ 12,  38,  77,  102,  134,  163,  0 ],
    [ 19,  47,  78,  104,  135,  147,  0 ],
    [ 1,   32,  77,  105,  136,  164,  0 ],
    [ 20,  48,  73,  106,  123,  163,  0 ],
    [ 21,  41,  79,  107,  137,  165,  0 ],
    [ 22,  42,  66,  108,  138,  152,  0 ],
    [ 18,  42,  80,  109,  139,  154,  0 ],
    [ 23,  49,  81,  110,  135,  166,  0 ],
    [ 16,  50,  82,  91,   129,  158,  0 ],
    [ 3,   48,  63,  107,  124,  167,  0 ],
    [ 6,   51,  67,  111,  134,  155,  0 ],
    [ 24,  35,  77,  100,  122,  162,  0 ],
    [ 20,  45,  76,  112,  140,  157,  0 ],
    [ 21,  36,  64,  92,   130,  159,  0 ],
    [ 8,   52,  83,  111,  118,  166,  0 ],
    [ 21,  53,  84,  113,  138,  168,  0 ],
    [ 25,  51,  79,  89,   122,  158,  0 ],
    [ 22,  44,  75,  107,  133,  155,  172 ],
    [ 9,   54,  84,  90,   141,  169,  0 ],
    [ 22,  54,  85,  110,  136,  161,  0 ],
    [ 8,   37,  65,  102,  129,  170,  0 ],
    [ 19,  39,  85,  114,  139,  150,  0 ],
    [ 26,  55,  71,  93,   142,  167,  0 ],
    [ 27,  56,  65,  96,   133,  160,  174 ],
    [ 28,  31,  86,  100,  117,  171,  0 ],
    [ 28,  52,  70,  104,  132,  144,  0 ],
    [ 24,  57,  68,  95,   137,  142,  0 ],
    [ 7,   30,  72,  110,  143,  151,  0 ],
    [ 4,   51,  76,  115,  127,  168,  0 ],
    [ 16,  45,  87,  114,  125,  172,  0 ],
    [ 15,  30,  86,  115,  123,  150,  0 ],
    [ 23,  46,  64,  91,   144,  173,  0 ],
    [ 23,  35,  75,  113,  145,  153,  0 ],
    [ 14,  41,  87,  108,  117,  149,  170 ],
    [ 25,  40,  85,  94,   124,  159,  0 ],
    [ 25,  58,  69,  116,  143,  174,  0 ],
    [ 29,  43,  61,  116,  132,  162,  0 ],
    [ 15,  58,  88,  112,  121,  164,  0 ],
    [ 4,   59,  72,  114,  119,  163,  173 ],
    [ 27,  47,  86,  98,   134,  153,  0 ],
    [ 5,   44,  78,  109,  141,  0,    0 ],
    [ 10,  46,  69,  103,  136,  165,  0 ],
    [ 9,   50,  59,  93,   128,  164,  0 ],
    [ 14,  57,  58,  109,  120,  166,  0 ],
    [ 17,  55,  62,  116,  125,  154,  0 ],
    [ 3,   54,  70,  101,  140,  170,  0 ],
    [ 1,   36,  82,  108,  127,  174,  0 ],
    [ 5,   53,  81,  105,  140,  0,    0 ],
    [ 29,  53,  67,  99,   142,  173,  0 ],
    [ 18,  49,  74,  97,   115,  167,  0 ],
    [ 2,   57,  63,  103,  138,  157,  0 ],
    [ 26,  38,  79,  112,  135,  171,  0 ],
    [ 11,  52,  66,  88,   119,  148,  0 ],
    [ 20,  40,  68,  117,  141,  160,  0 ],
    [ 11,  48,  81,  89,   146,  169,  0 ],
    [ 29,  47,  80,  92,   146,  172,  0 ],
    [ 6,   32,  87,  104,  145,  169,  0 ],
    [ 27,  34,  74,  106,  131,  165,  0 ],
    [ 12,  56,  84,  88,   139,  0,    0 ],
    [ 13,  56,  62,  111,  146,  171,  0 ],
    [ 26,  37,  80,  105,  144,  151,  0 ],
    [ 17,  31,  82,  113,  121,  161,  0 ],
    [ 28,  49,  59,  94,   137,  0,    0 ],
    [ 7,   55,  83,  101,  131,  168,  0 ],
    [ 24,  50,  78,  106,  143,  149,  0 ],
]

# Mn from WSJT-X's bpdecode174.f90.
# each row corresponds to a codeword bit.
# the numbers indicate which three parity
# checks (rows in Nm) refer to the codeword bit.
# 1-origin.
Mn = [
  [ 1, 25, 69 ],
  [ 2, 5, 73 ],
  [ 3, 32, 68 ],
  [ 4, 51, 61 ],
  [ 6, 63, 70 ],
  [ 7, 33, 79 ],
  [ 8, 50, 86 ],
  [ 9, 37, 43 ],
  [ 10, 41, 65 ],
  [ 11, 14, 64 ],
  [ 12, 75, 77 ],
  [ 13, 23, 81 ],
  [ 15, 16, 82 ],
  [ 17, 56, 66 ],
  [ 18, 53, 60 ],
  [ 19, 31, 52 ],
  [ 20, 67, 84 ],
  [ 21, 29, 72 ],
  [ 22, 24, 44 ],
  [ 26, 35, 76 ],
  [ 27, 36, 38 ],
  [ 28, 40, 42 ],
  [ 30, 54, 55 ],
  [ 34, 49, 87 ],
  [ 39, 57, 58 ],
  [ 45, 74, 83 ],
  [ 46, 62, 80 ],
  [ 47, 48, 85 ],
  [ 59, 71, 78 ],
  [ 1, 50, 53 ],
  [ 2, 47, 84 ],
  [ 3, 25, 79 ],
  [ 4, 6, 14 ],
  [ 5, 7, 80 ],
  [ 8, 34, 55 ],
  [ 9, 36, 69 ],
  [ 10, 43, 83 ],
  [ 11, 23, 74 ],
  [ 12, 17, 44 ],
  [ 13, 57, 76 ],
  [ 15, 27, 56 ],
  [ 16, 28, 29 ],
  [ 18, 19, 59 ],
  [ 20, 40, 63 ],
  [ 21, 35, 52 ],
  [ 22, 54, 64 ],
  [ 24, 62, 78 ],
  [ 26, 32, 77 ],
  [ 30, 72, 85 ],
  [ 31, 65, 87 ],
  [ 33, 39, 51 ],
  [ 37, 48, 75 ],
  [ 38, 70, 71 ],
  [ 41, 42, 68 ],
  [ 45, 67, 86 ],
  [ 46, 81, 82 ],
  [ 49, 66, 73 ],
  [ 58, 60, 66 ],
  [ 61, 65, 85 ],
  [ 1, 14, 21 ],
  [ 2, 13, 59 ],
  [ 3, 67, 82 ],
  [ 4, 32, 73 ],
  [ 5, 36, 54 ],
  [ 6, 43, 46 ],
  [ 7, 28, 75 ],
  [ 8, 33, 71 ],
  [ 9, 49, 76 ],
  [ 10, 58, 64 ],
  [ 11, 48, 68 ],
  [ 12, 19, 45 ],
  [ 15, 50, 61 ],
  [ 16, 22, 26 ],
  [ 17, 72, 80 ],
  [ 18, 40, 55 ],
  [ 20, 35, 51 ],
  [ 23, 25, 34 ],
  [ 24, 63, 87 ],
  [ 27, 39, 74 ],
  [ 29, 78, 83 ],
  [ 30, 70, 77 ],
  [ 31, 69, 84 ],
  [ 22, 37, 86 ],
  [ 38, 41, 81 ],
  [ 42, 44, 57 ],
  [ 47, 53, 62 ],
  [ 52, 56, 79 ],
  [ 60, 75, 81 ],
  [ 1, 39, 77 ],
  [ 2, 16, 41 ],
  [ 3, 31, 54 ],
  [ 4, 36, 78 ],
  [ 5, 45, 65 ],
  [ 6, 57, 85 ],
  [ 7, 14, 49 ],
  [ 8, 21, 46 ],
  [ 9, 15, 72 ],
  [ 10, 20, 62 ],
  [ 11, 17, 71 ],
  [ 12, 34, 47 ],
  [ 13, 68, 86 ],
  [ 18, 23, 43 ],
  [ 19, 64, 73 ],
  [ 24, 48, 79 ],
  [ 25, 70, 83 ],
  [ 26, 80, 87 ],
  [ 27, 32, 40 ],
  [ 28, 56, 69 ],
  [ 29, 63, 66 ],
  [ 30, 42, 50 ],
  [ 33, 37, 82 ],
  [ 35, 60, 74 ],
  [ 38, 55, 84 ],
  [ 44, 52, 61 ],
  [ 51, 53, 72 ],
  [ 58, 59, 67 ],
  [ 47, 56, 76 ],
  [ 1, 19, 37 ],
  [ 2, 61, 75 ],
  [ 3, 8, 66 ],
  [ 4, 60, 84 ],
  [ 5, 34, 39 ],
  [ 6, 26, 53 ],
  [ 7, 32, 57 ],
  [ 9, 52, 67 ],
  [ 10, 12, 15 ],
  [ 11, 51, 69 ],
  [ 13, 14, 65 ],
  [ 16, 31, 43 ],
  [ 17, 20, 36 ],
  [ 18, 80, 86 ],
  [ 21, 48, 59 ],
  [ 22, 40, 46 ],
  [ 23, 33, 62 ],
  [ 24, 30, 74 ],
  [ 25, 42, 64 ],
  [ 27, 49, 85 ],
  [ 28, 38, 73 ],
  [ 29, 44, 81 ],
  [ 35, 68, 70 ],
  [ 41, 63, 76 ],
  [ 45, 49, 71 ],
  [ 50, 58, 87 ],
  [ 48, 54, 83 ],
  [ 13, 55, 79 ],
  [ 77, 78, 82 ],
  [ 1, 2, 24 ],
  [ 3, 6, 75 ],
  [ 4, 56, 87 ],
  [ 5, 44, 53 ],
  [ 7, 50, 83 ],
  [ 8, 10, 28 ],
  [ 9, 55, 62 ],
  [ 11, 29, 67 ],
  [ 12, 33, 40 ],
  [ 14, 16, 20 ],
  [ 15, 35, 73 ],
  [ 17, 31, 39 ],
  [ 18, 36, 57 ],
  [ 19, 46, 76 ],
  [ 21, 42, 84 ],
  [ 22, 34, 59 ],
  [ 23, 26, 61 ],
  [ 25, 60, 65 ],
  [ 27, 64, 80 ],
  [ 30, 37, 66 ],
  [ 32, 45, 72 ],
  [ 38, 51, 86 ],
  [ 41, 77, 79 ],
  [ 43, 56, 68 ],
  [ 47, 74, 82 ],
  [ 40, 52, 78 ],
  [ 54, 61, 71 ],
  [ 46, 58, 69 ],
]

# LDPC generator matrix, from wsjt-x's encode174.f90 and ldpc_174_87_params.f90
# 87 rows, 87 columns.
# generates first 87 codeword bits; second 87 are the 87 bits of plain-text.
# i'th codeword bit is xor of plain bits and gen[i].
gen = [
    [ 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 ],
    [ 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0 ],
    [ 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1 ],
    [ 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 ],
    [ 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0 ],
    [ 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 ],
    [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1 ],
    [ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 ],
    [ 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0 ],
    [ 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1 ],
    [ 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0 ],
    [ 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0 ],
    [ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0 ],
    [ 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0 ],
    [ 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1 ],
    [ 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0 ],
    [ 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0 ],
    [ 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1 ],
    [ 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0 ],
    [ 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1 ],
    [ 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1 ],
    [ 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0 ],
    [ 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0 ],
    [ 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1 ],
    [ 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0 ],
    [ 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0 ],
    [ 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 ],
    [ 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0 ],
    [ 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1 ],
    [ 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1 ],
    [ 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0 ],
    [ 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1 ],
    [ 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0 ],
    [ 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1 ],
    [ 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1 ],
    [ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0 ],
    [ 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0 ],
    [ 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1 ],
    [ 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0 ],
    [ 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1 ],
    [ 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1 ],
    [ 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0 ],
    [ 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1 ],
    [ 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1 ],
    [ 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1 ],
    [ 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1 ],
    [ 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1 ],
    [ 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1 ],
    [ 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0 ],
    [ 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0 ],
    [ 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 ],
    [ 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1 ],
    [ 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1 ],
    [ 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0 ],
    [ 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0 ],
    [ 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1 ],
    [ 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1 ],
    [ 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0 ],
    [ 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ],
    [ 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 ],
    [ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0 ],
    [ 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0 ],
    [ 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0 ],
    [ 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0 ],
    [ 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1 ],
    [ 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0 ],
    [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1 ],
    [ 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1 ],
    [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1 ],
    [ 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1 ],
    [ 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0 ],
    [ 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0 ],
    [ 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1 ],
    [ 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1 ],
    [ 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1 ],
    [ 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1 ],
    [ 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0 ],
    [ 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1 ],
    [ 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1 ],
    [ 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1 ],
    [ 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 ],
    [ 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0 ],
    [ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1 ],
]

# plain is 87 bits of plain-text.
# returns a 174-bit codeword.
# mimics wsjt-x's encode174.f90.
def ldpc_encode(plain):
    cw = numpy.zeros(174, dtype=numpy.int32)
    for i in range(0, 87):
        x = numpy.multiply(plain, gen[i])
        cw[i] = numpy.sum(x) % 2
    cw[87:] = plain

    cw1 = numpy.zeros(174, dtype=numpy.int32)
    for i in range(0, 174):
        cw1[colorder[i]] = cw[i]

    return cw1

# given a 174-bit codeword as an array of log-likelihood of zero,
# return a 87-bit plain text, or zero-length array.
# this is an implementation of the sum-product algorithm
# from Sarah Johnson's Iterative Error Correction book.
# codeword[i] = log ( P(x=0) / P(x=1) )
def ldpc_decode_python(codeword):
    # 174 codeword bits
    # 87 parity checks

    mnx = numpy.array(Mn, dtype=numpy.int32)
    nmx = numpy.array(Nm, dtype=numpy.int32)

    # Mji
    # each codeword bit i tells each parity check j
    # what the bit's log-likelihood of being 0 is
    # based on information *other* than from that
    # parity check.
    m = numpy.zeros((87, 174))

    for i in range(0, 174):
        for j in range(0, 87):
            m[j][i] = codeword[i]

    for iter in range(0, ldpc_iters):
        # Eji
        # each check j tells each codeword bit i the
        # log likelihood of the bit being zero based
        # on the *other* bits in that check.
        e = numpy.zeros((87, 174))

        # messages from checks to bits.
        # for each parity check
        #for j in range(0, 87):
        #    # for each bit mentioned in this parity check
        #    for i in Nm[j]:
        #        if i <= 0:
        #            continue
        #        a = 1
        #        # for each other bit mentioned in this parity check
        #        for ii in Nm[j]:
        #            if ii != i:
        #                a *= math.tanh(m[j][ii-1] / 2.0)
        #        e[j][i-1] = math.log((1 + a) / (1 - a))
        for i in range(0, 7):
            a = numpy.ones(87)
            for ii in range(0, 7):
                if ii != i:
                    x1 = numpy.tanh(m[range(0, 87), nmx[:,ii]-1] / 2.0)
                    x2 = numpy.where(numpy.greater(nmx[:,ii], 0.0), x1, 1.0)
                    a = a * x2
            # avoid divide by zero, i.e. a[i]==1.0
            # XXX why is a[i] sometimes 1.0?
            b = numpy.where(numpy.less(a, 0.99999), a, 0.99)
            c = numpy.log((b + 1.0) / (1.0 - b))
            # have assign be no-op when nmx[a,b] == 0
            d = numpy.where(numpy.equal(nmx[:,i], 0),
                            e[range(0,87), nmx[:,i]-1],
                            c)
            e[range(0,87), nmx[:,i]-1] = d

        # decide if we are done -- compute the corrected codeword,
        # see if the parity check succeeds.
        # sum the three log likelihoods contributing to each codeword bit.
        e0 = e[mnx[:,0]-1, range(0,174)]
        e1 = e[mnx[:,1]-1, range(0,174)]
        e2 = e[mnx[:,2]-1, range(0,174)]
        ll = codeword + e0 + e1 + e2
        # log likelihood > 0 => bit=0.
        cw = numpy.select( [ ll < 0 ], [ numpy.ones(174, dtype=numpy.int32) ])
        if ldpc_check(cw):
            # success!
            # it's a systematic code, though the plain-text bits are scattered.
            # collect them.
            decoded = cw[colorder]
            decoded = decoded[-87:]
            return [ 87, decoded ]

        # messages from bits to checks.
        for j in range(0, 3):
            # for each column in Mn.
            ll = codeword
            if j != 0:
                e0 = e[mnx[:,0]-1, range(0,174)]
                ll = ll + e0
            if j != 1:
                e1 = e[mnx[:,1]-1, range(0,174)]
                ll = ll + e1
            if j != 2:
                e2 = e[mnx[:,2]-1, range(0,174)]
                ll = ll + e2
            m[mnx[:,j]-1, range(0,174)] = ll
                

    # could not decode.
    return [ 0, numpy.array([]) ]

# given a 174-bit codeword as an array of log-likelihood of zero,
# return a 87-bit plain text, or zero-length array.
# this is an implementation of the bit-flipping algorithm
# from Sarah Johnson's Iterative Error Correction book.
# codeword[i] = log ( P(x=0) / P(x=1) )
def ldpc_decode_flipping(codeword):
    # turn log-likelihood into hard bits.
    # > 0 means bit=0, < 0 means bit=1.
    hard = numpy.less(codeword, 0.0)
    hard = numpy.array(hard, dtype=numpy.int32) # T/F -> 1/0
    two = numpy.array([0, 1], dtype=numpy.int32)
    cw = two[hard]

    for iter in range(0,100):
        # for each codeword bit,
        # count of votes for 0 and 1.
        votes = numpy.zeros((len(codeword), 2))

        # for each parity check equation.
        for e in Nm:
            # for each codeword bit mentioned in e.
            for bi in e:
                if bi == 0:
                    continue
                # value for bi implied by remaining bits.
                x = 0
                for i in e:
                    if i != bi:
                        x ^= cw[i-1]
                # the other bits in the equation suggest that
                # bi must have value x.
                votes[(bi-1),x] += 1

        for i in range(0, len(cw)):
            if cw[i] == 0 and votes[i][1] > votes[i][0]:
                cw[i] = 1
            elif cw[i] == 1 and votes[i][0] > votes[i][1]:
                cw[i] = 0

        if ldpc_check(cw):
            # success!
            # it's a systematic code, though the plain-text bits are scattered.
            # collect them.
            decoded = cw[colorder]
            decoded = decoded[-87:]
            return decoded
        
    return numpy.array([])

# does a 174-bit codeword pass the LDPC parity checks?
def ldpc_check(codeword):
    for e in Nm:
        x = 0
        for i in e:
            if i != 0:
                x ^= codeword[i-1]
        if x != 0:
            return False
    return True

libldpc = None
try:
    libldpc = ctypes.cdll.LoadLibrary("libldpc/libldpc.so")
except:
    libldpc = None
    sys.stderr.write("ft8: using the Python LDPC decoder, not the C decoder.\n")

def ldpc_test():
    tt = 0.0
    niters = 200
    ok = 0
    for iter in range(0, niters):
        # ldpc_encode() takes 87 bits.
        a87 = numpy.random.randint(0, 2, 87)
        a174 = ldpc_encode(a87)
        
        # turn hard bits into 0.99 vs 0.01 log-likelihood,
        # log( P(0) / P(1) )
        # log base e.
        two = numpy.array([ 4.6, -4.6 ], dtype=numpy.int32)
        ll174 = two[a174]

        # wreck some bits
        for junk in range(0, 70):
            ll174[random.randint(0, len(ll174)-1)] = (random.random() - 0.5) * 4

        t0 = time.time()
        
        # decode LDPC(174,87)
        d87 = ldpc_decode(ll174)

        t1 = time.time()
        tt += t1 - t0

        if numpy.array_equal(a87, d87):
            ok += 1

    print("success %.2f" % (ok / float(niters)))
    print("%.6f per call" % (tt / niters))
    # success 0.88
    # 0.019423 per call

# codeword is 174 log-likelihoods.
# return is  [ ok, 87 bits ].
# ok is 87 if all ldpc parity checks worked, < 87 otherwise.
# result is usually garbage if ok < 87.
def ldpc_decode_c(codeword):
    double174 = ctypes.c_double * 174
    int174 = ctypes.c_int * 174

    c174 = double174()
    for i in range(0, 174):
        c174[i] = codeword[i]

    out174 = int174()
    for i in range(0, 174):
        out174[i] = -1;

    ok = ctypes.c_int()
    ok.value = -1

    libldpc.ldpc_decode(c174, ldpc_iters, out174, ctypes.byref(ok))

    plain174 = numpy.zeros(174, dtype=numpy.int32);
    for i in range(0, 174):
        plain174[i] = out174[i];

    plain87 = plain174[-87:]
    return [ ok.value, plain87 ]

def ldpc_decode(codeword):
    if libldpc != None:
        return ldpc_decode_c(codeword)
    else:
        return ldpc_decode_python(codeword)

if False:
    ldpc_test()
    sys.exit(1)

# the CRC-12 polynomial, from wsjt-x's 0xc06.
crc12poly = [ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 ]

# a-priori probability of each of the 174 LDPC codeword
# bits being one. measured from reconstructed correct
# codewords, into ft8bits, then python bprob.py.
apriori174 = numpy.array([
    0.54, 0.45, 0.53, 0.47, 0.46, 0.48, 0.50, 0.49, 0.45, 0.53,
    0.52, 0.51, 0.53, 0.50, 0.47, 0.49, 0.48, 0.48, 0.45, 0.52,
    0.57, 0.50, 0.50, 0.49, 0.54, 0.49, 0.53, 0.46, 0.54, 0.53,
    0.55, 0.54, 0.47, 0.48, 0.47, 0.48, 0.49, 0.48, 0.49, 0.55,
    0.50, 0.52, 0.50, 0.48, 0.55, 0.52, 0.49, 0.50, 0.50, 0.43,
    0.46, 0.51, 0.48, 0.56, 0.45, 0.50, 0.44, 0.53, 0.45, 0.55,
    0.47, 0.52, 0.49, 0.51, 0.53, 0.55, 0.47, 0.50, 0.53, 0.50,
    0.47, 0.49, 0.51, 0.46, 0.54, 0.50, 0.52, 0.57, 0.51, 0.48,
    0.53, 0.46, 0.57, 0.52, 0.51, 0.59, 0.53, 0.88, 0.80, 0.68,
    0.73, 0.64, 0.37, 0.72, 0.47, 0.31, 0.32, 0.28, 0.37, 0.70,
    0.31, 0.36, 0.35, 0.31, 0.39, 0.66, 0.67, 0.37, 0.31, 0.34,
    0.63, 0.66, 0.31, 0.32, 0.66, 0.86, 0.72, 0.51, 0.61, 0.48,
    0.50, 0.55, 0.71, 0.43, 0.41, 0.45, 0.53, 0.57, 0.43, 0.50,
    0.55, 0.45, 0.60, 0.55, 0.47, 0.50, 0.45, 0.53, 0.47, 0.50,
    0.47, 0.49, 0.47, 0.02, 0.89, 0.59, 0.86, 0.91, 0.77, 0.66,
    0.30, 0.68, 0.49, 0.31, 0.61, 0.47, 0.47, 0.40, 0.41, 0.01,
    0.01, 0.01, 0.48, 0.49, 0.50, 0.52, 0.49, 0.54, 0.48, 0.47,
    0.46, 0.47, 0.50, 0.01, 
])

# information about one decoded signal.
class Decode:
    def __init__(self,
                 hza,
                 msg,
                 snr,
                 twelve,
                 decode_time):
        self.hza = hza
        self.msg = msg
        self.snr = snr
        self.twelve = twelve # the 72 bits, as 12 6-bit numbers
        self.decode_time = decode_time # unix time of decode
        self.minute = None # cycle number
        self.start = None # sample number
        self.dt = None # dt in seconds
        self.drift = self.hz() - hza[0] # Hz per minute

    def hz(self):
        return numpy.mean(self.hza)

normal_table_stds = 5 # +/- this many std dev
normal_table_gran = 20 # this many points per std dev
normal_table = None

# Normal function integrated from -Inf to x. Range: 0-1.
# x in units of std dev.
# mean is zero.
# the same as scipy.stats.norm.cdf([x])
def real_normal(x):
    y = 0.5 + 0.5*math.erf(x / 1.414213)
    return y

def make_normal_table():
    global normal_table
    tt = [ ]
    x = 0 - normal_table_stds
    while x < normal_table_stds:
        z = real_normal(x)
        tt.append(z)
        x += 1.0 / normal_table_gran
    normal_table = numpy.array(tt)

# x is distance from mean, in units of std-dev.
# uses pre-computed table.
def vnormal(x):
    x *= normal_table_gran
    x += (normal_table_stds * normal_table_gran)
    x = numpy.rint(x)
    x = x.astype(numpy.int32)
    x = numpy.maximum(x, 0)
    x = numpy.minimum(x, len(normal_table)-1)
    return normal_table[x]

# vectorized normal()
def real_vnormal(v):
    return scipy.stats.norm.cdf(v)

# how much of the distribution is < x?
def problt(x, mean, std):
    if std != 0.0:
        y = normal((x - mean) / std)
    else:
        y = 0.5
    return y

def vproblt(x, mean, std):
    y = vnormal((x - mean) / std)
    return y

# how much of the distribution is > x?
def probgt(x, mean, std):
    if std != 0.0:
        y = 1.0 - normal((x - mean) / std)
    else:
        y = 0.5
    return y

def vprobgt(x, mean, std):
    y = 1.0 - vnormal((x - mean) / std)
    return y

def bit_reverse(x, width):
    y = 0
    for i in range(0, width):
        z = (x >> i) & 1
        y <<= 1
        y |= z
    return y

# turn an array of bits into a number.
# most significant bit first.
def bits2num(bits):
    assert len(bits) < 32
    n = 0
    for i in range(0, len(bits)):
        n *= 2
        n += bits[i]
    return n

def crc_c(msg):
    msgtype = ctypes.c_int * len(msg)
    outtype = ctypes.c_int * 12

    msg1 = msgtype()
    for i in range(0, len(msg)):
        msg1[i] = msg[i]

    out1 = outtype()

    libldpc.ft8_crc(msg1, len(msg), out1)

    out = numpy.zeros(12, dtype=numpy.int32)
    for i in range(0, 12):
        out[i] = out1[i]

    return out

#
# thank you, evan sneath.
# https://gist.github.com/evansneath/4650991
#
# generate with x^3 + x + 1:
#   >>> xc.crc([1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1])
#   array([1, 0, 0])
# check:
#   >>> xc.crc([1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1], [1, 0, 0])
#   array([0, 0, 0])
#
# 0xc06 is really 0x1c06 or [ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 ]
#
def crc(msg, div, code=None):
    return crc_c(msg)

    """Cyclic Redundancy Check
    Generates an error detecting code based on an inputted message
    and divisor in the form of a polynomial representation.
    Arguments:
        msg: The input message of which to generate the output code.
        div: The divisor in polynomial form. For example, if the polynomial
            of x^3 + x + 1 is given, this should be represented as '1011' in
            the div argument.
        code: This is an option argument where a previously generated code may
            be passed in. This can be used to check validity. If the inputted
            code produces an outputted code of all zeros, then the message has
            no errors.
    Returns:
        An error-detecting code generated by the message and the given divisor.
    """

    # Append the code to the message. If no code is given, default to '000'
    if code is None:
        code = numpy.zeros(len(div)-1, dtype=numpy.int32)
    assert len(code) == len(div) - 1
    msg = numpy.append(msg, code)

    div = numpy.array(div, dtype=numpy.int32)
    divlen = len(div)

    # Loop over every message bit (minus the appended code)
    for i in range(len(msg)-len(code)):
        # If that messsage bit is 1, perform modulo 2 multiplication
        if msg[i] == 1:
            #for j in range(len(div)):
            #    # Perform modulo 2 multiplication on each index of the divisor
            #    msg[i+j] = (msg[i+j] + div[j]) % 2
            msg[i:i+divlen] = numpy.mod(msg[i:i+divlen] + div, 2)

    # Output the last error-checking code portion of the message generated
    return msg[-len(code):]

if False:
    msg = numpy.zeros(76, dtype=numpy.int32)
    msg[3] = 1
    msg[7] = 1
    msg[44] = 1
    msg[45] = 1
    msg[46] = 1
    msg[51] = 1
    msg[61] = 1
    msg[71] = 1
    cksum = crc(msg, crc12poly)
    # cksum = crc_c(msg)
    expected = [ 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0 ]
    eq = numpy.equal(cksum, numpy.array(expected, dtype=numpy.int32))
    assert numpy.all(eq)
    sys.exit(1)

# gadget that returns FFT buckets of a fixed set of
# original samples, with required (inter-bucket)
# frequency, drift, and offset.
class FFTCache:
    def __init__(self, samples, jrate, jblock):
        self.jrate = jrate
        self.jblock = jblock
        self.samples = samples

        fg = 1.0 / coarse_fstep
        if fine_fstep > 0:
            fg /= fine_fstep
        self.bin_granules = int(round(fg))

        bg = 1.0 / coarse_tstep
        if fine_tstep > 0:
            bg /= fine_tstep
        self.block_granules = int(round(bg))

        # compute self.all[][]
        self.makeall()

    # do all the FFTs, for all granules.
    def makeall(self):
        bin_hz = self.jrate / float(self.jblock)

        # all[79*granules][fftsize*granules]
        # all[block*granules+blockoff][bin*granules+binoff]
        nx1 = len(self.samples) // self.jblock
        nxall = self.block_granules * nx1
        ny1 = (self.jblock // 2) + 1
        nyall = self.bin_granules * ny1
        self.all = numpy.zeros((nxall, nyall))

        for i in range(0, self.bin_granules):
            freq_off = i * (bin_hz / self.bin_granules)
            ss = weakutil.freq_shift(self.samples, -freq_off, 1.0/self.jrate)
            bi = 0
            while True:
                off = bi * (self.jblock / self.block_granules)
                if off + self.jblock > len(ss):
                    break
                block = ss[off:off+self.jblock]
                a = numpy.fft.rfft(block)
                a = abs(a)
                # m[bi] = a
                self.all[bi][i::self.bin_granules] = a
                bi += 1

    # binkey is 0..self.bin_granules
    # blockkey is 0..self.block_granules
    def make(self, binkey, blockkey):
        m = self.all[blockkey::self.block_granules,binkey::self.bin_granules]
        return m

    # return bins[symbol][bin] -- i.e. a mini-FFT per symbol.
    def get(self, hz, start):
        m = self.getall(hz, start)
        bin_hz = self.jrate / float(self.jblock)
        bin = int(hz / bin_hz)
        return m[start // self.jblock : , bin : bin+8]

    # not used yet, but does hz drift.
    def new_get(self, hza, start):
        bin_hz = self.jrate / float(self.jblock)

        nx = len(self.samples) // self.jblock
        m = numpy.zeros((nx, 8))

        for x in range(0, nx):
            offset = start + x*self.jblock
            xi = offset // (self.jblock // self.block_granules)
            hz = hza[0] + (hza[1] - hza[0]) * (x / float(nx))
            hzi = int(round(hz / (bin_hz / self.bin_granules)))
            if xi < self.all.shape[0]:
                m[x] = self.all[xi][hzi:hzi+8*self.bin_granules:self.bin_granules]

        return m

    # return the complete set of FFTs, m[symbol][bin]
    # hz and start just cause a sub-bin and sub-symbol shift.
    # that is, the returned array starts near hz=0
    # and offset=0.
    def getall(self, hz, start):
        # which quarter-bin?
        bin_hz = self.jrate / float(self.jblock)
        bin = int(hz / bin_hz)
        binfrac = (hz / bin_hz) - bin
        binkey = int(binfrac / (1.0 / self.bin_granules))
        
        # which eighth-block?
        blockoff = start % self.jblock
        blockkey = int(blockoff / (self.jblock / self.block_granules))

        m = self.make(binkey, blockkey)
        
        return m

    def len(self):
        return len(self.samples)

# for unpack() &c.
NBASE = 37*36*10*27*27*27
# start of special grid locators for sig strength &c.
NGBASE = 180*180

class FT8:
  debug = False

  offset = 0

  def __init__(self):
      self.msgs_lock = threading.Lock()
      self.msgs = [ ]
      self.verbose = False
      self.enabled = True
      self.extra_budget = 0
      self.hints = [ ]
      self.band = "-"
      self.carddesc = None
      self.restrict_hz = None

      self.jrate = 12000 // 2 # sample rate for processing (FFT &c)
      self.jblock = 1920 // 2 # samples per symbol

      # set self.start_time to the UNIX time of the start
      # of the last UTC minute.
      now = int(time.time())
      gm = time.gmtime(now)
      self.start_time = now - gm.tm_sec

      make_normal_table()

  def close(self):
      pass

  def junklog(self, samples_time, msg):
      minute = self.minute(samples_time + 1)
      gm = time.gmtime(self.minute2time(minute))
      hms = "%02d:%02d:%02d" % (
          gm.tm_hour,
          gm.tm_min,
          gm.tm_sec)
      msg = "%s %s %s %s\n" % (self.ts(time.time()),
                               hms,
                               self.carddesc,
                               msg)
      
      #sys.stderr.write(msg)
      f = open("ft8-junk.txt", "a")
      f.write(msg)
      f.close()

  # seconds per cycle
  def cycle_seconds(self):
      return 15

  # return the minute number for t, a UNIX time in seconds.
  # truncates down, so best to pass a time mid-way through a minute.
  # returns only even minutes.
  def minute(self, t):
      dt = t - self.start_time
      return int(dt / 15.0)

  # convert cycle number to UNIX time.
  def minute2time(self, m):
      return (m * 15) + self.start_time

  # seconds since minute(), 0..15
  def second(self, t):
      dt = t - self.start_time
      dt /= 15.0
      return 15.0 * (dt - int(dt))

  def seconds_left(self, t):
      return 15 - self.second(t)

  # printable UTC timestamp, e.g. "07/07/15 16:31:00"
  # dd/mm/yy hh:mm:ss
  # t is unix time.
  def ts(self, t):
      gm = time.gmtime(t)
      return "%02d/%02d/%02d %02d:%02d:%02d" % (gm.tm_mday,
                                                gm.tm_mon,
                                                gm.tm_year - 2000,
                                                gm.tm_hour,
                                                gm.tm_min,
                                                gm.tm_sec)

  # UNIX time to HHMMSS
  def hhmmss(self, t):
      gm = time.gmtime(t)
      return "%02d%02d%02d" % (gm.tm_hour, gm.tm_min, gm.tm_sec)

  def openwav(self, filename):
    self.wav = wave.open(filename)
    self.wav_channels = self.wav.getnchannels()
    self.wav_width = self.wav.getsampwidth()
    self.cardrate = self.wav.getframerate()

  def readwav(self, chan):
    z = self.wav.readframes(8192)
    if self.wav_width == 1:
      zz = numpy.fromstring(z, numpy.int8)
    elif self.wav_width == 2:
      if (len(z) % 2) == 1:
        return numpy.array([])
      zz = numpy.fromstring(z, numpy.int16)
    else:
      sys.stderr.write("oops wave_width %d" % (self.wav_width))
      sys.exit(1)
    if self.wav_channels == 1:
      return zz
    elif self.wav_channels == 2:
      return zz[chan::2] # chan 0/1 => left/right
    else:
      sys.stderr.write("oops wav_channels %d" % (self.wav_channels))
      sys.exit(1)

  def gowav(self, filename, chan):
    self.openwav(filename)
    bufbuf = [ ]
    while True:
      buf = self.readwav(chan)
      if buf.size < 1:
        break
      bufbuf.append(buf)
    samples = numpy.concatenate(bufbuf)

    # trim trailing zeroes that wsjt-x adds to .wav files.
    i = len(samples)
    while i > 1000 and numpy.max(samples[i-1:]) == 0.0:
        if numpy.max(samples[i-1000:]) == 0.0:
            i -= 1000
        elif numpy.max(samples[i-100:]) == 0.0:
            i -= 100
        elif numpy.max(samples[i-10:]) == 0.0:
            i -= 10
        else:
            i -= 1
    samples = samples[0:i]

    self.process(samples, 0)

  def opencard(self, desc):
      self.carddesc = desc
      self.cardrate = 6000 # 12000 // 2
      self.audio = weakaudio.new(desc, self.cardrate)

  def gocard(self):
      bufbuf = [ ]
      nsamples = 0
      prev_buf_time = None
      last_tmin = None
      rate_t0 = None # track long-term sample rate
      rate_v0 = None
      rate_n = 0
      rate_last = 0
      self.audio.read() # get the SDR-IP started
      while True:
          sec0 = self.second(time.time())
          if sec0 < 13.14:
              # read big chunks so that the SDR-IP I/Q to USB
              # conversion works better.
              time.sleep(13.14 - sec0)

          [ buf, buf_time ] = self.audio.read()

          # buf_time is the UNIX time of the last sample in buf[].

          if len(buf) > 0:
              # is there a gap in the sample stream?
              if prev_buf_time != None:
                  dt = buf_time - prev_buf_time
                  expected = self.cardrate * dt
                  got = len(buf)
                  if abs(expected-got) > 2:
                      self.junklog(buf_time,
                                   "gocard expected %d got %d" % (expected, got))

              mx = numpy.max(numpy.abs(buf))
              if mx > 30000:
                  sys.stderr.write("!")
              bufbuf.append(buf)
              nsamples += len(buf)
              prev_buf_time = buf_time
              if True:
                  if rate_t0 == None:
                      rate_t0 = time.time() - len(buf)*(1.0/self.cardrate)
                      rate_v0 = buf_time - len(buf)*(1.0/self.cardrate)
                  rate_n += len(buf)
                  if time.time() - rate_last >= 60:
                      rate1 = rate_n / float(time.time() - rate_t0)
                      rate2 = rate_n / float(buf_time - rate_v0)
                      self.junklog(buf_time, "rate %.3f %.3f" % (rate1, rate2))
                      rate_last = time.time()
          else:
              # self.audio.read() is non-blocking, so sleep a bit.
              time.sleep(0.1)

          # an FT8 frame starts on second 0.5, and takes 12.64 seconds.
          if nsamples >= 13.14*self.cardrate:
              sec = self.second(buf_time)
              if sec >= 13.14:
                  # we have >= 13.14 seconds of samples,
                  # and second of minute is >= 13.14.

                  self.junklog(buf_time, "%.2f %.2f %.2f %.2f %d" % (nsamples/float(self.cardrate),
                                                                  self.second(buf_time),
                                                                  self.second(time.time()),
                                                                  sec0,
                                                                  len(buf)))

                  samples = numpy.concatenate(bufbuf)

                  excess = len(samples) - 15*self.cardrate
                  if excess < -1000 or excess > 1000:
                      self.junklog(buf_time, "gocard excess %d" % (excess))

                  # sample # of start of 15-second interval.
                  i0 = len(samples) - self.cardrate * self.second(buf_time)
                  i0 = int(i0)
                  i0 = max(i0, 0)

                  # UNIX time of samples[i0]
                  samples_time = buf_time - (len(samples)-i0) * (1.0/self.cardrate)

                  tmin = self.minute(samples_time + 1)
                  if last_tmin != None and tmin != last_tmin + 1:
                      self.junklog(samples_time, "gocard jumped minute %d %d" % (last_tmin, tmin))
                  last_tmin = tmin

                  self.process(samples[i0:], samples_time)

                  bufbuf = [ ]
                  nsamples = 0

  # received a message, add it to the list.
  # offset in seconds.
  # drift in hz/minute.
  def got_msg(self, dec):
      self.msgs_lock.acquire()

      # already in msgs with worse nerrs?
      found = False
      for i in range(max(0, len(self.msgs)-40), len(self.msgs)):
          xm = self.msgs[i]
          if xm.minute == dec.minute and abs(xm.hz() - dec.hz()) < 10 and xm.msg == dec.msg:
              # we already have this msg
              found = True
              if dec.snr > xm.snr:
                  self.msgs[i] = dec
                  
      if found == False:
          self.msgs.append(dec)

      self.msgs_lock.release()

  # someone wants a list of all messages received,
  # as array of Decode.
  def get_msgs(self):
      self.msgs_lock.acquire()
      a = self.msgs
      self.msgs = [ ]
      self.msgs_lock.release()
      return a

  # c is a pipe from a sub-process.
  def readchild(self, c, samples_time):
      start_time = time.time()
      n = 0
      while True:
          try:
              # poll so we won't wait forever if the sub-process
              # is wedged.
              some = c.poll(budget + self.extra_budget + 1)
              if some == False:
                  break
              dec = c.recv()
              self.got_msg(dec)
              n += 1
          except:
              break

      dt = time.time() - start_time
      if dt > budget + self.extra_budget + 0.5:
          self.junklog(samples_time, "sub-process did not quit %.1f got %d" % (dt, n))

      c.close()

  # run the FT8 decode in a separate process. this yields
  # much more parallelism for multiple receivers than
  # Python's threads.
  # samples_time is UNIX time that samples[0] was
  # sampled by the sound card.
  def process(self, samples, samples_time):
      min_hz = 100
      max_hz = 2500
      if self.restrict_hz != None:
          if self.restrict_hz[0] > min_hz:
              min_hz = self.restrict_hz[0]
          if self.restrict_hz[1] < max_hz:
              max_hz = self.restrict_hz[1]

      global very_first_time
      if profiling or very_first_time:
          # warm things up.
          very_first_time = False
          thunk = (lambda dec : self.got_msg(dec))
          self.process0(samples, samples_time, thunk, min_hz, max_hz)
          return

      ss = self.second(time.time())
      if self.band != "-" and self.enabled and (ss > 13.8 or ss < 13):
          self.junklog(samples_time, "late start %.1f" % (self.second(time.time())))
      sys.stdout.flush()

      nchildren = 2
      procs = [ ]
      readers = [ ]
      for chi in range(0, nchildren):
          # adjust min_hz and max_hz
          hzinc = (max_hz - min_hz) / nchildren
          hz0 = min_hz + chi*hzinc
          hz1 = hz0 + hzinc
          if chi > 0:
              hz0 -= 60
          if chi < nchildren-1:
              hz1 += 60
          
          rpipe, spipe = multiprocessing.Pipe(False)
          px = multiprocessing.Process(target=self.process00,
                                         args=[samples, samples_time, spipe, rpipe,
                                               hz0, hz1])
          px.start()
          spipe.close()

          procs.append(px)

          th = threading.Thread(target=lambda c=rpipe: self.readchild(c, samples_time))
          th.start()
          readers.append(th)
          readers.append(th)

      oband = self.band

      # wait for the readchild threads.
      for chi in range(0, nchildren):
          readers[chi].join(budget+self.extra_budget+1.0)
          procs[chi].terminate()
          procs[chi].join(0.5)

      if os.path.isfile("./savewave"):
          filename = "save/%s-%s-%d.wav" % (self.hhmmss(samples_time), oband, n)
          #print "%s saving %s" % (self.carddesc, filename)
          weakutil.writewav1(samples, filename, self.cardrate)

      if self.band != "-" and self.enabled and self.second(time.time()) > 13:
          self.junklog(samples_time, "late end %.1f" % (self.second(time.time())))

  def process00(self, samples, samples_time, spipe, rpipe, min_hz, max_hz):
      rpipe.close()
      thunk = (lambda dec : spipe.send(dec))
      self.process0(samples, samples_time, thunk, min_hz, max_hz)
      spipe.close()

  def process0(self, samples, samples_time, thunk, min_hz, max_hz):
    global budget, ldpc_iters, fine_tstep

    if self.enabled == False:
        return

    # samples_time is UNIX time that samples[0] was
    # sampled by the sound card.
    samples_minute = self.minute(samples_time + 1)

    t0 = time.time()

    #assert self.cardrate == self.jrate
    if self.cardrate != self.jrate:
        r = weakutil.Resampler(self.cardrate, self.jrate)
        samples = r.resample(samples)

    # nominal signal start time is half a second into samples[].
    # prepend and append padding.
    # result: end_pad samples, then start of on-time signals.
    start_pad = int(2.5 * self.jrate)
    end_pad = int(2.5 * self.jrate)
    sm = numpy.mean(samples[12000:20000]) # pad with plausible signal levels
    sd = numpy.std(samples[12000:20000])
    sd /= 4.0
    # sm /= 4.0
    # sd /= 4.0
    samples = numpy.append(numpy.random.normal(sm, sd, start_pad - self.jrate//2), samples)
    wanted = 79*self.jblock + start_pad + end_pad - len(samples)
    if wanted > 0:
        samples = numpy.append(samples, numpy.random.normal(sm, sd, wanted))

    bin_hz = self.jrate / float(self.jblock)
    
    # I think signals should start 0.5 seconds into the minute,
    # at offset start_pad. But it seems like they generally start
    # later, captured by start_adj.
    adjusted_start = start_pad + int(self.jrate * start_adj)

    # find a clear spot, to help avoid our replies interfering.
    clear_hz = self.find_clear(samples[adjusted_start:])

    ssamples = numpy.copy(samples) # for subtraction

    # suppress duplicate message decodes,
    # indexed by message text.
    already = { }

    ndecoded = 0

    for phase in [ 0, 1, 2 ]:
        used = time.time() - t0
        if used >= budget + self.extra_budget:
            break

        if phase == 0:
            # look at hints first; these are hz's that we recently decoded at.
            # ranking = self.hints
            ranking = [ ] # not this form of hinting any more; skip phase 0
        elif phase == 1:
            # non-subtracted
            xf = FFTCache(samples, self.jrate, self.jblock)
            ranking = self.coarse(xf, adjusted_start, min_hz, max_hz)
        elif phase == 2:
            # revisit coarse list, with subtracted ssamples
            xf = FFTCache(ssamples, self.jrate, self.jblock)
            ranking = self.coarse(xf, adjusted_start, min_hz, max_hz)

        # suppress duplicate attempts to look at
        # the same hz and offset. duplicates can arise
        # due to find_*slop.
        # indexed by "hz-offset".
        already_hzo = { }

        for rr in ranking:
            used = time.time() - t0
            if used >= budget + self.extra_budget:
                break

            left = budget - used
            # if phase == 1 and ndecoded >= 1 and used > budget * subtime:
            # if phase == 1 and ndecoded >= submin and (left > 0.6 or used > budget+1):
            if phase == 1 and ndecoded >= 1 and used > budget * subtime:
                # switch to subtracted ssamples for phase 2
                break

            # rr is [ hz, offset, strength ]
            hz = rr[0]
            offset = rr[1]

            hz0 = hz
            offset0 = offset

            if offset < 0 or (offset+79*self.jblock) > len(samples):
                continue

            if fine_tstep > 0.0001:
                # improve the starting offset.
                offslop = int(self.jblock * coarse_tstep * 0.5)
                offstep = int(self.jblock * coarse_tstep * fine_tstep)
                offs = self.best_offsets(xf, hz, offset, offslop, offstep, False)
                [ offset, strength ] = offs[0]
            if fine_fstep > 0.0001 and phase > 0:
                # improve the starting hz.
                hzslop = coarse_fstep * bin_hz * 0.5
                hzstep = coarse_fstep * bin_hz * fine_fstep
                [ hz, strength ] = self.best_freq(xf, hz, offset, hzslop, hzstep)
                
            key = "%d-%d" % (int(round(hz)), offset)
            if key in already_hzo:
                continue
            already_hzo[key] = True

            ss = xf.get(hz, offset)
            # ss has 79 8-bucket mini-FFTs.

            dec = self.process1(ss[0:79], hz)

            if False and dec == False and fine_tstep > 0.0001:
                # improve the starting offset, look for CQ.
                # this turns out not to be worth the CPU time.
                offs = self.best_offsets(xf, hz0, offset0, offslop, offstep, True)
                if offs[0][0] != offset:
                    offset = offs[0][0]
                    ss = xf.get(hz0, offset)
                    dec = self.process1(ss[0:79], hz0)
                    if dec != False:
                        sys.stderr.write("cq win %s" % (dec.msg))
                        sys.stdout.write("cq win %s" % (dec.msg))

            if False:
                dt = ((offset - start_pad) / float(self.jrate))
                if dec != None:
                    print "%d [%.1f %d %.2f] %.1f %d %.1f %s" % (phase, rr[0], rr[1], rr[2], hz, offset, dt, dec.msg)
                else:
                    print "%d [%.1f %d %.2f] %.1f %d %.1f" % (phase, rr[0], rr[1], rr[2], hz, offset, dt)
                sys.stdout.flush()

            if dec != None:
                dec.minute = samples_minute
                dec.dt = ((offset - start_pad) / float(self.jrate))
                dec.start = offset
                dec.clear_hz = clear_hz
                if do_subtract >= 3 and phase <= 1:
                    ssamples = self.subtract_v4(ssamples, dec, dec.hz())
                if not dec.msg in already:
                    ndecoded += 1
                    if do_subtract == 1 and phase <= 1:
                        ssamples = self.subtract_v4(ssamples, dec, dec.hz())
                    if do_subtract == 2 and phase <= 1:
                        ssamples = self.subtract_v4(ssamples, dec, dec.hz())
                        ssamples = self.subtract_v4(ssamples, dec, dec.hz() - subgap)
                        ssamples = self.subtract_v4(ssamples, dec, dec.hz() + subgap)
                    already[dec.msg] = True
                    if self.verbose:
                        print("%s %s %4.1f %6.1f %5d %.1f %.0f %s" % (["HY","HN","HN"][phase],
                                                                      self.band,
                                                                      self.second(dec.decode_time),
                                                                      hz,
                                                                      dec.start,
                                                                      dec.dt,
                                                                      dec.snr,
                                                                      dec.msg))
                    thunk(dec)

  # find a clear hz in case we want to reply.
  # samples[] starts at nominal start time (0.5 seconds).
  def find_clear(self, samples):
      bin_hz = self.jrate / float(self.jblock)
      occupied1 = numpy.zeros((self.jblock // 2) + 1)
      for sec in [ 2, 4, 6, 7, 9, 11 ]:
          i1 = int(sec*self.jrate)
          i2 = i1 + self.jblock
          occupied1 += abs(numpy.fft.rfft(samples[i1:i2]))
      occupied2 = numpy.copy(occupied1)
      for bi in range(1, 8):
          occupied2[0:-bi] += occupied1[bi:]
      b1 = int(300 / bin_hz)
      b2 = int(2100 / bin_hz)
      clear_bin = numpy.argmin(occupied2[b1:b2]) + b1
      clear_hz = clear_bin * bin_hz
      return clear_hz

  # # subtract a decoded signal, which may help decodes of buried signals.
  # def subtract(self, dec, xf):
  #     snd = FT8Send()
  #     s79 = snd.make_symbols(dec.twelve)
  #     xf.subtract(dec.hz(), dec.start, s79)

  # subtract a decoded signal (hz/start/twelve) from the samples,
  # to that we can then decode weaker signals underneath it.
  # i.e. interference cancellation.
  # generates the right tone for each symbol, finds the best
  # offset w/ correlation, finds the amplitude, subtracts in the time domain.
  def subtract_v4(self, osamples, dec, hz0):
      bin_hz = self.jrate / float(self.jblock)

      # the 79 symbols, each 0..8
      snd = FT8Send()
      symbols = snd.make_symbols(dec.twelve)

      samples = numpy.copy(osamples)

      if dec.start < 0:
          samples = numpy.append([0.0]*(-dec.start), samples)
      else:
          samples = samples[dec.start:]

      bigslop = int(self.jblock * subslop)

      # find amplitude of each symbol.
      amps = [ ]
      offs = [ ]
      tones = [ ]
      i = 0
      while i < len(symbols):
          nb = 1
          while i+nb < len(symbols) and symbols[i+nb] == symbols[i]:
              nb += 1

          hz = hz0 + symbols[i] * bin_hz
          tone = weakutil.costone(self.jrate, hz, self.jblock*nb)

          # nominal start of symbol in samples[]
          i0 = i * self.jblock
          i1 = i0 + nb*self.jblock
          
          # search +/- slop.
          # we search separately for each symbol b/c the
          # phase may drift over the minute, and we
          # want the tone to match exactly.
          i0 = max(0, i0 - bigslop)
          i1 = min(len(samples), i1 + bigslop)
          cc = numpy.correlate(samples[i0:i1], tone)
          mm = numpy.argmax(cc) # thus samples[i0+mm]

          # what is the amplitude?
          # if actual signal had a peak of 1.0, then
          # correlation would be sum(tone*tone).
          cx = cc[mm]
          c1 = numpy.sum(tone * tone)
          a = cx / c1

          amps.append(a)
          offs.append(i0+mm)
          tones.append(tone)

          i += nb

      ai = 0
      while ai < len(amps):
          a = amps[ai]
          off = offs[ai]
          tone = tones[ai]
          samples[off:off+len(tone)] -= tone * a
          ai += 1

      if dec.start < 0:
          nsamples = samples[(-dec.start):]
      else:
          nsamples = numpy.append(osamples[0:dec.start], samples)

      return nsamples
    
  # find hz with best Costas sync at offset=start.
  # look at frequencies midhz +/ slop,
  # at granule hz increments.
  # returns [ hz, strength ]
  def best_freq(self, xf, midhz, start, slop, granule):
      start = int(start)
      bin_hz = self.jrate / float(self.jblock)
      
      # a Costas sync array.
      costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
      costas_array = numpy.ones((7, 8)) * (-1 / 7.0)
      for i in range(0, len(costas_symbols)):
          costas_array[i][costas_symbols[i]] = 1

      hz0 = midhz - slop
      hz1 = midhz + slop

      corrs = [ ]
      for hz in numpy.arange(hz0, hz1*1.0001, granule):
          ss = xf.get(hz, start)
          if len(ss) < 79:
              continue
          # ss has 79 8-bucket mini-FFTs.

          a = ss[0:7] + ss[36:43] + ss[72:79]
          norm = numpy.sum(a)
          b = a * costas_array
          c = numpy.sum(b)
          c = c / norm

          if True and contrast_weight > 0:
              # factor in contrast: how much the strongest bin
              # in each symbol time is stronger than the second-
              # strongest.
              # sort the 8 bins in each symbol time.
              sss = numpy.sort(ss)
              contrasts = numpy.divide(sss[:,7],
                                       sss[:,6],
                                       out=numpy.ones(len(sss)),
                                       where=sss[:,6]!=0)
              contrast = numpy.sum(contrasts)
              contrast /= len(sss)
              
              c += (contrast - 1.0) * contrast_weight

          corrs.append([hz, c])

      corrs = sorted(corrs, key = lambda e : - e[1])
      return corrs[0]

  # find offset with best Costas sync at hz.
  # looks at offsets at start +/- slop,
  # at granule offset increments.
  # returns [ [ start, strength ], ... ]
  def best_offsets(self, xf, hz, start, slop, granule, find_cq):
      start = int(start)
      slop = int(slop)
      granule = int(granule)
      
      # a Costas sync array.
      costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
      costas_array = numpy.ones((7, 8)) * (-1 / 7.0)
      for i in range(0, len(costas_symbols)):
          costas_array[i][costas_symbols[i]] = 1

      # use CQ as a sync array.
      cq_symbols = [ 7, 6, 4, 0, 4, 0, 6, 1, 4 ]
      cq_array = numpy.ones((9, 8)) * (-1 / 7.0)
      for i in range(0, len(cq_symbols)):
          cq_array[i][cq_symbols[i]] = 1

      off0 = start - slop
      off1 = start + slop
      corrs = [ ]
      for off in range(off0, off1+4, granule):
          if off + 79 * self.jblock > xf.len():
              continue
          ss = xf.get(hz, off)
          if len(ss) < 79:
              continue
          # ss has 79 8-bucket mini-FFTs.

          a = ss[0:7] + ss[36:43] + ss[72:79]
          norm = numpy.sum(a)
          b = a * costas_array
          c = numpy.sum(b)
          c = c / norm # we care about strength of correlation, not sig ampl

          if find_cq:
              # assume it's a CQ, and add in correlation with
              # the 28 bits at bit 87 (9 symbols at symbol 29).
              # in real life about 1/4 of messages are CQs.
              # CQ's 28 bits: 1111101000001000001100011001
              # turns out to be not worth the extra CPU.
              a = ss[43:43+9]
              norm = numpy.sum(a)
              b = a * cq_array
              bsum = numpy.sum(b)
              c += bsum / norm

          if False and contrast_weight > 0:
              # factor in contrast: how much the strongest bin
              # in each symbol time is stronger than the second-
              # strongest.
              # sort the 8 bins in each symbol time.
              sss = numpy.sort(ss)
              contrasts = numpy.divide(sss[:,7],
                                       sss[:,6],
                                       out=numpy.ones(len(sss)),
                                       where=sss[:,6]!=0)
              contrast = numpy.sum(contrasts)
              contrast /= len(sss)
              
              c += (contrast - 1.0) * contrast_weight

          corrs.append([off, c])

      corrs = sorted(corrs, key = lambda e : - e[1])
      return corrs

  def coarse1(self, xf, adjusted_start, hzoff, offoff, min_hz, max_hz):
      # prepare a template for 2d correlation containing
      # the three Costas arrays.
      costas = [ 2, 5, 6, 0, 4, 1, 3 ]
      template = numpy.zeros((79, 8))
      for i0 in [ 0, 36, 72 ]:
          for i1 in range(0, 7):
              template[i0+i1,:] = -1 / 7.0
              template[i0+i1,costas[i1]] = 1

      # m[symbol][bin]
      m = xf.getall(hzoff, offoff)

      bin_hz = self.jrate / float(self.jblock)
      min_hz_bin = int(min_hz / bin_hz)
      max_hz_bin = int(max_hz / bin_hz)

      min_sym = int((adjusted_start - self.jrate*coarse_tminus) / self.jblock)
      max_sym = int((adjusted_start + self.jrate*coarse_tplus) / self.jblock)

      m = m[min_sym:79+max_sym,min_hz_bin:max_hz_bin]

      if True:
          mlen = len(m)
          tlen = len(template)
          minussyms = int(round((self.jrate * coarse_tminus) / float(self.jblock)))
          plussyms = int(round((self.jrate * coarse_tplus) / float(self.jblock)))
          slopsyms = minussyms + plussyms
          m = numpy.concatenate([ m[0:7+slopsyms],
                                  m[36:43+slopsyms],
                                  m[72:79+slopsyms] ])
          template = numpy.concatenate( [ template[0:7+slopsyms],
                                          template[36:43+slopsyms],
                                          template[72:79] ] )
      
      # for each frequency bin, the total signal level for
      # it and the next eight bins up. we'll divide by this
      # in order to emphasize the correlation, not the
      # signal (or noise) level.
      binsum = numpy.sum(m, axis=0)
      norm = numpy.zeros(len(binsum))
      for i in range(0, 8):
          norm[0:len(norm)-i] += binsum[i:]

      c = scipy.signal.correlate2d(m, template, mode='valid')

      if False:
          h = [ [ (bi+min_hz_bin) * bin_hz + hzoff,
                  (si+min_sym) * self.jblock + offoff,
                  c[si,bi] / norm[bi]
                ]
                for si in range(0, c.shape[0]) for bi in range(0, c.shape[1]) ]
      else:
          # best few starting symbol indices for each frequency bin.
          # so we only return a few elements per bin, not
          # one element per bin per starting symbol index.
          max_si = numpy.argsort(-c, axis=0)
          h = [ ]
          for mi in range(0, coarse_no):
              h += [ [ (bi+min_hz_bin) * bin_hz + hzoff,
                      (max_si[mi][bi]+min_sym) * self.jblock + offoff,
                      c[max_si[mi][bi],bi] / norm[bi]
                    ]
                    for bi in range(0, max_si.shape[1]) ]

      return h

  def coarse(self, xf, adjusted_start, min_hz, max_hz):
      bin_hz = self.jrate / float(self.jblock)

      h = [ ]
      for hzoff in numpy.arange(0.0, bin_hz, bin_hz * coarse_fstep):
          for offoff in range(0, self.jblock, int(self.jblock * coarse_tstep)):
              hx = self.coarse1(xf, adjusted_start, hzoff, offoff, min_hz, max_hz)
              h += hx

      # boost scores of hinted hz/offset pairs.
      # but no evidence that this is a net win.
      if False and len(self.hints) > 0:
          # granularity: half-bin half-block
          def make_key(hz, off):
              key = str(int(round(hz / (bin_hz / 2))))
              key += "-"
              key += str(int(off / (self.jblock / 2)))
              return key
          d = { }
          for hi in self.hints:
              key = make_key(hi[0], hi[1])
              d[key] = True
          for hh in h:
              key = make_key(hh[0], hh[1])
              if key in d:
                  hh[2] *= 2

      h = sorted(h, key = lambda e : -e[2])

      return h

  # m79 is 79 8-bucket mini FFTs, for 8-FSK demodulation.
  # m79[0..79][0..8]
  def snr(self, m79):
    # estimate SNR.
    # mimics wsjt-x code, though the results are not very close.
    sigi = numpy.argmax(m79, axis=1)
    noisei = numpy.mod(sigi + 4, 8)
    noises = m79[range(0, 79), noisei]
    noise = numpy.mean(noises * noises) # square yields power
    sigs = numpy.amax(m79, axis=1) # guess correct tone
    sig = numpy.mean(sigs * sigs)
    rawsnr = sig / noise
    rawsnr -= 1 # turn (s+n)/n into s/n
    if rawsnr < 0.1:
        rawsnr = 0.1
    rawsnr /= (2500.0 / 2.7) # 2.7 hz noise b/w -> 2500 hz b/w
    snr = 10 * math.log10(rawsnr)
    snr += 3
    return snr

  ci3 = numpy.array([ 2, 5, 6, 0, 4, 1, 3,
                      2, 5, 6, 0, 4, 1, 3,
                      2, 5, 6, 0, 4, 1, 3 ], dtype=numpy.int32)

  # mean and std dev of winning and non-winning
  # FFT bins, to help compute probabilities of
  # symbol values for soft decoding.
  # m79 is 79 8-bucket mini FFTs, for 8-FSK demodulation.
  # m79[0..79][0..8]
  # returns None or a Decode.
  # return [ winmean, winstd, losemean, losestd ],
  # for use in LDPC decoder.
  def softstats(self, m79, i0=0, i1=79):

    if True:
        # this works best, 596 (574 of 675)
        winners = numpy.max(m79[i0:i1], 1)
        losers = m79[i0:i1]

    if False:
        # 595 (575 of 675)
        # just look at Costas arrays, where we know
        # which symbols are correct.
        cs = numpy.concatenate( [ m79[0:0+7], m79[36:36+7], m79[72:72+7] ] )
        winners = cs[range(0,21),self.ci3]
        losers = m79

    if False:
        # this works pretty well, old 575 (555 of 675).
        # just look at Costas arrays, where we know
        # which symbols are correct.
        winners = numpy.zeros(3*7)
        losers = numpy.zeros(3*7*7)
        costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
        wi = 0
        li = 0
        for i0 in [ 0, 36, 72 ]:
            for i1 in range(0, 7):
                cs = costas_symbols[i1]
                winners[wi] = m79[i0+i1][cs]
                wi += 1
                losers[li:li+cs] = m79[i0+i1][0:cs]
                losers[li+cs:li+7] = m79[i0+i1][cs+1:]
                li += 7

    if False:
        # this works pretty well, old 578 (558 of 675)
        n = len(m79)
        winners = numpy.zeros(n)
        losers = numpy.zeros(n * 7)
        for mi in range(0, n):
           e = m79[mi]
           wini = numpy.argmax(e) # guess the winning tone.
           winners[mi] = e[wini]
           li = mi * 7
           losers[li:li+wini] = e[0:wini]
           losers[li+wini:li+7] = e[wini+1:]

    if False:
        # this is ok, 573 (555 of 675)
        # look at all symbols.
        # we know the correct Costas values.
        # guess the others based on strength.
        winners = [ ]
        losers = [ ]
        costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
        for i in range(i0, i1):
            e = m79[i]
            good = False
            loudest = numpy.argmax(e)
            if (i >= 0 and i < 7) or (i >= 36 and i < 36+7) or (i >= 72 and i < 72+7):
                # in a costas block, so we know the correct symbol.
                if i >= 72:
                    ci = i - 72
                elif i >= 36:
                    ci = i - 36
                else:
                    ci = i
                wini = costas_symbols[ci]
                good = (wini == loudest)
            else:
                # we don't know correct symbol; use loudest.
                wini = loudest
            winners.append(e[wini])
            if good:
                # higher weight.
                winners.append(e[wini])

            losers += list(e[0:wini])
            losers += list(e[wini+1:])

    if False:
        import matplotlib.pyplot as plt
        plt.plot(winners)
        plt.plot(losers[::7])
        plt.show()

    winmean = numpy.mean(winners)
    winstd = numpy.std(winners)
    losemean = numpy.mean(losers)
    losestd = numpy.std(losers)

    return [ winmean, winstd, losemean, losestd ]

  # m79 is 79 8-bucket mini FFTs, for 8-FSK demodulation.
  # m79[0..79][0..8]
  # returns None or a Decode.
  def process1(self, m79, hz):
    if len(m79) < 79:
        return

    snr = self.snr(m79)

    # convert to S/N. this seems to help, though I do not know why.
    mm = numpy.median(m79, 1)
    mm = numpy.select( [ mm > 0.000001 ], [ mm ], default=numpy.mean(mm))
    sm = numpy.stack([mm,mm,mm,mm,mm,mm,mm,mm], 1)
    m79 = numpy.divide(m79, sm)

    [ winmean, winstd, losemean, losestd ] = self.softstats(m79)
    dec = self.process2(m79, hz, snr, winmean, winstd, losemean, losestd)

    return dec

  def winfn(self, a, window, fn):
      out = numpy.array([])
      i = 0
      while i < len(a):
          if i == 0:
              block = a[i:i+(2*window)]
          else:
              block = a[i-window:i+(2*window)]
          x = fn(block)
          out = numpy.append(out, numpy.repeat(x, window))
          i += window
      if len(out) > len(a):
          out = out[0:len(a)]
      assert len(out) == len(a)
      return out

  # returns 174 log-likelihood values for whether each
  # bit is a zero.
  def loglikelihood(self, m58, winmean, winstd, losemean, losestd):

    if True:
        # 576 (556 of 675)
        # Bayes combining rule from:
        # http://cs.wellesley.edu/~anderson/writing/naive-bayes.pdf

        wm = winmean
        ws = winstd
        lm = losemean
        ls = losestd

        n = len(m58)
        ll174 = numpy.zeros(3 * n)

        bi = 0
        for [ v0, v1 ] in [
                # symbol numbers that make this bit zero and one.
                # most-significant bit first.
                [ [ 0, 1, 2, 3 ], [ 4, 5, 6, 7 ] ],
                [ [ 0, 1, 4, 5 ], [ 2, 3, 6, 7 ] ],
                [ [ 0, 2, 4, 6 ], [ 1, 3, 5, 7 ] ],
                ]:
            # treat each of the three bits in a symbol separately.
            
            e0 = numpy.maximum(
                   numpy.maximum(m58[range(0,n),v0[0]], m58[range(0,n),v0[1]]),
                   numpy.maximum(m58[range(0,n),v0[2]], m58[range(0,n),v0[3]]))
            e1 = numpy.maximum(
                   numpy.maximum(m58[range(0,n),v1[0]], m58[range(0,n),v1[1]]),
                   numpy.maximum(m58[range(0,n),v1[2]], m58[range(0,n),v1[3]]))

            # start with measured a-priori bit probabilities.
            pone = apriori174[bi::3]
            pzero = 1.0 - pone

            # P(zero)P(e0|zero)P(e1|zero)
            a = pzero * vproblt(e0, wm, ws) * vprobgt(e1, lm, ls)

            # P(one)P(e0|one)P(e1|one)
            b = pone * vprobgt(e0, lm, ls) * vproblt(e1, wm, ws)

            ab = a + b
            p0 = numpy.divide(a, ab, out=numpy.repeat(0.5, len(a)), where=ab!=0)

            # log likelihood of t0 being the correct symbol.
            # ll0 = log(p0 / (1 - p0))
            # log(148) = 4.99
            dd = numpy.divide(p0, (1.0 - p0), out=numpy.repeat(148.0, len(p0)), where=p0<0.99)
            ll = numpy.log(dd, out=numpy.repeat(-5.0, len(dd)), where=dd>0)

            ll = numpy.maximum(ll, -5.0)
            ll = numpy.minimum(ll, 5.0)

            ll174[bi::3] = ll
            bi += 1

    if False:
        # vectorized version of the code below.
        # this works well, though per symbol rather than per bit.
        m58sorted = numpy.argsort(-m58) # for each symbol, strongest tone number first

        t0 = m58sorted[:,0]      # number of strongest tone
        e0 = m58[range(0,58),t0] # strength of strongest tone
        t1 = m58sorted[:,1]      # second strongest
        e1 = m58[range(0,58),t1]

        p00 = vproblt(e0, winmean, winstd)   # P(receive e0 | t0 sent)
        p01 = vprobgt(e0, losemean, losestd) # P(receive e0 | t0 NOT sent)
        p10 = vprobgt(e1, losemean, losestd) # P(receive e1 | t1 NOT sent)
        p11 = vproblt(e1, winmean, winstd)   # P(receive e1 | t1 sent)

        # XXX the above basically assumes there are only two possibilities, t0 and t1.
        # better P(receive e1 | t0 sent) &c

        # Bayes' rule for P(t0 was sent)
        # XXX is the 0.5 right for 8-FSK?
        a = 0.5 * p00 * p10
        b = 0.5 * p00 * p10 + 0.5 * p01 * p11
        p0 = numpy.divide(a, b, out=numpy.repeat(0.5, len(a)), where=b!=0) # p0 = a / b

        # log likelihood of t0 being the correct symbol.
        # ll0 = log(p0 / (1 - p0))
        dd = numpy.divide(p0, (1.0 - p0), out=numpy.ones(len(p0)), where=p0!=1.0) # dd = p0 / (1 - p0)
        ll0 = numpy.log(dd)
        ll0 = numpy.select( [ p0 <= 0.99 ], [ ll0 ], default=5.0)

        ll174 = numpy.zeros(174)

        xi = 0
        for bs in [ 2, 1, 0 ]:
            x = ll0

            bits = numpy.bitwise_and(numpy.right_shift(t0, bs), 1)

            bits1 = numpy.bitwise_and(numpy.right_shift(t1, bs), 1) # from second-strongest
            boost = numpy.select([ bits == bits1 ], [ numpy.ones(len(bits)) ], default=0.0)
            boost = softboost * boost
            x = x + boost

            bits = (bits * 2) - 1 # one bit is 1, zero bit is -1
            x = x * (0 - bits) # log liklihood, positive for zero bits, neg for one bits
            ll174[xi::3] = x
            xi += 1

        print ll174[0:18]

    if False:
        # soft: estimate probability of 0 for each bit.
        # this works well, though not vectorized.
        ll174 = [ ]
        m58sorted = numpy.argsort(-m58) # for each symbol, strongest tone number first
        for i in range(0, len(m58)):
            e = m58[i]

            # tone numbers sorted loudest first.
            #tones = sorted(range(0, 8), key = lambda i : -e[i])
            tones = m58sorted[i]

            # set up for Bayes on two loudest tones.
            # XXX should do Bayes over all eight tones.
            
            # if tones[0] were sent, how likely is e[tones[0]]?
            p00 = problt(e[tones[0]], winmean, winstd)
            # if tones[1] were sent, how likely is e[tones[0]]?
            p01 = probgt(e[tones[0]], losemean, losestd)

            # if tones[0] were sent, how likely is e[tones[1]]?
            p10 = probgt(e[tones[1]], losemean, losestd)
            # if tones[1] were sent, how likely is e[tones[1]]?
            p11 = problt(e[tones[1]], winmean, winstd)

            # Bayes' rule, for P(tones[0] was sent)
            a = 0.5 * p00 * p10
            b = 0.5*p00*p10 + 0.5*p01*p11
            if b == 0:
                p0 = 0.5
            else:
                p0 = a / b

            # log likelihood of tones[0] being the correct symbol.
            if p0 > 0.99:
                ll0 = 5.0
            else:
                ll0 = math.log(p0 / (1 - p0))

            # extract the three bits from this symbol,
            # most-significant bit first.
            # XXX the probability for each bit has a complex relationship
            #     to the probability the tone is correct, since second-best
            #     tone might leave some bits the same as best tone.

            # assert ll0 >= 0

            for bs in [ 2, 1, 0 ]:
                x = ll0
                if ((tones[0]>>bs) & 1) == ((tones[1]>>bs) & 1):
                    # second-strongest symbol has same bit here,
                    # so give us a boost. XXX how much boost is correct?
                    x += softboost
                if ((tones[0]>>bs) & 1) != 0:
                    x *= -1
                ll174.append(x)

    if False:
        # hard: strongest FFT bucket yields symbol.
        s58 = [ numpy.argmax(x) for x in m58 ]
        
        # turn each 3-bit symbol into three bits.
        # most-significant bit first.
        z = [ [ (x>>2)&1, (x>>1)&1, x&1 ] for x in s58 ]
        a174 = numpy.concatenate(z)

        # turn hard bits into 0.99 vs 0.01 log-likelihood,
        # log_e( P(bit=0) / P(bit=1) )
        two = numpy.array([ 4.6, -4.6 ], dtype=numpy.int32)
        ll174 = two[a174]

    return ll174

  def process2(self, m79, hz, snr, winmean, winstd, losemean, losestd):

    if winmean < 0.000001:
        # this happens when we look again at a signal that
        # has been subtracted by zeroing FFTCache bins.
        return None

    # get rid of the three 7-symbol Costas arrays.
    m58 = numpy.concatenate( [ m79[7:36], m79[43:72] ] )

    ll174 = self.loglikelihood(m58, winmean, winstd, losemean, losestd)

    # decode LDPC(174,87)
    [ ldpc_ok, a87 ] = ldpc_decode(ll174)

    forced = False
    if True and (len(a87) == 0 or ldpc_ok < 87):
        # force a CQ in and try again.
        llx = numpy.copy(ll174)
        cq = "1111101000001000001100011001"
        for i in range(0, len(cq)):
            if cq[i] == '0':
                llx[87+i] = 4.99
            else:
                llx[87+i] = -4.99
        [ ok1, a1 ] = ldpc_decode(llx)
        if ok1 == 87:
            ldpc_ok = ok1
            a87 = a1
            #forced = True
    if self.restrict_hz != None and (len(a87) == 0 or ldpc_ok < 87):
        # restrict_hz means we're looking for QSO replies.
        # force an AB1HL in and try again.
        llx = numpy.copy(ll174)
        ab1hl = "0100010110101010001111001111"
        for i in range(0, len(ab1hl)):
            if ab1hl[i] == '0':
                llx[87+i] = 4.99
            else:
                llx[87+i] = -4.99
        [ ok1, a1 ] = ldpc_decode(llx)
        if ok1 == 87:
            ldpc_ok = ok1
            a87 = a1
            forced = True

    if len(a87) == 0:
        # failure.
        return None

    if ldpc_ok < 50:
        # reject decodes with lots of LDPC parity check failures.
        # this does reject some messages that pass the CRC and
        # are correct, but also weeds out vast amounts of garbage.
        return None

    # check the CRC-12
    cksum = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
                crc12poly)
    if numpy.array_equal(cksum, a87[-12:]) == False:
        # CRC failed.
        return None

    # a87 is 75 bits of msg and 12 bits of CRC.
    # turn the first 72 bits into twelve 6-bit numbers,
    # for compatibility with FT8 unpack().
    # MSB.
    a72 = a87[0:72]
    twelve = [ ]
    for i in range(0, 72, 6):
        a = a72[i:i+6]
        x = (a[0] * 32 +
             a[1] * 16 +
             a[2] *  8 + 
             a[3] *  4 +
             a[4] *  2 +
             a[5] *  1)
        twelve.append(x)

    msg = self.unpack(twelve)

    if "000AAA" in msg:
        return None

    if ldpc_ok < 87:
        # some of the LDPC parity checks failed.
        # the CRC sometimes succeeds even for garbage.
        # so filter out syntactically broken decodes.
        # only accept CQ ... and AB1HL ...
        m1 = re.match(r'^ *CQ[ D].* [A-R][A-R][0-9][0-9] *$', msg)
        m2 = re.match(r'^ *AB1HL ', msg)
        if m1 == None and m2 == None:
            return None

    if False and ldpc_ok == 87:
        # remember codeword bits in order to figure out
        # a-priori bit value probabilities.
        # python bprob.py < ft8bits
        
        # re-encode
        n87 = numpy.copy(a87)
        cksum = crc(numpy.append(n87[0:72], numpy.zeros(4, dtype=numpy.int32)),
                    crc12poly)
        n87[-12:] = cksum
        n174 = ldpc_encode(n87)

        if False:
            for i in range(0, 10):
                sys.stdout.write("%4.1f " % (ll174[i]))
            sys.stdout.write("\n")
            for i in range(0, 10):
                sys.stdout.write("%4.1f " % (n174[i]))
            sys.stdout.write("\n")

        f = open("ft8bits", "a")
        for i in range(0, 174):
            f.write("%d" % (n174[i]))
        f.write("\n")
        f.close()

    dec = Decode([hz,hz], msg, snr, twelve, time.time())
    if forced:
        sys.stderr.write("forced %s\n" % (dec.msg))
    dec.errs = 87 - ldpc_ok
    return dec

  # convert packed character to Python string.
  # 0..9 a..z space
  def charn(self, c):
    if c >= 0 and c <= 9:
      return chr(ord('0') + c)
    if c >= 10 and c < 36:
      return chr(ord('A') + c - 10)
    if c == 36:
      return ' '
    # sys.stderr.write("jt65 charn(%d) bad\n" % (c))
    return '?'

  # x is an integer, e.g. nc1 or nc2, containing all the
  # call sign bits from a packed message.
  # 28 bits.
  def unpackcall(self, x):
    a = [ 0, 0, 0, 0, 0, 0 ]
    a[5] = self.charn((x % 27) + 10) # + 10 b/c only alpha+space
    x = int(x / 27)
    a[4] = self.charn((x % 27) + 10)
    x = int(x / 27)
    a[3] = self.charn((x % 27) + 10)
    x = int(x / 27)
    a[2] = self.charn(x%10) # digit only
    x = int(x / 10)
    a[1] = self.charn(x % 36) # letter or digit
    x = int(x / 36)
    a[0] = self.charn(x)
    return ''.join(a)

  # extract maidenhead locator
  def unpackgrid(self, ng):
    if ng == NGBASE+1:
        return "    "
    if ng >= NGBASE+1 and ng < NGBASE+31:
      return " -%02d" % (ng - (NGBASE+1)) # sig str, -01 to -30 DB
    if ng >= NGBASE+31 and ng < NGBASE+62:
      return "R-%02d" % (ng - (NGBASE+31))
    if ng == NGBASE+62:
      return "RO  "
    if ng == NGBASE+63:
      return "RRR "
    if ng == NGBASE+64:
      return "73  "
      
    lat = (ng % 180) - 90
    ng = int(ng / 180)
    lng = (ng * 2) - 180

    g = "%c%c%c%c" % (ord('A') + int((179-lng)/20),
                      ord('A') + int((lat+90)/10),
                      ord('0') + int(((179-lng)%20)/2),
                      ord('0') + (lat+90)%10)

    if g[0:2] == "KA":
        # really + signal strength
        sig = int(g[2:4]) - 50
        return "+%02d" % (sig)

    if g[0:2] == "LA":
        # really R+ signal strength
        sig = int(g[2:4]) - 50
        return "R+%02d" % (sig)

    #print "lat %d, long %d, %s" % (lat, lng, g)
    return g

  def unpack(self, a):
    # a[] has 12 0..63 symbols, or 72 bits.
    # turn them into the original human-readable message.
    # unpack([61, 37, 30, 28, 9, 27, 61, 58, 26, 3, 49, 16]) -> "G3LTF DL9KR JO40"
    nc1 = 0 # 28 bits of first call
    nc1 |= a[4] >> 2 # 4 bits
    nc1 |= a[3] << 4 # 6 bits
    nc1 |= a[2] << 10 # 6 bits
    nc1 |= a[1] << 16 # 6 bits
    nc1 |= a[0] << 22 # 6 bits

    nc2 = 0 # 28 bits of second call
    nc2 |= (a[4] & 3) << 26 # 2 bits
    nc2 |= a[5] << 20 # 6 bits
    nc2 |= a[6] << 14 # 6 bits
    nc2 |= a[7] << 8 # 6 bits
    nc2 |= a[8] << 2 # 6 bits
    nc2 |= a[9] >> 4 # 2 bits

    ng = 0 # 16 bits of grid
    ng |= (a[9] & 15) << 12 # 4 bits
    ng |= a[10] << 6 # 6 bits
    ng |= a[11]

    if ng >= 32768:
      txt = self.unpacktext(nc1, nc2, ng)
      return txt

    if nc1 == NBASE+1:
      c2 = self.unpackcall(nc2)
      grid = self.unpackgrid(ng)
      return "CQ %s %s" % (c2, grid)

    if nc1 >= 267649090 and nc1 <= 267698374:
        # CQ with suffix (e.g. /QRP)
        n = nc1 - 267649090
        sf = self.charn(n % 37)
        n /= 37
        sf = self.charn(n % 37) + sf
        n /= 37
        sf = self.charn(n % 37) + sf
        n /= 37
        c2 = self.unpackcall(nc2)
        grid = self.unpackgrid(ng)
        return "CQ %s/%s %s" % (c2, sf, grid)

    c1 = self.unpackcall(nc1)
    if c1 == "CQ9DX ":
        c1 = "CQ DX "
    m = re.match(r'^ *E9([A-Z][A-Z]) *$', c1)
    if m != None:
        c1 = "CQ " + m.group(1)
    c2 = self.unpackcall(nc2)
    grid = self.unpackgrid(ng)
    return "%s %s %s" % (c1, c2, grid)

  def unpacktext(self, nc1, nc2, nc3):
    c = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?"

    nc3 &= 32767
    if (nc1 & 1) != 0:
      nc3 += 32768
    nc1 >>= 1
    if (nc2 & 1) != 0:
      nc3 += 65536
    nc2 >>= 1
      
    msg = [""] * 22

    for i in range(4, -1, -1):
      j = nc1 % 42
      msg[i] = c[j]
      nc1 = nc1 // 42

    for i in range(9, 4, -1):
      j = nc2 % 42
      msg[i] = c[j]
      nc2 = nc2 // 42

    for i in range(12, 9, -1):
      j = nc3 % 42
      msg[i] = c[j]
      nc3 = nc3 // 42

    return ''.join(msg)

very_first_time = True
profiling = False

class FT8Send:
    def __init__(self):
        pass

    # convert a character into a number; order is
    # 0..9 A..Z space
    def nchar(self, ch):
        if ch >= '0' and ch <= '9':
            return ord(ch) - ord('0')
        if ch >= 'A' and ch <= 'Z':
            return ord(ch) - ord('A') + 10
        if ch == ' ':
            return 36
        print("NT65Send.nchar(%s) oops" % (ch))
        return 0

    # returns a 28-bit number.
    # we need call to be:
    #   lds lds d ls ls ls
    # l-etter, d-igit, s-pace
    # 28-bit number's high bits correspond to first call sign character.
    def packcall(self, call):
        call = call.strip()
        call = call.upper()

        if call == "CQ":
            return NBASE + 1
        if call == "QRZ":
            return NBASE + 2
        if call == "DE":
            return 267796945

        if len(call) > 2 and len(call) < 6 and not call[2].isdigit():
            call = " " + call
        while len(call) < 6:
            call = call + " "

        if re.search(r'^[A-Z0-9 ][A-Z0-9 ][0-9][A-Z ][A-Z ][A-Z ]$', call) == None:
            return -1

        x = 0
        x += self.nchar(call[0])

        x *= 36
        x += self.nchar(call[1])

        x *= 10
        x += self.nchar(call[2])

        x *= 27
        x += self.nchar(call[3]) - 10

        x *= 27
        x += self.nchar(call[4]) - 10

        x *= 27
        x += self.nchar(call[5]) - 10
        
        return x

    # returns 16-bit number.
    # g is maidenhead grid, or signal strength, or 73.
    def packgrid(self, g):
        g = g.strip()
        g = g.upper()

        if g[0] == '-':
            snr = int(g[1:])
            if snr == 0:
                snr = 1
            if snr > 29:
                snr = 29
            return NGBASE + 1 + snr
        if g[0:2] == 'R-':
            snr = int(g[2:])
            if snr == 0:
                snr = 1
            if snr > 29:
                snr = 29
            return NGBASE + 31 + snr
        if g == "RO":
            return NGBASE + 62
        if g == "RRR":
            return NGBASE + 63
        if g == "73":
            return NGBASE+64

        if re.match(r'^[A-R][A-R][0-9][0-9]$', g) == None:
            return -1

        lng = (ord(g[0]) - ord('A')) * 20
        lng += (ord(g[2]) - ord('0')) * 2
        lng = 179 - lng

        lat = (ord(g[1]) - ord('A')) * 10
        lat += (ord(g[3]) - ord('0')) * 1
        lat -= 90

        x = (lng + 180) / 2
        x *= 180
        x += lat + 90

        return x

    # turn three numbers into 12 6-bit symbols.
    def pack3(self, nc1, nc2, g):
        a = [0] * 12
        a[0] = (nc1 >> 22) & 0x3f
        a[1] = (nc1 >> 16) & 0x3f
        a[2] = (nc1 >> 10) & 0x3f
        a[3] = (nc1 >> 4) & 0x3f
        a[4] = ((nc1 & 0xf) << 2) | ((nc2 >> 26) & 0x3)
        a[5] = (nc2 >> 20) & 0x3f
        a[6] = (nc2 >> 14) & 0x3f
        a[7] = (nc2 >> 8) & 0x3f
        a[8] = (nc2 >> 2) & 0x3f
        a[9] = ((nc2 & 0x3) << 4) | ((g >> 12) & 0xf)
        a[10] = (g >> 6) & 0x3f
        a[11] = (g >> 0) & 0x3f
        return a
        
    def pack(self, msg):
        msg = msg.strip()
        msg = re.sub(r'  *', ' ', msg)
        msg = re.sub(r'^CQ DX ', 'CQ9DX ', msg)

        # try CALL CALL GRID
        a = msg.split(' ')
        if len(a) == 3:
            nc1 = self.packcall(a[0])
            nc2 = self.packcall(a[1])
            g = self.packgrid(a[2])
            if nc1 >= 0 and nc2 >= 0 and g >= 0:
                return self.pack3(nc1, nc2, g)

        # never finished this -- no text &c.
        sys.stderr.write("FT8Send.pack(%s) -- cannot parse\n" % (msg))
        # sys.exit(1)
        return [0] * 12

    def testpack(self):
        r = FT8()
        for g in [ "FN42", "-22", "R-01", "RO", "RRR", "73", "AA00", "RR99" ]:
            pg = self.packgrid(g)
            upg = r.unpackgrid(pg)
            if g != upg.strip():
                print("packgrid oops %s" % (g))
        for call in [ "AB1HL", "K1JT", "M0TRJ", "KK4BMV", "2E0CIN", "HF9D",
                      "6Y4K", "D4Z", "8P6DR", "ZS2I", "3D2RJ",
                      "WB3D", "S59GCD", "T77C", "4Z5AD", "A45XR", "OJ0V",
                      "6Y6N", "S57V", "3Z0R" ]:
            # XXX 3XY1T doesn't work
            pc = self.packcall(call)
            upc = r.unpackcall(pc)
            if call != upc.strip():
                print("packcall oops %s %d %s" % (call, pc, upc))
        for msg in [ "AB1HL K1JT FN42", "CQ DX CO3HMR EL82", "KD6HWI PY7VI R-12",
                     "KD5RBW TU 73", "CQ N5OSK EM25", "PD9BG KG7EZ RRR",
                     "W1JET KE0HQZ 73", "WB3D OM4SX -16", "WA3ETR IZ2QGB RR73",
                     "BG THX JOE 73"]:
            pm = self.pack(msg)
            upm = r.unpack(pm)
            upm = re.sub(r'  *', ' ', upm)
            if msg != upm.strip():
                print("pack oops %s %s %s" % (msg, pm, upm))

    # twelve[] is 12 6-bit symbols, the result of pack().
    # returns an array of 79 symbols 0..8, ready for FSK.
    def make_symbols(self, twelve):
        # turn the 72 bits in twelve into an array of bits,
        # most significant bit first.
        # three zero bits at the end, for 75.
        # and room for 12 CRC bits.
        a87 = numpy.zeros(87, dtype=numpy.int32)
        i = 0
        for x in twelve:
            a87[i + 0] = (x >> 5) & 1
            a87[i + 1] = (x >> 4) & 1
            a87[i + 2] = (x >> 3) & 1
            a87[i + 3] = (x >> 2) & 1
            a87[i + 4] = (x >> 1) & 1
            a87[i + 5] = (x >> 0) & 1
            i += 6

        # CRC12
        cksum = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
                    crc12poly)
        a87[-12:] = cksum

        # LDPC(174,87)
        a174 = ldpc_encode(a87)

        # turn array of 174 bits into 58 3-bit symbols,
        # most significant bit first.
        dsymbols = numpy.zeros(58, dtype=numpy.int32)
        for i in range(0, 58):
            ii = i * 3
            dsymbols[i] = (a174[ii+0] << 2) | (a174[ii+1]<<1) | (a174[ii+2]<<0)

        # insert three 7-symbol Costas arrays.
        costas = numpy.array([ 2, 5, 6, 0, 4, 1, 3 ], dtype=numpy.int32)
        symbols = numpy.zeros(79, dtype=numpy.int32)
        symbols[0:7] = costas
        symbols[7:36] = dsymbols[0:29]
        symbols[36:43] = costas
        symbols[43:72] = dsymbols[29:]
        symbols[72:] = costas

        return symbols

    # twelve[] is 12 6-bit symbols, the result of pack().
    # tone is Hz of lowest tone.
    # returns an array of audio samples.
    def send12(self, twelve, tone, rate):
        symbols = self.make_symbols(twelve)

        samples_per_symbol = int(round(rate * (1920 / 12000.0)))
        samples = weakutil.fsk(symbols, [tone, tone], 6.25, rate, samples_per_symbol)

        return samples

    def testsend(self):
        random.seed(0)
        rate = 12000
        
        # G3LTF DL9KR JO40)
        x1 = self.send12([61, 37, 30, 28, 9, 27, 61, 58, 26, 3, 49, 16], 1000, rate)
        x1 = numpy.concatenate(([0]*1,  x1, [0]*(8192-1) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x1 = x1 * rv

        # RA3Y VE3NLS 73
        x2 = self.send12([46, 6, 32, 22, 55, 20, 11, 32, 53, 23, 59, 16], 1050, rate)
        x2 = numpy.concatenate(([0]*4096,  x2, [0]*(8192-4096) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x2 = x2 * rv

        # CQ DL7ACA JO40
        x3 = self.send12([62, 32, 32, 49, 37, 27, 59, 2, 30, 19, 49, 16], 1100, rate)
        x3 = numpy.concatenate(([0]*5120,  x3, [0]*(8192-5120) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x3 = x3 * rv

        # VA3UG   F1HMR 73  
        x4 = self.send12([52, 54, 60, 12, 55, 54, 7, 19, 2, 23, 59, 16], 1150, rate)
        x4 = numpy.concatenate(([0]*1,  x4, [0]*(8192-1) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x4 = x4 * rv

        x = 3*x1 + 2*x2 + 1.0*x3 + 0.5*x4

        x += numpy.random.rand(len(x)) * 1.0
        x *= 1000.0

        x = numpy.append([0]*(rate // 2), x)
        x = numpy.append(x, [0]*rate)

        r = FT8()
        r.cardrate = rate
        r.process(x, 0)

if False and __name__ == '__main__':
    r = FT8()
    syms = numpy.array([ [ 500, 1000, 1500, 1450, 700, 100, 300, 1000 ] ], dtype=numpy.float64)
    wm = 1000.0
    ws = 100.0
    lm = 1500.0
    ls = 300.0
    x = r.loglikelihood(syms, wm, ws, lm, ls)
    print x
    sys.exit(0)

if False:
    s = FT8Send()
    r = FT8()
    plain = [ ]
    for i in range(0, 87):
        plain.append(random.randint(0, 1))

    cw = ldpc_encode(plain)

    # turn hard bits into 0.99 vs 0.01 log-likelihood,
    # log( P(0) / P(1) )
    # log base e.
    two = numpy.array([ 4.6, -4.6 ], dtype=numpy.int32)
    ll174 = two[cw]

    d = ldpc_decode(ll174)

    assert numpy.array_equal(d, plain)

    sys.exit(1)

if False:
    s = FT8Send()
    s.testsend()
    sys.exit(1)

if False:
    s = FT8Send()
    s.testpack()
    sys.exit(1)

if False:
    # test decoding sequence on known correct symbols,
    # from wsjt-x's ft8sim.
    # should yield K1ABC W9XYZ EN37
    r = FT8()

    # 79 3-bit 8-FSK symbols, including the Costas arrays.
    a79 = "2560413335544231617326364127543164332560413756060434371356756660051002662560413"
    b79 = [ int(x) for x in a79 ]
    assert len(b79) == 79

    # get rid of the three 7-symbol Costas arrays.
    a58 = b79[7:36] + b79[43:72]
    assert len(a58) == 58

    # turn 3-bits into 1-bits.
    # most-significant bit first.
    z = [ [ (x>>2)&1, (x>>1)&1, x&1 ] for x in a58 ]
    a174 = numpy.concatenate(z)
    assert len(a174) == 174

    if True:
        # flip some bits, for testing.
        a174[17] ^= 1
        a174[30] ^= 1
        a174[31] ^= 1
        a174[102] ^= 1

    # turn hard bits into 0.99 vs 0.01 log-likelihood,
    # log( P(0) / P(1) )
    # log base e.
    two = numpy.array([ 4.6, -4.6 ], dtype=numpy.int32)
    ll174 = two[a174]
    
    # decode LDPC(174,87)
    a87 = ldpc_decode(ll174)

    # failure -> numpy.array([])
    assert len(a87) == 87

    # CRC12
    # this mimics the way the sender computes the 12-bit checksum:
    c = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
            crc12poly)
    assert numpy.array_equal(c, a87[-12:])
    
    # a87 is 72 bits of msg and 12 bits of CRC.
    # turn the 72 bits into twelve 6-bit numbers,
    # for compatibility with FT8 unpack().
    # MSB.
    a72 = a87[0:72]
    twelve = [ ]
    for i in range(0, 72, 6):
        a = a72[i:i+6]
        x = (a[0] * 32 +
             a[1] * 16 +
             a[2] *  8 + 
             a[3] *  4 +
             a[4] *  2 +
             a[5] *  1)
        twelve.append(x)

    msg = r.unpack(twelve)
    #print msg
    assert msg == " K1ABC  W9XYZ EN37"

    sys.exit(0)

def usage():
  sys.stderr.write("Usage: ft8.py -in CARD:CHAN\n")
  sys.stderr.write("       ft8.py -file fff [-chan xxx]\n")
  sys.stderr.write("       ft8.py -bench ft8files/xxx.txt\n")
  sys.stderr.write("       ft8.py -opt ft8files/xxx.txt\n")
  # list sound cards
  weakaudio.usage()
  sys.exit(1)

def set_start_adj(wsjtfile):
    global start_adj

    # time apparently wrong on laptop when I had wsjt-x record these files.
    if "ft8-40" in wsjtfile:
        start_adj = 0.5
    if "ft8-20" in wsjtfile:
        start_adj = 0.5
    if "ft8files" in wsjtfile:
        start_adj = 0.8

def benchmark(wsjtfile, verbose):
    dir = os.path.dirname(wsjtfile)
    minutes = { } # keyed by hhmmss
    wsjtf = open(wsjtfile, "r")
    for line in wsjtf:
        # 161230 -15  0.2 1779 ~  CQ W8MSC EN82 !U.S.A.
        # 161230 -16  0.8 2352 ~  VE2FON KM4MDT R-09
        # 161245 -21  0.3  538 ~  K3OWX KG5AUW -03
        # 161245   2  0.1  955 ~  KJ1J NS9I -06
        line = re.sub(r'\xA0', ' ', line) # 0xA0 -> space
        line = re.sub(r'[\r\n]', '', line)
        m = re.match(r'^([0-9]{6}) +.*$', line)
        if m == None:
            print("oops: " + line)
            continue
        hhmmss = m.group(1)
        if not hhmmss in minutes:
            minutes[hhmmss] = ""
        minutes[hhmmss] += line + "\n"
    wsjtf.close()

    info = [ ]
    for hhmmss in sorted(minutes.keys()):
        ff = [ x for x in os.listdir(dir) if re.match('......_' + hhmmss + '.wav', x) != None ]
        if len(ff) == 1:
            filename = ff[0]
            info.append([ True, filename, minutes[hhmmss] ])
        elif len(ff) == 0:
            sys.stderr.write("could not find .wav file in %s for %s\n" % (dir, hhmmss))
        else:
            sys.stderr.write("multiple files in %s for %s: %s\n" % (dir, hhmmss, ff))

    return benchmark1(dir, info, verbose)

def benchmark1(dir, bfiles, verbose):
    global chan
    chan = 0
    crcok = 0 # how many we decoded
    jtscore = 0 # how many we decoded that wsjt-x also decoded
    jtwanted = 0 # how many wsjt-x decoded
    hints = [ [], [] ]
    for bf in bfiles:
        if not bf[0]: # only the short list
            continue
        if verbose:
            print(bf[1])
        filename = dir + "/" + bf[1]
        r = FT8()
        r.verbose = False
        if True:
            r.hints = hints[1]
        if False:
            r.restrict_hz = [ 1500, 1750 ] 
        r.gowav(filename, chan)
        all = r.get_msgs()
        crcok += len(all)
        got = { } # did wsjt-x see this? indexed by msg.
        any_no = False

        # generate hints for 2 minutes from now.
        hints[1] = hints[0]
        hints[0] = [ ]
        for dec in all:
            hints[0].append( [ dec.hz(), dec.start ] )

        wsa = bf[2].split("\n")
        for wsx in wsa:
            # 161245 -21  0.3  538 ~  K3OWX KG5AUW -03
            # 161245   2  0.1  955 ~  KJ1J NS9I -06
            wsx = wsx.strip()
            if wsx != "":
                jtwanted += 1
                wsx = re.sub(r'  *', ' ', wsx)
                found = None
                for dec in all:
                    mymsg = dec.msg
                    mymsg = mymsg.strip()
                    mymsg = re.sub(r'  *', ' ', mymsg)
                    if mymsg in wsx:
                        found = dec
                        got[dec.msg] = True

                wa = wsx.split(' ')
                wmsg = ' '.join(wa[5:8])
                whz = float(wa[3])
                if whz >= 10 and whz < 11:
                    whz = (whz - 10.1387) * 1000000.0
                elif whz >= 14 and whz < 15:
                    whz = (whz - 14.0956) * 1000000.0
                elif whz < 1.0:
                    whz = whz * 1000000.0

                if found != None:
                    jtscore += 1
                    if verbose:
                        print("yes %4.0f %s (%.1f %.1f) %s" % (float(whz), wa[2], found.hz(), found.dt, wmsg))
                else:
                    any_no = True
                    if verbose:
                        print("no  %4.0f %s %s" % (float(whz), wa[2], wmsg))
                sys.stdout.flush()
        extras = [ ]
        for dec in all:
            if not (dec.msg in got) and not (dec.msg in extras):
                extras.append(dec.msg)
                if verbose:
                    print("EXTRA: %6.1f %s" % (dec.hz(), dec.msg))
    if verbose:
        print("score %d (%d of %d)" % (crcok, jtscore, jtwanted))
    return [ crcok, jtscore, jtwanted ]

vars = [
    [ "subslop", [ 0.006, 0.008, 0.009, 0.01, 0.011, 0.012, 0.015, 0.017 ] ],
    [ "fine_tstep", [ 0, 0.25, 0.5 ] ],
    [ "ldpc_iters", [ 20, 25, 27, 30, 33, 37, 50, 100 ] ],
    [ "coarse_fstep", [ 0.25, 0.5 ] ],
    [ "coarse_tstep", [ 0.25, 0.5 ] ],
    [ "fine_fstep", [ 0, 0.25, 0.5 ] ],
    [ "do_subtract", [ 0, 1, 2, 3 ] ],
    [ "subtime", [ 0.33, 0.41, 0.5, 0.58, 0.66 ] ],
    [ "subgap", [ 1.0, 1.2, 1.25, 1.3, 1.4, 1.5, 1.562, 1.6, 1.75 ] ],
    [ "coarse_no", [ 1, 2, 3, 4 ] ],
    [ "budget", [ 2, 4, 11 ] ],
    [ "coarse_tminus", [ 1.3, 1.4, 1.5, 1.6 ] ],
    [ "coarse_tplus", [ 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0 ] ],
    [ "start_adj", [ 0.3, 0.4, 0.5, 0.6, 0.7 ] ],
    # [ "contrast_weight", [ 0.0, 0.1, 0.2, 0.3 ] ],
    # [ "softboost", [ 0, 0.125, 0.25, 0.33, 0.5, 1.0, 1.5, 2.0 ] ],
    ]

def printvars():
    s = ""
    for v in vars:
        s += "%s=%s " % (v[0], eval(v[0]))
    return s

def optimize(wsjtfile):
    set_start_adj(wsjtfile)

    sys.stdout.write("# %s %s\n" % (opt, printvars()))

    # warm up any caches, JIT, &c.
    r = FT8()
    r.verbose = False
    r.gowav("ft8files/170717_161300.wav", 0)

    for v in vars:
        for val in v[1]:
            old = None
            if "." in v[0]:
                xglob = ""
            else:
                xglob = "global %s ; " % (v[0])
            exec("%sold = %s" % (xglob, v[0]))
            exec("%s%s = %s" % (xglob, v[0], val))

            [ crcok, jtscore, jtwanted ] = benchmark(wsjtfile, False)
            exec("%s%s = old" % (xglob, v[0]))
            sys.stdout.write("%s=%s : " % (v[0], val))
            sys.stdout.write("%d %d %d\n" % (crcok, jtscore, jtwanted))
            sys.stdout.flush()

filename = None
card = None
bench = None
opt = None

def main():
  global filename, card, bench, opt
  i = 1
  while i < len(sys.argv):
    if sys.argv[i] == "-in":
      card = [ sys.argv[i+1], sys.argv[i+2] ]
      i += 3
    elif sys.argv[i] == "-file":
      filename = sys.argv[i+1]
      i += 2
    elif sys.argv[i] == "-bench":
      bench = sys.argv[i+1]
      i += 2
    elif sys.argv[i] == "-opt":
      opt = sys.argv[i+1]
      i += 2
    else:
      usage()
  
  if False:
    xr = FT8()
    xr.test_guess_offset()
    sys.exit(0)
  
  if bench != None:
    set_start_adj(bench)
    sys.stdout.write("# %s %s\n" % (bench, printvars()))
    benchmark(bench, True)
    sys.exit(0)

  if opt != None:
    optimize(opt)
    sys.exit(0)
  
  if filename != None and card == None:
    set_start_adj(filename)
    r = FT8()
    r.verbose = True
    r.gowav(filename, 0)
  elif filename == None and card != None:
    r = FT8()
    r.verbose = True
    r.opencard(card)
    r.gocard()
  else:
    usage()

if __name__ == '__main__':
  if False:
    profiling = True
    pfile = "cprof.out"
    sys.stderr.write("ft8: cProfile -> %s\n" % (pfile))
    import cProfile
    import pstats
    cProfile.run('main()', pfile)
    p = pstats.Stats(pfile)
    p.strip_dirs().sort_stats('time')
    # p.print_stats(10)
    p.print_callers()
  else:
    main()
