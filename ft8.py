#!/usr/local/bin/python

#
# decode FT8
#
# Robert Morris, AB1HL
#

import numpy
import numpy.linalg
import wave
import scipy
import scipy.signal
import sys
import os
import math
import time
import copy
import calendar
import subprocess
import multiprocessing
import threading
import re
import random
from scipy.signal import lfilter
import ctypes
import weakaudio
import weakutil
import ctypes

#
# tuning parameters.
#
budget = 2 # max seconds of time for decoding.
coarse_fstep = 2 # coarse search granularity, per FFT bin
coarse_tstep = 4 # coarse search granularity, per symbol time
coarse_tminus = 1.5 # start search this many seconds before 0.5
coarse_tplus = 1.6 # end search this many seconds after 0.5
coarse_no    = 1 # number of best offsets to use per hz
fine_no    = 1 # number of best fine offsets to look at
fine_fstep = 2 # fine-tuning steps per coarse_fstep
fine_tstep = 4 # fine-tuning steps per coarse_tstep
start_adj = 0.1 # signals seem on avg to start this many seconds late.
ldpc_iters = 15 # how hard LDPC should work
softboost = 1.0 # log(prob) if #2 symbol has same bit value
do_subtract = 4 # 0 none, 1 once per unique decode, 2 three per unique, 3 once per decode
subgap = 1.25  # extra subtract()s this many hz on either side of main bin
substeps = 16 # subtract phase steps, in 2pi
subpasses = 3 # 0 means no subtraction, 1 means subtract, 2 means another subtraction pass
contrast_weight = 0.5
noise_factor = 1.0 / 7.0 # for strength()
top_high_order = 0 # 0 for cheby, 7 or 9 for butter
top_low_order = 6
bottom_low_order = 0
top_down = True
bottom_slow = True
osd_crc = False
osd_order = 1
phase_gran = 100 # phase_drift() precision -- pi/phase_gran
already_o = 1
already_f = 1
down200 = False # process1() that down-converts to 200 hz / 32 samples/symbol

# FT8 modulation and protocol definitions.
# 1920-point FFT at 12000 samples/second
#   yields 6.25 Hz spacing, 0.16 seconds/symbol
# encode chain:
#   75 bits
#   append 12 bits CRC (for 87 bits)
#   LDPC(174,87) yields 174 bits
#   that's 58 3-bit FSK-8 symbols
#   insert three 7-symbol Costas sync arrays
#     at symbol #s 0, 36, 72 of final signal
#   thus: 79 FSK-8 symbols
# total transmission time is 12.64 seconds

# the CRC-12 polynomial, from wsjt-x's 0xc06.
crc12poly = [ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 ]

def crc_c(msg):
    msgtype = ctypes.c_int * len(msg)
    outtype = ctypes.c_int * 12

    msg1 = msgtype()
    for i in range(0, len(msg)):
        msg1[i] = msg[i]

    out1 = outtype()

    libldpc.ft8_crc(msg1, len(msg), out1)

    out = numpy.zeros(12, dtype=numpy.int32)
    for i in range(0, 12):
        out[i] = out1[i]

    return out

#
# thank you, evan sneath.
# https://gist.github.com/evansneath/4650991
#
# generate with x^3 + x + 1:
#   >>> xc.crc([1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1])
#   array([1, 0, 0])
# check:
#   >>> xc.crc([1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1], [1, 0, 0])
#   array([0, 0, 0])
#
# 0xc06 is really 0x1c06 or [ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 ]
#
def crc(msg, div, code=None):
    return crc_c(msg)

    """Cyclic Redundancy Check
    Generates an error detecting code based on an inputted message
    and divisor in the form of a polynomial representation.
    Arguments:
        msg: The input message of which to generate the output code.
        div: The divisor in polynomial form. For example, if the polynomial
            of x^3 + x + 1 is given, this should be represented as '1011' in
            the div argument.
        code: This is an option argument where a previously generated code may
            be passed in. This can be used to check validity. If the inputted
            code produces an outputted code of all zeros, then the message has
            no errors.
    Returns:
        An error-detecting code generated by the message and the given divisor.
    """

    # Append the code to the message. If no code is given, default to '000'
    if code is None:
        code = numpy.zeros(len(div)-1, dtype=numpy.int32)
    assert len(code) == len(div) - 1
    msg = numpy.append(msg, code)

    div = numpy.array(div, dtype=numpy.int32)
    divlen = len(div)

    # Loop over every message bit (minus the appended code)
    for i in range(len(msg)-len(code)):
        # If that messsage bit is 1, perform modulo 2 multiplication
        if msg[i] == 1:
            #for j in range(len(div)):
            #    # Perform modulo 2 multiplication on each index of the divisor
            #    msg[i+j] = (msg[i+j] + div[j]) % 2
            msg[i:i+divlen] = numpy.mod(msg[i:i+divlen] + div, 2)

    # Output the last error-checking code portion of the message generated
    return msg[-len(code):]

if False:
    msg = numpy.zeros(76, dtype=numpy.int32)
    msg[3] = 1
    msg[7] = 1
    msg[44] = 1
    msg[45] = 1
    msg[46] = 1
    msg[51] = 1
    msg[61] = 1
    msg[71] = 1
    cksum = crc(msg, crc12poly)
    # cksum = crc_c(msg)
    expected = [ 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0 ]
    eq = numpy.equal(cksum, numpy.array(expected, dtype=numpy.int32))
    assert numpy.all(eq)
    sys.exit(1)

def check_crc(a87):
    cksum = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
                crc12poly)
    if numpy.array_equal(cksum, a87[-12:]) == False:
        # CRC failed.
        return False
    return True

# LDPC(174,87) parameters from WSJT-X.
# this is an indirection table that moves a
# codeword's 87 systematic (message) bits to the end.
colorder = numpy.array([
  0, 1, 2, 3, 30, 4, 5, 6, 7, 8, 9, 10, 11, 32, 12, 40, 13, 14, 15, 16,
  17, 18, 37, 45, 29, 19, 20, 21, 41, 22, 42, 31, 33, 34, 44, 35, 47,
  51, 50, 43, 36, 52, 63, 46, 25, 55, 27, 24, 23, 53, 39, 49, 59, 38,
  48, 61, 60, 57, 28, 62, 56, 58, 65, 66, 26, 70, 64, 69, 68, 67, 74,
  71, 54, 76, 72, 75, 78, 77, 80, 79, 73, 83, 84, 81, 82, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103,
  104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
  118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
  132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145,
  146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
  160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173
  ], dtype=numpy.int32)

# this is the LDPC(174,87) parity check matrix.
# 87 rows.
# each row describes one parity check.
# each number is an index into the codeword (1-origin).
# the codeword bits mentioned in each row must xor to zero.
# From WSJT-X's bpdecode174.f90.
Nm = [
    [ 1,   30,  60,  89,   118,  147,  0 ],
    [ 2,   31,  61,  90,   119,  147,  0 ],
    [ 3,   32,  62,  91,   120,  148,  0 ],
    [ 4,   33,  63,  92,   121,  149,  0 ],
    [ 2,   34,  64,  93,   122,  150,  0 ],
    [ 5,   33,  65,  94,   123,  148,  0 ],
    [ 6,   34,  66,  95,   124,  151,  0 ],
    [ 7,   35,  67,  96,   120,  152,  0 ],
    [ 8,   36,  68,  97,   125,  153,  0 ],
    [ 9,   37,  69,  98,   126,  152,  0 ],
    [ 10,  38,  70,  99,   127,  154,  0 ],
    [ 11,  39,  71,  100,  126,  155,  0 ],
    [ 12,  40,  61,  101,  128,  145,  0 ],
    [ 10,  33,  60,  95,   128,  156,  0 ],
    [ 13,  41,  72,  97,   126,  157,  0 ],
    [ 13,  42,  73,  90,   129,  156,  0 ],
    [ 14,  39,  74,  99,   130,  158,  0 ],
    [ 15,  43,  75,  102,  131,  159,  0 ],
    [ 16,  43,  71,  103,  118,  160,  0 ],
    [ 17,  44,  76,  98,   130,  156,  0 ],
    [ 18,  45,  60,  96,   132,  161,  0 ],
    [ 19,  46,  73,  83,   133,  162,  0 ],
    [ 12,  38,  77,  102,  134,  163,  0 ],
    [ 19,  47,  78,  104,  135,  147,  0 ],
    [ 1,   32,  77,  105,  136,  164,  0 ],
    [ 20,  48,  73,  106,  123,  163,  0 ],
    [ 21,  41,  79,  107,  137,  165,  0 ],
    [ 22,  42,  66,  108,  138,  152,  0 ],
    [ 18,  42,  80,  109,  139,  154,  0 ],
    [ 23,  49,  81,  110,  135,  166,  0 ],
    [ 16,  50,  82,  91,   129,  158,  0 ],
    [ 3,   48,  63,  107,  124,  167,  0 ],
    [ 6,   51,  67,  111,  134,  155,  0 ],
    [ 24,  35,  77,  100,  122,  162,  0 ],
    [ 20,  45,  76,  112,  140,  157,  0 ],
    [ 21,  36,  64,  92,   130,  159,  0 ],
    [ 8,   52,  83,  111,  118,  166,  0 ],
    [ 21,  53,  84,  113,  138,  168,  0 ],
    [ 25,  51,  79,  89,   122,  158,  0 ],
    [ 22,  44,  75,  107,  133,  155,  172 ],
    [ 9,   54,  84,  90,   141,  169,  0 ],
    [ 22,  54,  85,  110,  136,  161,  0 ],
    [ 8,   37,  65,  102,  129,  170,  0 ],
    [ 19,  39,  85,  114,  139,  150,  0 ],
    [ 26,  55,  71,  93,   142,  167,  0 ],
    [ 27,  56,  65,  96,   133,  160,  174 ],
    [ 28,  31,  86,  100,  117,  171,  0 ],
    [ 28,  52,  70,  104,  132,  144,  0 ],
    [ 24,  57,  68,  95,   137,  142,  0 ],
    [ 7,   30,  72,  110,  143,  151,  0 ],
    [ 4,   51,  76,  115,  127,  168,  0 ],
    [ 16,  45,  87,  114,  125,  172,  0 ],
    [ 15,  30,  86,  115,  123,  150,  0 ],
    [ 23,  46,  64,  91,   144,  173,  0 ],
    [ 23,  35,  75,  113,  145,  153,  0 ],
    [ 14,  41,  87,  108,  117,  149,  170 ],
    [ 25,  40,  85,  94,   124,  159,  0 ],
    [ 25,  58,  69,  116,  143,  174,  0 ],
    [ 29,  43,  61,  116,  132,  162,  0 ],
    [ 15,  58,  88,  112,  121,  164,  0 ],
    [ 4,   59,  72,  114,  119,  163,  173 ],
    [ 27,  47,  86,  98,   134,  153,  0 ],
    [ 5,   44,  78,  109,  141,  0,    0 ],
    [ 10,  46,  69,  103,  136,  165,  0 ],
    [ 9,   50,  59,  93,   128,  164,  0 ],
    [ 14,  57,  58,  109,  120,  166,  0 ],
    [ 17,  55,  62,  116,  125,  154,  0 ],
    [ 3,   54,  70,  101,  140,  170,  0 ],
    [ 1,   36,  82,  108,  127,  174,  0 ],
    [ 5,   53,  81,  105,  140,  0,    0 ],
    [ 29,  53,  67,  99,   142,  173,  0 ],
    [ 18,  49,  74,  97,   115,  167,  0 ],
    [ 2,   57,  63,  103,  138,  157,  0 ],
    [ 26,  38,  79,  112,  135,  171,  0 ],
    [ 11,  52,  66,  88,   119,  148,  0 ],
    [ 20,  40,  68,  117,  141,  160,  0 ],
    [ 11,  48,  81,  89,   146,  169,  0 ],
    [ 29,  47,  80,  92,   146,  172,  0 ],
    [ 6,   32,  87,  104,  145,  169,  0 ],
    [ 27,  34,  74,  106,  131,  165,  0 ],
    [ 12,  56,  84,  88,   139,  0,    0 ],
    [ 13,  56,  62,  111,  146,  171,  0 ],
    [ 26,  37,  80,  105,  144,  151,  0 ],
    [ 17,  31,  82,  113,  121,  161,  0 ],
    [ 28,  49,  59,  94,   137,  0,    0 ],
    [ 7,   55,  83,  101,  131,  168,  0 ],
    [ 24,  50,  78,  106,  143,  149,  0 ],
]

# Mn from WSJT-X's bpdecode174.f90.
# each row corresponds to a codeword bit.
# the numbers indicate which three parity
# checks (rows in Nm) refer to the codeword bit.
# 1-origin.
Mn = [
  [ 1, 25, 69 ],
  [ 2, 5, 73 ],
  [ 3, 32, 68 ],
  [ 4, 51, 61 ],
  [ 6, 63, 70 ],
  [ 7, 33, 79 ],
  [ 8, 50, 86 ],
  [ 9, 37, 43 ],
  [ 10, 41, 65 ],
  [ 11, 14, 64 ],
  [ 12, 75, 77 ],
  [ 13, 23, 81 ],
  [ 15, 16, 82 ],
  [ 17, 56, 66 ],
  [ 18, 53, 60 ],
  [ 19, 31, 52 ],
  [ 20, 67, 84 ],
  [ 21, 29, 72 ],
  [ 22, 24, 44 ],
  [ 26, 35, 76 ],
  [ 27, 36, 38 ],
  [ 28, 40, 42 ],
  [ 30, 54, 55 ],
  [ 34, 49, 87 ],
  [ 39, 57, 58 ],
  [ 45, 74, 83 ],
  [ 46, 62, 80 ],
  [ 47, 48, 85 ],
  [ 59, 71, 78 ],
  [ 1, 50, 53 ],
  [ 2, 47, 84 ],
  [ 3, 25, 79 ],
  [ 4, 6, 14 ],
  [ 5, 7, 80 ],
  [ 8, 34, 55 ],
  [ 9, 36, 69 ],
  [ 10, 43, 83 ],
  [ 11, 23, 74 ],
  [ 12, 17, 44 ],
  [ 13, 57, 76 ],
  [ 15, 27, 56 ],
  [ 16, 28, 29 ],
  [ 18, 19, 59 ],
  [ 20, 40, 63 ],
  [ 21, 35, 52 ],
  [ 22, 54, 64 ],
  [ 24, 62, 78 ],
  [ 26, 32, 77 ],
  [ 30, 72, 85 ],
  [ 31, 65, 87 ],
  [ 33, 39, 51 ],
  [ 37, 48, 75 ],
  [ 38, 70, 71 ],
  [ 41, 42, 68 ],
  [ 45, 67, 86 ],
  [ 46, 81, 82 ],
  [ 49, 66, 73 ],
  [ 58, 60, 66 ],
  [ 61, 65, 85 ],
  [ 1, 14, 21 ],
  [ 2, 13, 59 ],
  [ 3, 67, 82 ],
  [ 4, 32, 73 ],
  [ 5, 36, 54 ],
  [ 6, 43, 46 ],
  [ 7, 28, 75 ],
  [ 8, 33, 71 ],
  [ 9, 49, 76 ],
  [ 10, 58, 64 ],
  [ 11, 48, 68 ],
  [ 12, 19, 45 ],
  [ 15, 50, 61 ],
  [ 16, 22, 26 ],
  [ 17, 72, 80 ],
  [ 18, 40, 55 ],
  [ 20, 35, 51 ],
  [ 23, 25, 34 ],
  [ 24, 63, 87 ],
  [ 27, 39, 74 ],
  [ 29, 78, 83 ],
  [ 30, 70, 77 ],
  [ 31, 69, 84 ],
  [ 22, 37, 86 ],
  [ 38, 41, 81 ],
  [ 42, 44, 57 ],
  [ 47, 53, 62 ],
  [ 52, 56, 79 ],
  [ 60, 75, 81 ],
  [ 1, 39, 77 ],
  [ 2, 16, 41 ],
  [ 3, 31, 54 ],
  [ 4, 36, 78 ],
  [ 5, 45, 65 ],
  [ 6, 57, 85 ],
  [ 7, 14, 49 ],
  [ 8, 21, 46 ],
  [ 9, 15, 72 ],
  [ 10, 20, 62 ],
  [ 11, 17, 71 ],
  [ 12, 34, 47 ],
  [ 13, 68, 86 ],
  [ 18, 23, 43 ],
  [ 19, 64, 73 ],
  [ 24, 48, 79 ],
  [ 25, 70, 83 ],
  [ 26, 80, 87 ],
  [ 27, 32, 40 ],
  [ 28, 56, 69 ],
  [ 29, 63, 66 ],
  [ 30, 42, 50 ],
  [ 33, 37, 82 ],
  [ 35, 60, 74 ],
  [ 38, 55, 84 ],
  [ 44, 52, 61 ],
  [ 51, 53, 72 ],
  [ 58, 59, 67 ],
  [ 47, 56, 76 ],
  [ 1, 19, 37 ],
  [ 2, 61, 75 ],
  [ 3, 8, 66 ],
  [ 4, 60, 84 ],
  [ 5, 34, 39 ],
  [ 6, 26, 53 ],
  [ 7, 32, 57 ],
  [ 9, 52, 67 ],
  [ 10, 12, 15 ],
  [ 11, 51, 69 ],
  [ 13, 14, 65 ],
  [ 16, 31, 43 ],
  [ 17, 20, 36 ],
  [ 18, 80, 86 ],
  [ 21, 48, 59 ],
  [ 22, 40, 46 ],
  [ 23, 33, 62 ],
  [ 24, 30, 74 ],
  [ 25, 42, 64 ],
  [ 27, 49, 85 ],
  [ 28, 38, 73 ],
  [ 29, 44, 81 ],
  [ 35, 68, 70 ],
  [ 41, 63, 76 ],
  [ 45, 49, 71 ],
  [ 50, 58, 87 ],
  [ 48, 54, 83 ],
  [ 13, 55, 79 ],
  [ 77, 78, 82 ],
  [ 1, 2, 24 ],
  [ 3, 6, 75 ],
  [ 4, 56, 87 ],
  [ 5, 44, 53 ],
  [ 7, 50, 83 ],
  [ 8, 10, 28 ],
  [ 9, 55, 62 ],
  [ 11, 29, 67 ],
  [ 12, 33, 40 ],
  [ 14, 16, 20 ],
  [ 15, 35, 73 ],
  [ 17, 31, 39 ],
  [ 18, 36, 57 ],
  [ 19, 46, 76 ],
  [ 21, 42, 84 ],
  [ 22, 34, 59 ],
  [ 23, 26, 61 ],
  [ 25, 60, 65 ],
  [ 27, 64, 80 ],
  [ 30, 37, 66 ],
  [ 32, 45, 72 ],
  [ 38, 51, 86 ],
  [ 41, 77, 79 ],
  [ 43, 56, 68 ],
  [ 47, 74, 82 ],
  [ 40, 52, 78 ],
  [ 54, 61, 71 ],
  [ 46, 58, 69 ],
]

# LDPC generator matrix, from wsjt-x's encode174.f90 and ldpc_174_87_params.f90
# 87 rows, 87 columns.
# generates first 87 codeword bits; second 87 are the 87 bits of plain-text.
# i'th codeword bit is xor of plain bits and gen[i].
gen = [
    [ 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 ],
    [ 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0 ],
    [ 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1 ],
    [ 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 ],
    [ 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0 ],
    [ 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 ],
    [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1 ],
    [ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 ],
    [ 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0 ],
    [ 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1 ],
    [ 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0 ],
    [ 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0 ],
    [ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0 ],
    [ 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0 ],
    [ 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1 ],
    [ 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0 ],
    [ 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0 ],
    [ 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1 ],
    [ 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0 ],
    [ 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1 ],
    [ 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1 ],
    [ 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0 ],
    [ 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0 ],
    [ 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1 ],
    [ 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0 ],
    [ 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0 ],
    [ 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 ],
    [ 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0 ],
    [ 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1 ],
    [ 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1 ],
    [ 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0 ],
    [ 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1 ],
    [ 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0 ],
    [ 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1 ],
    [ 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1 ],
    [ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0 ],
    [ 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0 ],
    [ 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1 ],
    [ 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0 ],
    [ 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1 ],
    [ 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1 ],
    [ 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0 ],
    [ 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1 ],
    [ 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1 ],
    [ 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1 ],
    [ 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1 ],
    [ 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1 ],
    [ 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1 ],
    [ 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0 ],
    [ 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0 ],
    [ 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 ],
    [ 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1 ],
    [ 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1 ],
    [ 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0 ],
    [ 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0 ],
    [ 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1 ],
    [ 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1 ],
    [ 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0 ],
    [ 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ],
    [ 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 ],
    [ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0 ],
    [ 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0 ],
    [ 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0 ],
    [ 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0 ],
    [ 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1 ],
    [ 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0 ],
    [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1 ],
    [ 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1 ],
    [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1 ],
    [ 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1 ],
    [ 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0 ],
    [ 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0 ],
    [ 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1 ],
    [ 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1 ],
    [ 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1 ],
    [ 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1 ],
    [ 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0 ],
    [ 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1 ],
    [ 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1 ],
    [ 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1 ],
    [ 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 ],
    [ 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0 ],
    [ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1 ],
]

# turn gen[] into a systematic array by appending
# an identity matrix.
gen_sys = numpy.zeros((174, 87), dtype=numpy.int32)
gen_sys[0:87,:] = gen
gen_sys[87:,:] = numpy.eye(87, dtype=numpy.int32)
gen_sys_reorder = numpy.zeros((174,87), dtype=numpy.int32)
gen_sys_reorder[colorder] = gen_sys

# plain is 87 bits of plain-text.
# returns a 174-bit codeword.
# mimics wsjt-x's encode174.f90.
def ldpc_encode(plain):
    # cw = numpy.dot(gen_sys_reorder, plain)
    # cw = numpy.mod(cw, 2)
    # return cw

    ncw = numpy.zeros(174, dtype=numpy.int32)
    numpy.dot(gen_sys[0:87,:], plain, out=ncw[0:87])
    numpy.mod(ncw[0:87], 2, out=ncw[0:87])
    ncw[87:] = plain
    ncw1 = numpy.zeros(174, dtype=numpy.int32)
    ncw1[colorder] = ncw
    ncw = ncw1

    # assert numpy.array_equal(cw, ncw)

    return ncw


# given a 174-bit codeword as an array of log-likelihood of zero,
# return a 87-bit plain text, or zero-length array.
# this is an implementation of the sum-product algorithm
# from Sarah Johnson's Iterative Error Correction book.
# codeword[i] = log ( P(x=0) / P(x=1) )
def ldpc_decode_python(codeword):
    # 174 codeword bits
    # 87 parity checks

    mnx = numpy.array(Mn, dtype=numpy.int32)
    nmx = numpy.array(Nm, dtype=numpy.int32)

    # Mji
    # each codeword bit i tells each parity check j
    # what the bit's log-likelihood of being 0 is
    # based on information *other* than from that
    # parity check.
    m = numpy.zeros((87, 174))

    for i in range(0, 174):
        for j in range(0, 87):
            m[j][i] = codeword[i]

    for iter in range(0, ldpc_iters):
        # Eji
        # each check j tells each codeword bit i the
        # log likelihood of the bit being zero based
        # on the *other* bits in that check.
        e = numpy.zeros((87, 174))

        # messages from checks to bits.
        # for each parity check
        #for j in range(0, 87):
        #    # for each bit mentioned in this parity check
        #    for i in Nm[j]:
        #        if i <= 0:
        #            continue
        #        a = 1
        #        # for each other bit mentioned in this parity check
        #        for ii in Nm[j]:
        #            if ii != i:
        #                a *= math.tanh(m[j][ii-1] / 2.0)
        #        e[j][i-1] = math.log((1 + a) / (1 - a))
        for i in range(0, 7):
            a = numpy.ones(87)
            for ii in range(0, 7):
                if ii != i:
                    x1 = numpy.tanh(m[range(0, 87), nmx[:,ii]-1] / 2.0)
                    x2 = numpy.where(numpy.greater(nmx[:,ii], 0.0), x1, 1.0)
                    a = a * x2
            # avoid divide by zero, i.e. a[i]==1.0
            # XXX why is a[i] sometimes 1.0?
            b = numpy.where(numpy.less(a, 0.99999), a, 0.99)
            c = numpy.log((b + 1.0) / (1.0 - b))
            # have assign be no-op when nmx[a,b] == 0
            d = numpy.where(numpy.equal(nmx[:,i], 0),
                            e[range(0,87), nmx[:,i]-1],
                            c)
            e[range(0,87), nmx[:,i]-1] = d

        # decide if we are done -- compute the corrected codeword,
        # see if the parity check succeeds.
        # sum the three log likelihoods contributing to each codeword bit.
        e0 = e[mnx[:,0]-1, range(0,174)]
        e1 = e[mnx[:,1]-1, range(0,174)]
        e2 = e[mnx[:,2]-1, range(0,174)]
        ll = codeword + e0 + e1 + e2
        # log likelihood > 0 => bit=0.
        cw = numpy.select( [ ll < 0 ], [ numpy.ones(174, dtype=numpy.int32) ])
        if ldpc_check(cw):
            # success!
            # it's a systematic code, though the plain-text bits are scattered.
            # collect them.
            decoded = cw[colorder]
            decoded = decoded[-87:]
            return [ 87, decoded ]

        # messages from bits to checks.
        for j in range(0, 3):
            # for each column in Mn.
            ll = codeword
            if j != 0:
                e0 = e[mnx[:,0]-1, range(0,174)]
                ll = ll + e0
            if j != 1:
                e1 = e[mnx[:,1]-1, range(0,174)]
                ll = ll + e1
            if j != 2:
                e2 = e[mnx[:,2]-1, range(0,174)]
                ll = ll + e2
            m[mnx[:,j]-1, range(0,174)] = ll


    # could not decode.
    return [ 0, numpy.array([]) ]

# turn log-likelihood bits into hard bits.
# codeword[i] = log ( P(x=0) / P(x=1) )
# so > 0 means bit=0, < 0 means bit=1.
def soft2hard(codeword):
    hard = numpy.less(codeword, 0.0)
    hard = numpy.array(hard, dtype=numpy.int32) # T/F -> 1/0
    two = numpy.array([0, 1], dtype=numpy.int32)
    hardword = two[hard]
    return hardword

# given a 174-bit codeword as an array of log-likelihood of zero,
# return a 87-bit plain text, or zero-length array.
# this is an implementation of the bit-flipping algorithm
# from Sarah Johnson's Iterative Error Correction book.
# codeword[i] = log ( P(x=0) / P(x=1) )
def ldpc_decode_flipping(codeword):
    cw = soft2hard(codeword)

    for iter in range(0,100):
        # for each codeword bit,
        # count of votes for 0 and 1.
        votes = numpy.zeros((len(codeword), 2))

        # for each parity check equation.
        for e in Nm:
            # for each codeword bit mentioned in e.
            for bi in e:
                if bi == 0:
                    continue
                # value for bi implied by remaining bits.
                x = 0
                for i in e:
                    if i != bi:
                        x ^= cw[i-1]
                # the other bits in the equation suggest that
                # bi must have value x.
                votes[(bi-1),x] += 1

        for i in range(0, len(cw)):
            if cw[i] == 0 and votes[i][1] > votes[i][0]:
                cw[i] = 1
            elif cw[i] == 1 and votes[i][0] > votes[i][1]:
                cw[i] = 0

        if ldpc_check(cw):
            # success!
            # it's a systematic code, though the plain-text bits are scattered.
            # collect them.
            decoded = cw[colorder]
            decoded = decoded[-87:]
            return decoded

    return numpy.array([])

# does a 174-bit codeword pass the LDPC parity checks?
def ldpc_check(codeword):
    for e in Nm:
        x = 0
        for i in e:
            if i != 0:
                x ^= codeword[i-1]
        if x != 0:
            return False
    return True

libldpc = None
try:
    libldpc = ctypes.cdll.LoadLibrary("libldpc/libldpc.so")
except:
    libldpc = None
    sys.stderr.write("ft8: using the Python LDPC decoder, not the C decoder.\n")

def ldpc_test():
    tt = 0.0
    # niters = 5000
    niters = 1000
    ok = 0
    for iter in range(0, niters):
        # ldpc_encode() takes 87 bits.
        a87 = numpy.random.randint(0, 2, 87)
        a174 = ldpc_encode(a87)

        # turn hard bits into 0.99 vs 0.01 log-likelihood,
        # log( P(0) / P(1) )
        # log base e.
        two = numpy.array([ 4.6, -4.6 ])
        ll174 = two[a174]

        # wreck some bits
        for junk in range(0, 70):
            ll174[random.randint(0, len(ll174)-1)] = (random.random() - 0.5) * 4

        t0 = time.time()

        # decode LDPC(174,87)
        [ _, d87 ] = ldpc_decode(ll174)

        t1 = time.time()
        tt += t1 - t0

        if numpy.array_equal(a87, d87):
            ok += 1

    print("ldpc_iters %d, success %.2f, %.6f sec/call" % (ldpc_iters,
                                                          ok / float(niters),
                                                          tt / niters))

    # success 0.88
    # 0.019423 per call

    # but Dec 28 2017
    # ldpc_iters 20, success 0.64, 0.000592 sec/call
    # ldpc_iters 33, success 0.68, 0.000749 sec/call
    # ldpc_iters 37, success 0.68, 0.000806 sec/call
    # ldpc_iters 50, success 0.69, 0.000943 sec/call
    # ldpc_iters 100, success 0.71, 0.001515 sec/call
    # fast_tanh is a bit faster, but has same success as tanh()
    # ldpc_decode_python() has about the same success rate


# codeword is 174 log-likelihoods.
# return is  [ ok, 87 bits ].
# ok is 87 if all ldpc parity checks worked, < 87 otherwise.
# result is usually garbage if ok < 87.
def ldpc_decode_c(codeword):
    double174 = ctypes.c_double * 174
    int174 = ctypes.c_int * 174

    c174 = double174()
    for i in range(0, 174):
        c174[i] = codeword[i]

    out174 = int174()
    for i in range(0, 174):
        out174[i] = -1;

    ok = ctypes.c_int()
    ok.value = -1

    libldpc.ldpc_decode(c174, ldpc_iters, out174, ctypes.byref(ok))

    plain174 = numpy.zeros(174, dtype=numpy.int32);
    for i in range(0, 174):
        plain174[i] = out174[i];

    plain87 = plain174[-87:]
    return [ ok.value, plain87 ]

def ldpc_decode(codeword):
    if libldpc != None:
        return ldpc_decode_c(codeword)
    else:
        return ldpc_decode_python(codeword)

if False:
    ldpc_test()
    sys.exit(1)

# gauss-jordan elimination of rows.
# m[row][col]
# inverts the square top of the matrix, swapping
# with lower rows as needed.
# returns the inverse of the top of the matrix.
# cooks up the identity matrix (the right-hand half)
# as needed.
# mod 2, so elements should be 0 or 1.
# keeps track of swaps in which[] -- every time it swaps two
# rows, it swaps the same two rows in which[].
# which[] could start out as range(0, n_rows).
def python_gauss_jordan(m, which):
    rows = m.shape[1] # rows to invert = columns
    # assert numpy.all(numpy.greater_equal(m, 0))
    # assert numpy.all(numpy.less_equal(m, 1))
    b = numpy.zeros((m.shape[0], rows * 2), dtype=m.dtype)
    b[:,0:rows] = m

    for row in range(0, rows):
        if b[row,row] != 1:
            # oops, find a row that has a 1 in row,row,
            # and swap.
            for row1 in range(row+1,m.shape[0]):
                if b[row1,row] == 1:
                    tmp = numpy.copy(b[row])
                    b[row] = b[row1]
                    b[row1] = tmp
                    tmp = which[row]
                    which[row] = which[row1]
                    which[row1] = tmp
                    break
        if b[row,row] != 1:
            sys.stderr.write("not reducible\n")
            print(b)
            return numpy.array([])
        # lazy creation of identity matrix in right half
        b[row,rows+row] = (b[row,rows+row] + 1) % 2 
        # now eliminate
        for row1 in range(0, m.shape[0]):
            if row1 == row:
                continue
            if b[row1,row] != 0:
                b[row1] = numpy.mod(b[row]+b[row1], 2)
    
    # assert numpy.array_equal(b[0:rows,0:rows],
    #                          numpy.eye(rows, dtype=numpy.int32))

    c = b[0:rows,rows:2*rows]
    return c

# m[174,87]
def gauss_jordan(m, which):
    if m.dtype != numpy.int32:
        m = m.astype(numpy.int32)
    assert len(which) == m.shape[1]*2

    rows = m.shape[1]
    int174 = ctypes.c_int * (2*rows)

    b = numpy.zeros((m.shape[0], rows * 2), dtype=numpy.int32)
    b[:,0:rows] = m
    xb = b.ctypes.data_as(ctypes.POINTER(ctypes.c_int))

    xwhich = int174()
    for i in range(0, len(which)):
        xwhich[i] = which[i]

    ok = ctypes.c_int()
    ok.value = -1

    libldpc.gauss_jordan(rows, xb, xwhich, ctypes.byref(ok))

    if ok.value != 1:
        sys.stderr.write("C gauss-jordan: not reducible %d\n" % (ok.value))
        return numpy.array([])

    for i in range(0, len(which)):
        which[i] = xwhich[i]

    c = b[0:rows,rows:2*rows]
    return c

def test_gauss_jordan():
    rows = 7
    a = numpy.random.randint(0, 2, (rows*2, rows))
    pa = numpy.copy(a)

    which = range(0, a.shape[0])
    which = numpy.array(which, dtype=numpy.int32)
    pwhich = numpy.copy(which)

    b = gauss_jordan(a, which)

    pb = python_gauss_jordan(pa, pwhich)
    if not numpy.array_equal(b, pb):
        print("not the same")
        sys.exit(1)

    if len(b) > 0:
        aa = a[which][0:rows,:]
        prod = numpy.mod(numpy.dot(aa, b), 2)
        assert numpy.array_equal(prod, numpy.eye(rows, dtype=numpy.int32))

if False:
    test_gauss_jordan()
    sys.exit(1)

# ordered statistics decoder for LDPC.
# idea from wsjt-x.
# codeword[i] = log ( P(x=0) / P(x=1) )
# codeword has 174 bits.
def osd_decode(codeword, order):

    # un-do shuffling, so last 87 bits are plaintext.
    codeword = codeword[colorder]

    # we're going to use the strongest 87 bits of codeword.
    strength = abs(codeword)
    which = numpy.argsort(-strength)

    # generator matrix, reordered strongest codeword bit first.
    gen1 = gen_sys[which]

    # gen1[row,col]
    # gen1[i,:] produced y[i]

    gen1_inv = gauss_jordan(gen1, which)

    # which[i] = j means y1[i] is a174[j]
    # and gen1[i] is gen_sys[j]
    # gauss_jordan usually changes which[].

    # y1 is the received bits, same order as gen1_inv,
    # more or less strongest-first.
    #y1 = numpy.copy(codeword)
    #y1 = y1[which]
    #y1 = y1[0:87]
    y1 = codeword[which[0:87]]
    y1 = soft2hard(y1)

    # we expect this to yield the original plain-text.
    # z = gen1_inv * y
    # z = gen1_inv * (gen1 * plain)
    # z = plain
    # junk = numpy.matmul(gen1_inv, y1)
    # junk = numpy.mod(junk, 2)
    # assert numpy.array_equal(junk, plain)

    # next: 
    # code to reconstruct the whole codeword
    # flip one or more bits in y1
    # see which version of y1 reconstructs to codeword closest to received

    two = numpy.array([ 4.6, -4.6 ]) # for hard->soft conversion

    best_plain = numpy.array([])
    best_score = None # lower is better

    # order 0: don't flip any bits

    xplain = numpy.mod(numpy.matmul(gen1_inv, y1), 2)
    xcode = ldpc_encode(xplain)
    xcode = xcode[colorder]
    xsoftcode = two[xcode]
    xscore = numpy.sum(numpy.square(xsoftcode - codeword))

    if osd_crc == False or check_crc(xplain):
        best_plain = xplain
        best_score = xscore # lower is better

    if order >= 1:
        # order 1: flip one bit
        for i in range(0, len(y1)):
            y1[i] = (y1[i] + 1) % 2
            xplain = numpy.mod(numpy.matmul(gen1_inv, y1), 2)
            y1[i] = (y1[i] + 1) % 2
            xcode = ldpc_encode(xplain)
            xcode = xcode[colorder]
            xsoftcode = two[xcode]
            xscore = numpy.sum(numpy.square(xsoftcode - codeword))
            if best_score == None or xscore < best_score:
                if osd_crc == False or check_crc(xplain):
                    best_plain = xplain
                    best_score = xscore

    if order >= 2:
        # order 2: flip two bits
        for i in range(0, len(y1)):
            for j in range(0, len(y1)):
                y2 = numpy.copy(y1)
                y2[i] = (y2[i] + 1) % 2
                y2[j] = (y2[j] + 1) % 2
                xplain = numpy.mod(numpy.matmul(gen1_inv, y2), 2)
                xcode = ldpc_encode(xplain)
                xcode = xcode[colorder]
                xsoftcode = two[xcode]
                xscore = numpy.sum(numpy.square(xsoftcode - codeword))
                if best_score == None or xscore < best_score:
                    if osd_crc == False or check_crc(xplain):
                        best_plain = xplain
                        best_score = xscore

    return best_plain

def osd_test_gen_1(nbad):
    a87 = numpy.random.randint(0, 2, 87, dtype=numpy.int32)
    cksum = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
                crc12poly)
    a87[-12:] = cksum
    a174 = ldpc_encode(a87)

    # turn hard bits into 0.99 vs 0.01 log-likelihood,
    # log( P(0) / P(1) )
    # log base e.
    ll174 = 1.0 - (2.0 * a174)
    ll174 *= 4.5
    #ll174 *= numpy.random.random(len(ll174))

    # ll174[i] ranges from -1..1 (for bit value of 1 or 0)

    # disturb n bits
    if True:
        bb = numpy.array(range(0, 174), dtype=numpy.int32)
        numpy.random.shuffle(bb)
        for i in range(0, nbad):
            #ll174[bb[i]] *= -1
            ll174[bb[i]] = random.random() - 0.5
            ll174[bb[i]] /= 5.0
    else:
        for junk in range(0, nbad):
            i = random.randint(0, len(ll174)-1)
            x = random.random() - 0.5
            ll174[i] += x

    return ( a87, ll174 )

def osd_test_1():
    global ldpc_iters

    nbad = 87
    iters = 100

    plains = [ ]
    codewords = [ ]
    for iter in range(0, iters):
        ( p, c )  = osd_test_gen_1(nbad)
        plains.append(p)
        codewords.append(c)

    # for comparison
    oli = ldpc_iters
    # for ldpc_iters in [ oli // 2, oli, oli * 2, oli * 4 ]:
    for ldpc_iters in [ oli ]:
        nok = 0
        t0 = time.time()
        for iter in range(0, iters):
            [ _, d87 ] = ldpc_decode(codewords[iter])
            ok = numpy.array_equal(plains[iter], d87)
            if ok:
                nok += 1
        t1 = time.time()
        print("ldpc_decode iters=%d ok=%.2f, %.3f sec" % (ldpc_iters,
                                                          nok / float(iters),
                                                          (t1-t0)/iters))
    ldpc_iters = oli

    for order in [ 0, 1, 2 ]:
        nok = 0
        t0 = time.time()
        for iter in range(0, iters):
            d87 = osd_decode(codewords[iter], order)
            ok = numpy.array_equal(plains[iter], d87)
            if ok:
                nok += 1
        t1 = time.time()
        print("n=%d order=%d ok=%.02f, %.3f sec" % (nbad, order, nok/float(iters),
                                                    (t1-t0)/iters))

    # ldpc_decode ok=0.03, 0.005 sec
    # n=70 order=0 ok=0.43, 0.182 sec
    # n=70 order=1 ok=0.70, 0.610 sec
    # n=70 order=2 ok=0.72, 11.798 sec

    # ldpc_decode iters=16 ok=0.00, 0.001 sec
    # ldpc_decode iters=33 ok=0.00, 0.001 sec
    # ldpc_decode iters=66 ok=0.00, 0.002 sec
    # ldpc_decode iters=132 ok=0.00, 0.005 sec
    # n=70 order=0 ok=0.41, 0.039 sec
    # n=70 order=1 ok=0.70, 0.045 sec
    # n=70 order=2 ok=0.64, 0.591 sec

    # !!! above tained b/c python_gauss_jordan() was subtly incorrect.
    # sadly now the whole scheme looks broken, since higher orders do worse.
    # maybe n=70 is too small?
    # ldpc_decode iters=33 ok=0.01, 0.001 sec
    # n=70 order=0 ok=0.71, 0.000 sec
    # n=70 order=1 ok=0.55, 0.006 sec
    # n=70 order=2 ok=0.15, 0.549 sec
    
    # jan 7 2018
    # ldpc_decode iters=15 ok=0.00, 0.001 sec
    # n=87 order=0 ok=0.26, 0.000 sec
    # n=87 order=1 ok=0.32, 0.005 sec
    # n=87 order=2 ok=0.33, 0.391 sec

if False:
    osd_test_1()
    sys.exit(1)

if False:
    profiling = True
    pfile = "cprof.out"
    sys.stderr.write("ft8: cProfile -> %s\n" % (pfile))
    import cProfile
    import pstats
    cProfile.run('osd_test()', pfile)
    p = pstats.Stats(pfile)
    p.strip_dirs().sort_stats('time')
    # p.print_stats(10)
    p.print_callers()
    sys.exit(1)

# a-priori probability of each of the 174 LDPC codeword
# bits being one. measured from reconstructed correct
# codewords, into ft8bits, then python bprob.py.
apriori174 = numpy.array([
    0.54, 0.45, 0.53, 0.47, 0.46, 0.48, 0.50, 0.49, 0.45, 0.53,
    0.52, 0.51, 0.53, 0.50, 0.47, 0.49, 0.48, 0.48, 0.45, 0.52,
    0.57, 0.50, 0.50, 0.49, 0.54, 0.49, 0.53, 0.46, 0.54, 0.53,
    0.55, 0.54, 0.47, 0.48, 0.47, 0.48, 0.49, 0.48, 0.49, 0.55,
    0.50, 0.52, 0.50, 0.48, 0.55, 0.52, 0.49, 0.50, 0.50, 0.43,
    0.46, 0.51, 0.48, 0.56, 0.45, 0.50, 0.44, 0.53, 0.45, 0.55,
    0.47, 0.52, 0.49, 0.51, 0.53, 0.55, 0.47, 0.50, 0.53, 0.50,
    0.47, 0.49, 0.51, 0.46, 0.54, 0.50, 0.52, 0.57, 0.51, 0.48,
    0.53, 0.46, 0.57, 0.52, 0.51, 0.59, 0.53, 0.88, 0.80, 0.68,
    0.73, 0.64, 0.37, 0.72, 0.47, 0.31, 0.32, 0.28, 0.37, 0.70,
    0.31, 0.36, 0.35, 0.31, 0.39, 0.66, 0.67, 0.37, 0.31, 0.34,
    0.63, 0.66, 0.31, 0.32, 0.66, 0.86, 0.72, 0.51, 0.61, 0.48,
    0.50, 0.55, 0.71, 0.43, 0.41, 0.45, 0.53, 0.57, 0.43, 0.50,
    0.55, 0.45, 0.60, 0.55, 0.47, 0.50, 0.45, 0.53, 0.47, 0.50,
    0.47, 0.49, 0.47, 0.02, 0.89, 0.59, 0.86, 0.91, 0.77, 0.66,
    0.30, 0.68, 0.49, 0.31, 0.61, 0.47, 0.47, 0.40, 0.41, 0.01,
    0.01, 0.01, 0.48, 0.49, 0.50, 0.52, 0.49, 0.54, 0.48, 0.47,
    0.46, 0.47, 0.50, 0.01,
])

# information about one decoded signal.
class Decode:
    def __init__(self,
                 hza,
                 msg,
                 snr,
                 twelve,
                 decode_time):
        self.hza = hza
        self.msg = msg
        self.snr = snr
        self.twelve = twelve # the 72 bits, as 12 6-bit numbers
        self.decode_time = decode_time # unix time of decode
        self.minute = None # cycle number
        self.start = None # sample number
        self.dt = None # dt in seconds
        self.drift = self.hz() - hza[0] # Hz per minute

    def hz(self):
        return numpy.mean(self.hza)

normal_table_stds = 5 # +/- this many std dev
normal_table_gran = 20 # this many points per std dev
normal_table = None
normal_table_log = None

# Normal function integrated from -Inf to x. Range: 0-1.
# x in units of std dev.
# mean is zero.
# the same as scipy.stats.norm.cdf([x])
def real_normal(x):
    y = 0.5 + 0.5*math.erf(x / 1.414213)
    return y

def real_normal_log(x):
    y = scipy.stats.norm.logcdf(x)
    return y

def make_normal_table():
    global normal_table, normal_table_log
    tt = [ ]
    tt_log = [ ]
    x = 0 - normal_table_stds
    while x < normal_table_stds:
        tt.append(real_normal(x))
        tt_log.append(real_normal_log(x))
        x += 1.0 / normal_table_gran
    normal_table = numpy.array(tt)
    normal_table_log = numpy.array(tt_log)

# x is distance from mean, in units of std-dev.
# uses pre-computed table.
def vnormal(x):
    x *= normal_table_gran
    x += (normal_table_stds * normal_table_gran)
    x = numpy.rint(x)
    x = x.astype(numpy.int32)
    x = numpy.maximum(x, 0)
    x = numpy.minimum(x, len(normal_table)-1)
    return normal_table[x]

def vnormal_log(x):
    x *= normal_table_gran
    x += (normal_table_stds * normal_table_gran)
    x = numpy.rint(x)
    x = x.astype(numpy.int32)
    x = numpy.maximum(x, 0)
    x = numpy.minimum(x, len(normal_table_log)-1)
    return normal_table_log[x]

# vectorized normal()
def real_vnormal(v):
    return scipy.stats.norm.cdf(v)

# how much of the distribution is < x?
def problt(x, mean, std):
    if std != 0.0:
        y = normal((x - mean) / std)
    else:
        y = 0.5
    return y

def vproblt(x, mean, std):
    y = vnormal((x - mean) / std)
    return y

def vproblt_log(x, mean, std):
    y = vnormal_log((x - mean) / std)
    return y

# how much of the distribution is > x?
def probgt(x, mean, std):
    if std != 0.0:
        y = 1.0 - normal((x - mean) / std)
    else:
        y = 0.5
    return y

def vprobgt(x, mean, std):
    y = 1.0 - vnormal((x - mean) / std)
    return y

def bit_reverse(x, width):
    y = 0
    for i in range(0, width):
        z = (x >> i) & 1
        y <<= 1
        y |= z
    return y

# turn an array of bits into a number.
# most significant bit first.
def bits2num(bits):
    assert len(bits) < 32
    n = 0
    for i in range(0, len(bits)):
        n *= 2
        n += bits[i]
    return n

# return the best FFT bin number for a frequency.
# assumes 6.25-Hz bins, for FT8.
# the critical thing is that each bin is *centered* at
# a multiple of 6.25 Hz (it does not *start* at a multiple).
def bin_of(hz):
    bin = int((hz + 3.125) / 6.25)
    return bin

# gadget that returns FFT buckets of a fixed set of
# original samples, with required (inter-bucket)
# frequency, drift, and offset.
class FFTCache:
    def __init__(self, samples, jrate, jblock):
        self.jrate = jrate
        self.jblock = jblock
        self.samples = samples

        fg = coarse_fstep
        if down200 == False and fine_fstep > 0:
            fg *= fine_fstep
        self.bin_granules = int(round(fg))

        bg = coarse_tstep
        if down200 == False and fine_tstep > 0:
            bg *= fine_tstep
        self.block_granules = int(round(bg))

        # compute self.all[][]
        self.makeall()

    # do all the FFTs, for all granules.
    def makeall(self):
        bin_hz = self.jrate / float(self.jblock)

        # all[79*granules][fftsize*granules]
        # all[block*granules+blockoff][bin*granules+binoff]
        nblocks = len(self.samples) // self.jblock
        nxall = self.block_granules * nblocks
        nbins = (self.jblock // 2) + 1
        nyall = self.bin_granules * nbins
        self.all = numpy.zeros((nxall, nyall), dtype=numpy.complex128)

        # block granule size, in samples.
        gsize = self.jblock / float(self.block_granules)

        for i in range(0, self.bin_granules):
            ss = self.samples
            if i != 0:
                freq_off = i * (bin_hz / self.bin_granules)
                ss = weakutil.freq_shift(ss, -freq_off, 1.0/self.jrate)
            for gi in range(0, self.block_granules):
                if False:
                    for bi in range(0, nblocks):
                        off = (bi * self.jblock) + int(round(gi * gsize))
                        if off + self.jblock > len(ss):
                            break
                        block = ss[off:off+self.jblock]
                        a = weakutil.rfft(block)
                        alli = bi * self.block_granules + gi
                        self.all[alli][i::self.bin_granules] = a
                else:
                    # use rfftn()
                    i0 = int(round(gi * gsize))
                    nb = len(ss[i0:]) // self.jblock
                    bb = numpy.reshape(ss[i0:i0+nb*self.jblock], (nb, self.jblock))
                    assert nb >= 79
                    mm = numpy.zeros((nb, nbins), dtype=numpy.complex128)
                    # mm[0:79,:] = numpy.fft.rfftn(bb[0:79,:], axes=[1])
                    bbb = numpy.copy(bb[0:79,:]) # fftw rfftn needs this
                    mm[0:79,:] = weakutil.rfftn(bbb, axes=[1])
                    for k in range(79, nb):
                        mm[k,:] = weakutil.rfft(bb[k])
                    self.all[gi:gi+nb*self.block_granules:self.block_granules,i::self.bin_granules] = mm

    # return bins[symbol][bin] -- i.e. a mini-FFT per symbol.
    def get_complex(self, hz, start):
        [ hz0, offset0, m ] = self.getall_complex(hz, start)
        bin = bin_of(hz - hz0)
        subm = m[start // self.jblock : , bin : bin+8]
        return [ hz0, offset0, subm ]

    def get(self, hz, start):
        [ hz0, offset0, m1 ] = self.get_complex(hz, start)
        m1 = abs(m1)
        return [ hz0, offset0, m1 ]

    # not used yet, but does hz drift.
    def new_get(self, hza, start):
        bin_hz = self.jrate / float(self.jblock)

        nx = len(self.samples) // self.jblock
        m = numpy.zeros((nx, 8))

        for x in range(0, nx):
            offset = start + x*self.jblock
            xi = offset // (self.jblock // self.block_granules)
            hz = hza[0] + (hza[1] - hza[0]) * (x / float(nx))
            hzi = int(round(hz / (bin_hz / self.bin_granules)))
            if xi < self.all.shape[0]:
                m[x] = self.all[xi][hzi:hzi+8*self.bin_granules:self.bin_granules]

        return m

    # return the complete set of FFTs, m[symbol][bin]
    # hz and start just cause a sub-bin and sub-symbol shift.
    # that is, the returned array starts near hz=0
    # and offset=0.
    # returns complex FFT results.
    # returns [ hz0, offset0, ffts ]
    def getall_complex(self, hz, start):
        bin_hz = self.jrate / float(self.jblock)
        bingran = bin_hz / self.bin_granules

        # which quarter-bin?
        #bin = int(hz / bin_hz)
        #binfrac = (hz / bin_hz) - bin
        #binkey = int(binfrac / (1.0 / self.bin_granules))

        bgi = int((hz + (bingran/2)) / bingran)
        binkey = bgi % self.bin_granules

        # which eighth-block?
        blockoff = start % self.jblock
        gsize = self.jblock / float(self.block_granules)
        blockkey = int(round(blockoff / gsize))

        # binkey is 0..self.bin_granules
        # blockkey is 0..self.block_granules
        m = self.all[blockkey::self.block_granules,binkey::self.bin_granules]

        return [ binkey*bingran,
                 blockkey*(self.jblock // self.block_granules),
                 m ]

    def getall(self, hz, start):
        [ hz0, offset0, m ] = self.getall_complex(hz, start)
        m = abs(m)
        return [ hz0, offset0, m ]

    def len(self):
        return len(self.samples)

# for unpack() &c.
NBASE = 37*36*10*27*27*27
# start of special grid locators for sig strength &c.
NGBASE = 180*180

class FT8:
    debug = False

    offset = 0

    def __init__(self):
        self.msgs_lock = threading.Lock()
        self.msgs = [ ]
        self.verbose = False
        self.enabled = True
        self.extra_budget = 0
        self.band = "-"
        self.carddesc = None
        self.restrict_hz = None

        self.jrate = 12000 // 2 # sample rate for processing (FFT &c)
        self.jblock = 1920 // 2 # samples per symbol

        weakutil.init_freq_from_fft(32)
        weakutil.init_freq_from_fft(1920)
        weakutil.init_freq_from_fft(1920 // 2)
        weakutil.init_freq_from_fft(1920 // 4)

        weakutil.init_fft([1920, 1920 // 2, 1920 // 4, 32])

        # set self.start_time to the UNIX time of the start
        # of the last UTC minute.
        now = int(time.time())
        gm = time.gmtime(now)
        self.start_time = now - gm.tm_sec

        make_normal_table()

    def close(self):
        pass

    def junklog(self, samples_time, msg):
        minute = self.minute(samples_time + 1)
        gm = time.gmtime(self.minute2time(minute))
        hms = "%02d:%02d:%02d" % (
            gm.tm_hour,
            gm.tm_min,
            gm.tm_sec)
        msg = "%s %s %s %s\n" % (self.ts(time.time()),
                                 hms,
                                 self.carddesc,
                                 msg)

        #sys.stderr.write(msg)
        f = open("ft8-junk.txt", "a")
        f.write(msg)
        f.close()

    # seconds per cycle
    def cycle_seconds(self):
        return 15

    # return the minute number for t, a UNIX time in seconds.
    # truncates down, so best to pass a time mid-way through a minute.
    # returns only even minutes.
    def minute(self, t):
        dt = t - self.start_time
        return int(dt / 15.0)

    # convert cycle number to UNIX time.
    def minute2time(self, m):
        return (m * 15) + self.start_time

    # seconds since minute(), 0..15
    def second(self, t):
        dt = t - self.start_time
        dt /= 15.0
        return 15.0 * (dt - int(dt))

    def seconds_left(self, t):
        return 15 - self.second(t)

    # printable UTC timestamp, e.g. "07/07/15 16:31:00"
    # dd/mm/yy hh:mm:ss
    # t is unix time.
    def ts(self, t):
        gm = time.gmtime(t)
        return "%02d/%02d/%02d %02d:%02d:%02d" % (gm.tm_mday,
                                                  gm.tm_mon,
                                                  gm.tm_year - 2000,
                                                  gm.tm_hour,
                                                  gm.tm_min,
                                                  gm.tm_sec)

    # UNIX time to HHMMSS
    def hhmmss(self, t):
        gm = time.gmtime(t)
        return "%02d%02d%02d" % (gm.tm_hour, gm.tm_min, gm.tm_sec)

    def openwav(self, filename):
        self.wav = wave.open(filename)
        self.wav_channels = self.wav.getnchannels()
        self.wav_width = self.wav.getsampwidth()
        self.cardrate = self.wav.getframerate()

    def readwav(self, chan):
        z = self.wav.readframes(8192)
        if self.wav_width == 1:
            zz = numpy.fromstring(z, numpy.int8)
        elif self.wav_width == 2:
            if (len(z) % 2) == 1:
                return numpy.array([])
            zz = numpy.fromstring(z, numpy.int16)
        else:
            sys.stderr.write("oops wave_width %d" % (self.wav_width))
            sys.exit(1)
        if self.wav_channels == 1:
            return zz
        elif self.wav_channels == 2:
            return zz[chan::2] # chan 0/1 => left/right
        else:
            sys.stderr.write("oops wav_channels %d" % (self.wav_channels))
            sys.exit(1)

    def gowav(self, filename, chan):
        self.openwav(filename)
        bufbuf = [ ]
        while True:
            buf = self.readwav(chan)
            if buf.size < 1:
                break
            bufbuf.append(buf)
        samples = numpy.concatenate(bufbuf)

        # trim trailing zeroes that wsjt-x adds to .wav files.
        i = len(samples)
        while i > 1000 and numpy.max(samples[i-1:]) == 0.0:
            if numpy.max(samples[i-1000:]) == 0.0:
                i -= 1000
            elif numpy.max(samples[i-100:]) == 0.0:
                i -= 100
            elif numpy.max(samples[i-10:]) == 0.0:
                i -= 10
            else:
                i -= 1
        samples = samples[0:i]

        self.process(samples, 0)

    def opencard(self, desc):
        self.carddesc = desc
        self.cardrate = 6000 # 12000 // 2
        self.audio = weakaudio.new(desc, self.cardrate)

    def gocard(self):
        bufbuf = [ ]
        nsamples = 0
        prev_buf_time = None
        last_tmin = None
        self.audio.read() # get the SDR-IP started
        while True:
            sec0 = self.second(time.time())
            if sec0 < 13.14:
                # read big chunks so that the SDR-IP I/Q to USB
                # conversion works better.
                time.sleep(13.14 - sec0)

            [ buf, buf_time ] = self.audio.read()

            # buf_time is the UNIX time of the last sample in buf[].

            if len(buf) > 0:
                # is there a gap in the sample stream?
                if prev_buf_time != None:
                    dt = buf_time - prev_buf_time
                    expected = self.cardrate * dt
                    got = len(buf)
                    if abs(expected-got) > 2:
                        self.junklog(buf_time,
                                     "gocard expected %d got %d" % (expected, got))

                mx = numpy.max(numpy.abs(buf))
                if mx > 30000:
                    sys.stderr.write("!")
                bufbuf.append(buf)
                nsamples += len(buf)
                prev_buf_time = buf_time
            else:
                # self.audio.read() is non-blocking, so sleep a bit.
                time.sleep(0.1)

            # an FT8 frame starts on second 0.5, and takes 12.64 seconds.
            if nsamples >= 13.14*self.cardrate:
                sec = self.second(buf_time)
                if sec >= 13.14:
                    # we have >= 13.14 seconds of samples,
                    # and second of minute is >= 13.14.

                    samples = numpy.concatenate(bufbuf)

                    excess = len(samples) - 15*self.cardrate
                    if excess < -1000 or excess > 1000:
                        self.junklog(buf_time, "gocard excess %d" % (excess))

                    # sample # of start of 15-second interval.
                    i0 = len(samples) - self.cardrate * self.second(buf_time)
                    i0 = int(i0)
                    i0 = max(i0, 0)

                    # UNIX time of samples[i0]
                    samples_time = buf_time - (len(samples)-i0) * (1.0/self.cardrate)

                    tmin = self.minute(samples_time + 1)
                    if last_tmin != None and tmin != last_tmin + 1:
                        self.junklog(samples_time, "gocard jumped minute %d %d" % (last_tmin, tmin))
                    last_tmin = tmin

                    self.process(samples[i0:], samples_time)

                    bufbuf = [ ]
                    nsamples = 0

    # received a message, add it to the list.
    # offset in seconds.
    # drift in hz/minute.
    def got_msg(self, dec):
        self.msgs_lock.acquire()

        # already in msgs with worse nerrs?
        found = False
        for i in range(max(0, len(self.msgs)-40), len(self.msgs)):
            xm = self.msgs[i]
            if xm.minute == dec.minute and abs(xm.hz() - dec.hz()) < 10 and xm.msg == dec.msg:
                # we already have this msg
                found = True
                if dec.snr > xm.snr:
                    self.msgs[i] = dec

        if found == False:
            self.msgs.append(dec)

        self.msgs_lock.release()

    # someone wants a list of all messages received,
    # as array of Decode.
    def get_msgs(self):
        self.msgs_lock.acquire()
        a = self.msgs
        self.msgs = [ ]
        self.msgs_lock.release()
        return a

    # c is a pipe from a sub-process.
    def readchild(self, c, samples_time):
        start_time = time.time()
        n = 0
        while True:
            try:
                # poll so we won't wait forever if the sub-process
                # is wedged.
                some = c.poll(budget + self.extra_budget + 1)
                if some == False:
                    break
                dec = c.recv()
                self.got_msg(dec)
                n += 1
            except:
                break

        dt = time.time() - start_time
        if dt > budget + self.extra_budget + 0.5:
            self.junklog(samples_time, "sub-process did not quit %.1f got %d" % (dt, n))

        c.close()

    # run the FT8 decode in a separate process. this yields
    # much more parallelism for multiple receivers than
    # Python's threads.
    # samples_time is UNIX time that samples[0] was
    # sampled by the sound card.
    def process(self, samples, samples_time):
        min_hz = 100
        max_hz = 2500
        if self.restrict_hz != None:
            if self.restrict_hz[0] > min_hz:
                min_hz = self.restrict_hz[0]
            if self.restrict_hz[1] < max_hz:
                max_hz = self.restrict_hz[1]

        global very_first_time
        do_fork = not (profiling or very_first_time)
        very_first_time = False

        ss = self.second(time.time())
        if self.band != "-" and self.enabled and (ss > 13.8 or ss < 13):
            self.junklog(samples_time, "late start %.1f" % (self.second(time.time())))
        sys.stdout.flush()

        nchildren = 2
        procs = [ ]
        readers = [ ]
        for chi in range(0, nchildren):
            # adjust min_hz and max_hz
            hzinc = (max_hz - min_hz) / nchildren
            hz0 = min_hz + chi*hzinc
            hz1 = hz0 + hzinc
            if chi > 0:
                hz0 -= 60
            if chi < nchildren-1:
                hz1 += 60

            rpipe, spipe = multiprocessing.Pipe(False)
            if do_fork:
                px = multiprocessing.Process(target=self.process00,
                                             args=[samples, samples_time, spipe, rpipe,
                                                   hz0, hz1])
                px.start()
                procs.append(px)
                spipe.close()
            else:
                # either profiling, or warming caches for the very first cycle.
                self.process00(samples, samples_time, spipe, None, hz0, hz1)

            th = threading.Thread(target=lambda c=rpipe: self.readchild(c, samples_time))
            th.start()
            readers.append(th)

        oband = self.band

        # wait for the readchild threads.
        for chi in range(0, len(readers)):
            readers[chi].join(budget+self.extra_budget+1.0)
            if do_fork:
                procs[chi].terminate()
                procs[chi].join(0.5)

        if os.path.isfile("./savewave"):
            filename = "save/%s-%s.wav" % (self.hhmmss(samples_time), oband)
            weakutil.writewav1(samples, filename, self.cardrate)

        if self.band != "-" and self.enabled and self.second(time.time()) > 13:
            self.junklog(samples_time, "late end %.1f" % (self.second(time.time())))

    def process00(self, samples, samples_time, spipe, rpipe, min_hz, max_hz):
        if rpipe != None:
            rpipe.close()
        thunk = (lambda dec : spipe.send(dec))
        self.process0(samples, samples_time, thunk, min_hz, max_hz)
        spipe.close()

    def process0(self, samples, samples_time, thunk, min_hz, max_hz):
        global budget, ldpc_iters

        if self.enabled == False:
            return

        # samples_time is UNIX time that samples[0] was
        # sampled by the sound card.
        samples_minute = self.minute(samples_time + 1)

        t0 = time.time()

        down_hz = 0
        if top_down and min_hz > 500 and max_hz - min_hz < 1400 and (self.cardrate % 3000) == 0:
            # high-pass filter
            cut = min_hz
            if top_high_order == 0:
                filter = weakutil.cheby_highpass(min_hz - 12.0, self.cardrate)
            else:
                filter = weakutil.butter_highpass(min_hz, self.cardrate,
                                                  order=top_high_order)
            samples = scipy.signal.lfilter(filter[0], filter[1], samples)

            # shift down
            down_hz = min_hz - 50
            samples = weakutil.freq_shift(samples, -down_hz, 1.0 / self.cardrate)
            max_hz -= down_hz
            min_hz -= down_hz

            self.jrate = 12000 // 4
            self.jblock = 1920 // 4
            down_factor = self.cardrate // self.jrate
            assert self.jrate * down_factor == self.cardrate

            if top_low_order == 0:
                filter = weakutil.cheby_lowpass(0.45 * self.jrate, self.cardrate)
            else:
                filter = weakutil.butter_lowpass(0.45 * self.jrate,
                                                 self.cardrate,
                                                 order=top_low_order)
            samples = scipy.signal.lfilter(filter[0], filter[1], samples)

            samples = samples[::down_factor]

        elif bottom_slow and max_hz < 1400 and (self.cardrate % 3000) == 0:
            self.jrate = 12000 // 4
            self.jblock = 1920 // 4
            down_factor = self.cardrate // self.jrate
            assert self.jrate * down_factor == self.cardrate

            if bottom_low_order == 0:
                filter = weakutil.cheby_lowpass(0.45 * self.jrate, self.cardrate)
            else:
                filter = weakutil.butter_lowpass(0.45 * self.jrate,
                                                 self.cardrate,
                                                 order=bottom_low_order)
            samples = scipy.signal.lfilter(filter[0], filter[1], samples)

            samples = samples[::down_factor]

        elif self.cardrate == 12000:
            self.rate = 12000 // 2
            self.jblock = 1920 // 2

            filter = weakutil.butter_lowpass(0.45 * self.jrate,
                                             self.cardrate,
                                             order=7)
            # filter = weakutil.cheby_lowpass(0.45 * self.jrate, self.cardrate)
            samples = scipy.signal.lfilter(filter[0], filter[1], samples)
            samples = samples[::2]
        elif self.cardrate != self.jrate:
            print("cannot handle cardrate %d" % (self.cardrate))
            assert False

        # nominal signal start time is half a second into samples[].
        # prepend and append padding.
        # result: end_pad samples, then start of on-time signals.
        # pad with plausible signal levels.
        start_pad = int(2.5 * self.jrate)
        end_pad = int(2.5 * self.jrate)
        sm = numpy.mean(samples[self.jrate:self.jrate*2])
        sd = numpy.std(samples[self.jrate:self.jrate*2])
        sm /= 10 # XXX
        sd /= 10 # XXX
        sd /= 4.0
        # sm /= 4.0
        # sd /= 4.0
        nbefore = start_pad - self.jrate // 2
        samples = numpy.append(numpy.random.normal(sm, sd, nbefore), samples)

        wanted = 79*self.jblock + start_pad + end_pad - len(samples)
        if wanted > 0:
            samples = numpy.append(samples, numpy.random.normal(sm, sd, wanted))

        bin_hz = self.jrate / float(self.jblock)

        # I think signals should start 0.5 seconds into the minute,
        # at offset start_pad. But it seems like they generally start
        # later, captured by start_adj.
        adjusted_start = start_pad + int(self.jrate * start_adj)

        # find a clear spot, to help prevent our future replies
        # from interfering with other traffic.
        clear_hz = self.find_clear(samples[adjusted_start:], min_hz, max_hz)

        # suppress duplicate message decodes,
        # indexed by message text.
        already_msg = { }

        nphases = subpasses + 1
        for phase in range(0, nphases):
            used = time.time() - t0
            if used >= budget + self.extra_budget:
                break

            phase_got_some = False # decoded anything in this phase?

            if phase == 0:
                # non-subtracted
                xf = FFTCache(samples, self.jrate, self.jblock)
                ssamples = numpy.copy(samples) # for subtraction
                ranking = self.coarse(xf, adjusted_start, min_hz, max_hz)
            elif phase > 0:
                # revisit coarse list, with subtracted ssamples
                xf = FFTCache(ssamples, self.jrate, self.jblock)
                ssamples = numpy.copy(ssamples)
                ranking = self.coarse(xf, adjusted_start, min_hz, max_hz)

            # suppress duplicate attempts to look at
            # the same hz and offset. duplicates can arise
            # due to find_*slop.
            # indexed by "hz-offset".
            already_fine = { }

            # if we successfully decoded, don't bother looking
            # at nearby bins.
            # key is "%d-%d" % (offset/jblock, hz/6.25)
            already_coarse = { }

            for rr in ranking:
                used = time.time() - t0
                if used >= budget + self.extra_budget:
                    break

                left = budget - used
                if phase+1 < nphases and phase_got_some and used > budget * ((phase+1.0) / nphases):
                    # switch to [next pass of] subtracted ssamples
                    break

                # rr is [ hz, offset, strength ]
                hz = rr[0]
                offset = rr[1]

                # index into already_coarse.
                acoffset = int(round(offset / float(self.jblock)))
                achz = int(round(hz / bin_hz))
                ackey = "%d-%d" % (acoffset, achz)
                if ackey in already_coarse:
                    continue

                dec = self.process1(xf, hz, offset, already_fine)

                if dec != None:
                    for ooo in range(acoffset-already_o, acoffset+already_o+1):
                        for hhh in range(achz-already_f, achz+already_f+1):
                            ackey = "%d-%d" % (ooo, hhh)
                            already_coarse[ackey] = True
                    phase_got_some = True
                    dec.dt = ((dec.start - start_pad) / float(self.jrate))
                    dec.minute = samples_minute
                    dec.clear_hz = clear_hz
                    dec.hza[0] += down_hz
                    dec.hza[1] += down_hz
                    dec.clear_hz += down_hz
                    if do_subtract == 3 and phase+1 < nphases:
                        ssamples = self.subtract_v5(ssamples, dec, dec.hz() - down_hz)
                    if not dec.msg in already_msg:
                        shz = dec.hz() - down_hz
                        if phase+1 < nphases and do_subtract in [ 1, 2, 4 ]:
                            shz = self.known_best_freq(ssamples, dec, shz, xf) # improved hz for subtraction
                        if do_subtract == 1 and phase+1 < nphases:
                            ssamples = self.subtract_v5(ssamples, dec, shz)
                        if do_subtract == 2 and phase+1 < nphases:
                            # multiple times, vary the hz
                            ssamples = self.subtract_v5(ssamples, dec, shz)
                            ssamples = self.subtract_v5(ssamples, dec, shz - subgap)
                            ssamples = self.subtract_v5(ssamples, dec, shz + subgap)
                        if do_subtract == 4 and phase+1 < nphases:
                            ssamples = self.subtract_v5(ssamples, dec, shz)
                            ssamples = self.subtract_v5(ssamples, dec, dec.hz() - down_hz)
                        already_msg[dec.msg] = True
                        if self.verbose:
                            print("P%d %s %4.1f %6.2f %5d %.2f %.0f %s" % (phase,
                                                                          self.band,
                                                                          self.second(dec.decode_time),
                                                                          dec.hz(),
                                                                          dec.start,
                                                                          dec.dt,
                                                                          dec.snr,
                                                                          dec.msg))
                        thunk(dec)

    # down-convert to 200 samples/second,
    # or 32 samples per symbol. like wsjt-x.
    # moves hz at 25 hz, or bin=4.
    # hz must be on a coarse boundary.
    def downconvert200(self, xf, hz):
        bin_hz = self.jrate / float(self.jblock)

        gran = bin_hz / coarse_fstep
        assert int(round(hz / gran)) * gran == hz

        [ hzoff, _, m ] = xf.getall_complex(hz, 0)

        # hz is centered on m[...][bin].
        bin = int(round((hz - hzoff) / bin_hz))

        # move bin to bin=4 == 25 Hz.
        # need 17 bins for inverse FFT to yield 32 samples/symbol.
        assert bin >= 4
        m1 = m[:,bin-4:bin-4+17]

        # inverse FFTs, to generate sample rate of 200/second.
        slow = numpy.zeros(32*m1.shape[0])
        for i in range(0, m1.shape[0]):
            z = numpy.fft.irfft(m1[i,:])
            slow[i*32:(i+1)*32] = z

        return slow

    # return a 79x8 complex mini-FFT.
    # s is 200 samples/second, 32 samples per symbol.
    def extract200(self, s, off, hz):
        bin = int(hz / 6.25)
        assert bin >= 3 and bin <= 5
        hzshift = hz - 6.25 * bin
        assert hzshift >= 0.0
        if hzshift != 0.0:
            s = weakutil.freq_shift(s, -hzshift, 1.0/200)

        s = s[off:off+79*32]

        bb = numpy.reshape(s, (79,32))
        bb = numpy.copy(bb) # needed for fftw rfftn
        # mm = numpy.fft.rfftn(bb, axes=[1])
        mm = weakutil.rfftn(bb, axes=[1])

        m = mm[:,bin:bin+8]

        return m

    def process1(self, xf, hz, offset, already_hzo):
        if down200:
            return self.new_process1(xf, hz, offset, already_hzo)
        else:
            return self.old_process1(xf, hz, offset, already_hzo)

    # hz and offset are from coarse search.
    def old_process1(self, xf, hz, offset, already_hzo):
        bin_hz = self.jrate / float(self.jblock)

        hz0 = hz
        offset0 = offset

        if offset < 0 or (offset+79*self.jblock) > xf.len():
            return None

        offstep = self.jblock // coarse_tstep
        if fine_tstep > 1:
            offstep //= fine_tstep
        hzstep = bin_hz / coarse_fstep
        if fine_fstep > 1:
            hzstep /= fine_fstep

        if fine_tstep > 1:
            # improve the starting offset.
            off0 = offset - (fine_tstep // 2) * offstep
            off1 = offset + (fine_tstep // 2) * offstep
            offs = self.best_offsets(xf, hz, off0, off1, offstep)
            offs = offs[0:fine_no]
        else:
            offs = [ [ offset, 0 ] ]

        for [ offset, _ ] in offs:
            if fine_fstep > 1:
                # improve the starting hz.
                if True:
                    hzoff0 = hz0 - (fine_fstep // 2) * hzstep
                    hzoff1 = hz0 + (fine_fstep // 2) * hzstep
                    [ hz, strength ] = self.best_freq(xf, offset, hzoff0, hzoff1, hzstep)
                else:
                    hz = self.alternate_best_freq(xf, hz, offset)

            # the fine_ loops overlap at the edges. try each point just once.
            khz = int(round(hz))
            koff = offset // offstep
            key = "%d-%d" % (khz, koff)
            if key in already_hzo:
                continue
            already_hzo[key] = True

            [ _, _, ss ] = xf.get_complex(hz, offset)
            # ss has 79 8-bucket mini-FFTs.

            dec = self.process2(ss[0:79], hz, offset)
                
            if dec != None:
                return dec

        return None

    # hz and offset are from coarse search.
    def new_process1(self, xf, hz1, offset1, already_fine):
        bin_hz = self.jrate / float(self.jblock)

        if offset1 < 0 or (offset1+79*self.jblock) > xf.len():
            return None
        
        # 200 samples/second, 32 samples/symbol,
        # hz moved to bin 4 (25 Hz).
        slow = self.downconvert200(xf, hz1)
        offset = int((offset1 / float(self.jrate)) * 200)
        hz = 25.0

        # fine-tune the offset.
        bestoff = None
        beststrength = None
        gran = 32 // coarse_tstep
        if fine_tstep >= 1:
            gran = gran // fine_tstep
        if gran < 1:
            gran = 1
        for off in range(offset - (32/coarse_tstep),
                         offset + (32/coarse_tstep) + 1,
                         gran):
            if off < 0 or len(slow) - off < 32*79:
                continue
            m = self.extract200(slow, off, hz)
            m = abs(m)
            s = self.strength(m)
            if bestoff == None or s > beststrength:
                bestoff = off
                beststrength = s
        offset = bestoff

        # fine-tune hz
        besthz = None
        beststrength = None
        bestm = None
        for hzx in numpy.arange(hz - (6.25 / coarse_fstep),
                                hz + (6.25 / coarse_fstep) + 0.0001,
                                6.25 / (coarse_fstep * fine_fstep)):
            m = self.extract200(slow, offset, hzx)
            m = abs(m)
            s = self.strength(m)
            if besthz == None or s > beststrength:
                besthz = hzx
                beststrength = s
                bestm = m
        hz = besthz
        m = bestm

        # reference hz/offset back to self.jrate world.
        offset2 = int((offset / 200.0) * self.jrate)
        hz2 = hz1 + (hz - 25.0)

        # the fine loops overlap at the edges. try each point just once.
        # XXX move this into loops above?
        khz = int(round(hz2))
        koff = offset2 // (self.jblock // (coarse_tstep * fine_tstep))
        key = "%d-%d" % (khz, koff)
        if key in already_fine:
            return None
        already_fine[key] = True

        dec = self.process2(m[0:79], hz2, offset2)

        if dec != None:
            return dec

        return None

    # find a clear hz in case we want to reply.
    # samples[] starts at nominal start time (0.5 seconds).
    def find_clear(self, samples, min_hz, max_hz):
        bin_hz = self.jrate / float(self.jblock)
        occupied1 = numpy.zeros((self.jblock // 2) + 1)
        for sec in [ 2, 4, 6, 7, 9, 11 ]:
            i1 = int(sec*self.jrate)
            i2 = i1 + self.jblock
            occupied1 += weakutil.arfft(samples[i1:i2])
        occupied2 = numpy.copy(occupied1)
        for bi in range(1, 8):
            occupied2[0:-bi] += occupied1[bi:]
        b1 = int(min_hz / bin_hz)
        b2 = int(max_hz / bin_hz)
        clear_bin = numpy.argmin(occupied2[b1:b2]) + b1
        clear_hz = clear_bin * bin_hz
        return clear_hz

    # use freq_from_fft to find offset from center of bin.
    # this version knows the transmitted signal!
    # for subtraction.
    def known_best_freq(self, samples, dec, hz, xf):
        bin_hz = self.jrate / float(self.jblock)
        bin = bin_of(hz)

        snd = FT8Send()
        symbols = snd.make_symbols(dec.twelve)

        hz_sum = 0.0
        weight_sum = 0.0
        
        # only used for weighting
        [ _, _, m ] = xf.get(hz, dec.start)

        for i in range(0, len(symbols)):
            ind = dec.start + i*(self.jblock)
            block = samples[ind:ind+self.jblock]
            bin1 = bin + symbols[i]
            bin2 = weakutil.bin_from_fft(block, self.jrate, bin1)
            if bin2 == None:
                continue
            nhz = bin2 * bin_hz
            nhz -= symbols[i] * bin_hz # reference to base tone
            if abs(nhz - hz) < bin_hz*0.5:
                #weight = 1
                weight = m[i][symbols[i]] / numpy.min(m[i][0:8])
                hz_sum += nhz * weight
                weight_sum += weight
        if weight_sum == 0:
            return hz
        return hz_sum / weight_sum

    # subtract a decoded signal (hz/start/twelve) from the samples,
    # so that we can then decode weaker signals underneath it.
    # i.e. interference cancellation.
    # generates the right tone for each symbol, finds the best
    # offset w/ correlation, finds the amplitude, subtracts in the time domain.
    def subtract_v5(self, osamples, dec, hz0):
        bin_hz = self.jrate / float(self.jblock)

        # the 79 symbols, each 0..8
        snd = FT8Send()
        symbols = snd.make_symbols(dec.twelve)

        samples = numpy.copy(osamples)

        if dec.start < 0:
            samples = numpy.append([0.0]*(-dec.start), samples)
        else:
            samples = samples[dec.start:]

        # pre-compute the tones, since costone() is somewhat expensive.
        # tone_cache[sym_num][phase_i]
        tone_cache = [ ]
        for sym in range(0, 8):
            ta = [ ]
            for phase_i in range(0, substeps):
                hz = hz0 + sym * bin_hz
                phase = phase_i * ((2*numpy.pi) / substeps)
                tone = weakutil.costone(self.jrate, hz, self.jblock, phase)
                ta.append(tone)
            tone_cache.append(ta)

        # find amplitude and offset (phase) of each symbol.
        amps = [ ]
        offs = [ ]
        tones = [ ]
        i = 0
        while i < len(symbols):
            nb = 1
            #while i+nb < len(symbols) and symbols[i+nb] == symbols[i]:
            #    nb += 1

            # start+end of symbol in samples[]
            i0 = i * self.jblock
            i1 = i0 + nb*self.jblock

            # try a few different phases, remember the best one.
            best_corr = 0.0
            best_tone = numpy.array([])
            for phase_i in range(0, substeps):
                tone = tone_cache[symbols[i]][phase_i]
                corr = numpy.sum(tone * samples[i0:i1])
                if len(best_tone) == 0 or corr > best_corr:
                    best_tone = tone
                    best_corr = corr

            assert len(best_tone) == i1-i0

            # what is the amplitude?
            # if actual signal had a peak of 1.0, then
            # correlation would be sum(tone*tone).
            c1 = numpy.sum(best_tone * best_tone)
            a = best_corr / c1

            amps.append(a)
            offs.append(i0)
            tones.append(best_tone)

            i += nb

        ai = 0
        while ai < len(amps):
            a = amps[ai]
            off = offs[ai]
            tone = tones[ai]
            samples[off:off+len(tone)] -= tone * a
            ai += 1

        if dec.start < 0:
            nsamples = samples[(-dec.start):]
        else:
            nsamples = numpy.append(osamples[0:dec.start], samples)

        return nsamples

    # estimate the probability that m79 contains an FT8 signal.
    # looks only at Costas blocks.
    # looks at how far Costas signal is from mean/std of noise.
    # m79 is a mini-fft.
    # hmm, this kind of probability might be useful for comparing
    # two different signals, but it is not so useful in making
    # fine adjustments in best_offset()/best_freq() since small
    # changes to the noise variance can have a big effect.
    # i.e. it's a bit unstable.
    # (not used, never was useful)
    def estimate_probability(self, m79):
        # mask in shape of Costas array with False at
        # Costas locations.
        mask0 = numpy.ones((7,8), dtype=bool)
        mask1 = numpy.zeros((7,8), dtype=bool)
        costas = [ 2, 5, 6, 0, 4, 1, 3 ]
        for i in range(0, 7):
            mask0[i,costas[i]] = False
            mask1[i,costas[i]] = True

        # calculate probability that this is really a signal,
        # as the sum of the per-bit log(P(signal)).
        log_p_sig = 0.0
            
        for ci in [0, 36, 72]:
            # the costas block
            b = m79[ci:ci+7]

            # the seven costas strengths.
            c = b[mask1,...]

            # omit the expected costas signal, leaving
            # a one-dimensional vector of 49 elements
            b = b[mask0,...]
            
            mean = numpy.mean(b)
            std = numpy.std(b)

            lps = scipy.stats.norm.logcdf((c - mean) / std)
            #lps = vproblt_log(c, mean, std)
            log_p_sig = log_p_sig + numpy.sum(lps)


        return log_p_sig

    # how strong are the costas signals?
    # suitable for best_offset()/best_strength(),
    # where we're just comparing a signal to itself,
    # so clever treatment of noise isn't needed.
    def strength(self, m79):
        a = m79[0:7] + m79[36:43] + m79[72:79]
        sum = (a[0,2] + a[1,5] + a[2,6] + a[3,0] +
               a[4,4] + a[5,1] + a[6,3])
        #sum = sum - numpy.sum(a)*noise_factor + sum*noise_factor

        # subtract surrounding bins
        neg = 0
        # left
        neg += (a[0,5] + a[1,6] + a[2,0] +
                a[3,4] + a[4,1] + a[5,3])
        # up
        neg += (a[0,3] + a[1,6] + a[2,7] + a[3,1] +
                a[4,5] + a[5,2] + a[6,4])
        # right
        neg += (a[1,2] + a[2,5] + a[3,6] + a[1,0] +
                a[5,4] + a[6,1])
        # down
        neg += (a[0,1] + a[1,4] + a[2,5] +
                a[4,3] + a[5,0] + a[6,2])
        neg /= 4.0
        sum -= neg

        if contrast_weight > 0:
            for b in [ m79[8:36], m79[44:72] ]:
                sss = numpy.sort(b, 1)
                z = numpy.sum(sss[:,7])
                z -= numpy.sum(sss[:,0:7]) * noise_factor
                sum += contrast_weight * z

        return sum

    # contrast: how much the strongest bin
    # in each symbol time is stronger than the second-
    # strongest.
    # sort the 8 bins in each symbol time.
    # (no longer used)
    def contrast(self, m79):
        sss = numpy.sort(m79, 1)
        aaa = sss[:,7]
        bbb = sss[:,6]

        contrasts = numpy.divide(aaa,
                                 bbb,
                                 out=numpy.ones(len(m79)),
                                 where=bbb!=0)

        contrast = numpy.sum(contrasts)
        contrast /= len(m79)
        contrast -= 1.0

        return contrast

    # use freq_from_fft to find offset from center of bin
    def alternate_best_freq(self, xf, hz, offset):
        [ hz0, offset0, ss ] = xf.getall_complex(hz, offset)
        ss = abs(ss)
        bin_hz = self.jrate / float(self.jblock)
        bin = bin_of(hz - hz0)
        start = offset // self.jblock
        # ss[start:start+79,bin:bin+8]
        hz_sum = 0.0
        weight_sum = 0.0
        for i0 in [0, 36, 72]:
            costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
            for i in range(i0, i0+7):
                maxi = costas_symbols[i-i0]
                mini = numpy.argmin(ss[start+i,bin:bin+8])
                vv = ss[start+i,bin+maxi-1:bin+maxi+2]
                xp = weakutil.parabolic(numpy.log(vv), 1) # interpolate
                if xp != None and xp[0] >= 0 and xp[0] <= 2:
                    true_bin = xp[0] + bin + maxi - 1
                    true_hz = true_bin * bin_hz
                    true_hz -= maxi * bin_hz # reference back to base tone
                    weight = ss[start+i,bin+maxi] / ss[start+i,bin+mini]
                    #weight -= 1
                    hz_sum += true_hz * weight
                    weight_sum += weight
        if weight_sum == 0:
            return hz
        return (hz_sum / weight_sum) + hz0

    # find hz with best Costas sync at offset=start.
    # look at frequencies midhz +/ slop,
    # at granule hz increments.
    # returns [ hz, strength ]
    def best_freq(self, xf, start, hzoff0, hzoff1, hzstep):
        start = int(start)

        rank = [ ]
        for hz in numpy.arange(hzoff0, hzoff1*1.0001, hzstep):
            [ _, _, m79 ] = xf.get(hz, start)
            if len(m79) < 79:
                continue
            m79 = m79[0:79]
            # m79 has 79 8-bucket mini-FFTs.

            c = self.strength(m79)

            rank.append([hz, c])

        rank = sorted(rank, key = lambda e : - e[1])
        return rank[0]

    def old_best_freq(self, xf, midhz, start, slop, granule):
        start = int(start)

        # a Costas sync array.
        costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
        costas_array = numpy.ones((7, 8)) * (-1 / 7.0)
        for i in range(0, len(costas_symbols)):
            costas_array[i][costas_symbols[i]] = 1

        hz_start = midhz - slop
        hz_end = midhz + slop

        corrs = [ ]
        for hz in numpy.arange(hz_start, hz_end*1.0001, granule):
            [ _, _, ss ] = xf.get(hz, start)
            if len(ss) < 79:
                continue
            # ss has 79 8-bucket mini-FFTs.

            a = ss[0:7] + ss[36:43] + ss[72:79]
            norm = numpy.sum(a)
            b = a * costas_array
            c = numpy.sum(b)
            c = c / norm

            if contrast_weight > 0:
                contrast = self.contrast(ss)
                contrast *= contrast_weight
                c += contrast

            corrs.append([hz, c])

        corrs = sorted(corrs, key = lambda e : - e[1])
        return corrs[0]

    # find offset with best Costas sync at hz.
    # looks at offsets at start +/- slop,
    # at granule offset increments.
    # returns [ [ start, strength ], ... ]
    def best_offsets(self, xf, hz, off0, off1, step):
        rank = [ ]
        for xoff in numpy.arange(off0, off1+0.0001, step):
            off = int(xoff)
            if off + 79 * self.jblock > xf.len():
                continue
            [ _, _, m79 ] = xf.get(hz, off)
            if len(m79) < 79:
                continue

            m79 = m79[0:79]
            # m79 has 79 8-bucket mini-FFTs.

            c = self.strength(m79)

            rank.append([off, c])

        rank = sorted(rank, key = lambda e : - e[1])
        return rank

    def old_best_offsets(self, xf, hz, start, slop, granule, find_cq):
        start = int(start)
        slop = int(slop)
        granule = int(granule)

        # a Costas sync array.
        costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
        costas_array = numpy.ones((7, 8)) * (-1 / 7.0)
        for i in range(0, len(costas_symbols)):
            costas_array[i][costas_symbols[i]] = 1

        # use CQ as a sync array.
        cq_symbols = [ 7, 6, 4, 0, 4, 0, 6, 1, 4 ]
        cq_array = numpy.ones((9, 8)) * (-1 / 7.0)
        for i in range(0, len(cq_symbols)):
            cq_array[i][cq_symbols[i]] = 1

        off0 = start - slop
        off1 = start + slop
        corrs = [ ]
        for off in range(off0, off1+4, granule):
            if off + 79 * self.jblock > xf.len():
                continue
            [ _, _, m79 ] = xf.get(hz, off)
            if len(m79) < 79:
                continue
            m79 = m79[0:79]
            # m79 has 79 8-bucket mini-FFTs.

            a = m79[0:7] + m79[36:43] + m79[72:79]
            norm = numpy.sum(a)
            b = a * costas_array
            c = numpy.sum(b)
            c = c / norm # we care about strength of correlation, not sig ampl

            if find_cq:
                # assume it's a CQ, and add in correlation with
                # the 28 bits at bit 87 (9 symbols at symbol 29).
                # in real life about 1/4 of messages are CQs.
                # CQ's 28 bits: 1111101000001000001100011001
                # turns out to be not worth the extra CPU.
                a = m79[43:43+9]
                norm = numpy.sum(a)
                b = a * cq_array
                bsum = numpy.sum(b)
                c += bsum / norm

            if contrast_weight > 0:
                contrast = self.contrast(m79)
                contrast *= contrast_weight
                c += contrast

            corrs.append([off, c])

        corrs = sorted(corrs, key = lambda e : - e[1])
        return corrs

    def coarse1(self, xf, adjusted_start, hzoff, offoff, min_hz, max_hz):
        # prepare a template for 2d correlation containing
        # the three Costas arrays.
        costas = [ 2, 5, 6, 0, 4, 1, 3 ]
        template = numpy.zeros((79, 8))
        for i0 in [ 0, 36, 72 ]:
            for i1 in range(0, 7):
                template[i0+i1,:] = -1 / 7.0
                template[i0+i1,costas[i1]] = 1

        # m[symbol][bin]
        [ hz0, offset0, m ] = xf.getall(hzoff, offoff)

        bin_hz = self.jrate / float(self.jblock)
        min_hz_bin = bin_of(min_hz - hz0)
        max_hz_bin = bin_of(max_hz - hz0)

        min_sym = int((adjusted_start - self.jrate*coarse_tminus) / self.jblock)
        max_sym = int((adjusted_start + self.jrate*coarse_tplus) / self.jblock)

        m = m[min_sym:79+max_sym,min_hz_bin:max_hz_bin]

        if True:
            mlen = len(m)
            tlen = len(template)
            minussyms = int(round((self.jrate * coarse_tminus) / float(self.jblock)))
            plussyms = int(round((self.jrate * coarse_tplus) / float(self.jblock)))
            slopsyms = minussyms + plussyms
            m = numpy.concatenate([ m[0:7+slopsyms],
                                    m[36:43+slopsyms],
                                    m[72:79+slopsyms] ])
            template = numpy.concatenate( [ template[0:7+slopsyms],
                                            template[36:43+slopsyms],
                                            template[72:79] ] )

        # for each frequency bin, the total signal level for
        # it and the next eight bins up. we'll divide by this
        # in order to emphasize the correlation, not the
        # signal (or noise) level.
        binsum = numpy.sum(m, axis=0)
        norm = numpy.zeros(len(binsum))
        for i in range(0, 8):
            norm[0:len(norm)-i] += binsum[i:]

        c = scipy.signal.correlate2d(m, template, mode='valid')

        if False:
            h = [ [ (bi+min_hz_bin) * bin_hz + hz0,
                    (si+min_sym) * self.jblock + offoff,
                    c[si,bi] / norm[bi]
                  ]
                  for si in range(0, c.shape[0]) for bi in range(0, c.shape[1]) ]
        else:
            # best few starting symbol indices for each frequency bin.
            # so we only return a few elements per bin, not
            # one element per bin per starting symbol index.
            max_si = numpy.argsort(-c, axis=0)
            h = [ ]
            for mi in range(0, coarse_no):
                h += [ [ (bi+min_hz_bin) * bin_hz + hz0,
                        (max_si[mi][bi]+min_sym) * self.jblock + offoff,
                        c[max_si[mi][bi],bi] / norm[bi]
                      ]
                      for bi in range(0, max_si.shape[1]) ]

        return h

    def coarse(self, xf, adjusted_start, min_hz, max_hz):
        bin_hz = self.jrate / float(self.jblock)

        h = [ ]
        for hzoff in numpy.arange(0.0, bin_hz, bin_hz / coarse_fstep):
            for offoff in range(0, self.jblock, int(self.jblock / coarse_tstep)):
                hx = self.coarse1(xf, adjusted_start, hzoff, offoff, min_hz, max_hz)
                h += hx

        h = sorted(h, key = lambda e : -e[2])

        return h

    # m79 is 79 8-bucket mini FFTs, for 8-FSK demodulation.
    # m79[0..79][0..8]
    def snr(self, m79):
        # estimate SNR.
        # mimics wsjt-x code, though the results are not very close.
        sigi = numpy.argmax(m79, axis=1)
        noisei = numpy.mod(sigi + 4, 8)
        noises = m79[range(0, 79), noisei]
        noise = numpy.mean(noises * noises) # square yields power
        #if noise == 0.0:
        #    # !!!
        #    return 0
        sigs = numpy.amax(m79, axis=1) # guess correct tone
        sig = numpy.mean(sigs * sigs)
        rawsnr = sig / noise
        rawsnr -= 1 # turn (s+n)/n into s/n
        if rawsnr < 0.1:
            rawsnr = 0.1
        rawsnr /= (2500.0 / 2.7) # 2.7 hz noise b/w -> 2500 hz b/w
        snr = 10 * math.log10(rawsnr)
        snr += 3
        return snr

    ci3 = numpy.array([ 2, 5, 6, 0, 4, 1, 3,
                        2, 5, 6, 0, 4, 1, 3,
                        2, 5, 6, 0, 4, 1, 3 ], dtype=numpy.int32)

    # mean and std dev of winning and non-winning
    # FFT bins, to help compute probabilities of
    # symbol values for soft decoding.
    # m79 is 79 8-bucket mini FFTs, for 8-FSK demodulation.
    # m79[0..79][0..8]
    # returns None or a Decode.
    # return [ winmean, winstd, losemean, losestd ],
    # for use in LDPC decoder.
    def softstats(self, m79, i0=0, i1=79):

        if True:
            # this works best, 596 (574 of 675)
            winners = numpy.max(m79[i0:i1], 1)
            losers = m79[i0:i1]

        if False:
            # 595 (575 of 675)
            # just look at Costas arrays, where we know
            # which symbols are correct.
            cs = numpy.concatenate( [ m79[0:0+7], m79[36:36+7], m79[72:72+7] ] )
            winners = cs[range(0,21),self.ci3]
            losers = m79

        if False:
            # this works pretty well, old 575 (555 of 675).
            # just look at Costas arrays, where we know
            # which symbols are correct.
            winners = numpy.zeros(3*7)
            losers = numpy.zeros(3*7*7)
            costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
            wi = 0
            li = 0
            for i0 in [ 0, 36, 72 ]:
                for i1 in range(0, 7):
                    cs = costas_symbols[i1]
                    winners[wi] = m79[i0+i1][cs]
                    wi += 1
                    losers[li:li+cs] = m79[i0+i1][0:cs]
                    losers[li+cs:li+7] = m79[i0+i1][cs+1:]
                    li += 7

        if False:
            # this works pretty well, old 578 (558 of 675)
            n = len(m79)
            winners = numpy.zeros(n)
            losers = numpy.zeros(n * 7)
            for mi in range(0, n):
                e = m79[mi]
                wini = numpy.argmax(e) # guess the winning tone.
                winners[mi] = e[wini]
                li = mi * 7
                losers[li:li+wini] = e[0:wini]
                losers[li+wini:li+7] = e[wini+1:]

        if False:
            # this is ok, 573 (555 of 675)
            # look at all symbols.
            # we know the correct Costas values.
            # guess the others based on strength.
            winners = [ ]
            losers = [ ]
            costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
            for i in range(i0, i1):
                e = m79[i]
                good = False
                loudest = numpy.argmax(e)
                if (i >= 0 and i < 7) or (i >= 36 and i < 36+7) or (i >= 72 and i < 72+7):
                    # in a costas block, so we know the correct symbol.
                    if i >= 72:
                        ci = i - 72
                    elif i >= 36:
                        ci = i - 36
                    else:
                        ci = i
                    wini = costas_symbols[ci]
                    good = (wini == loudest)
                else:
                    # we don't know correct symbol; use loudest.
                    wini = loudest
                winners.append(e[wini])
                if good:
                    # higher weight.
                    winners.append(e[wini])

                losers += list(e[0:wini])
                losers += list(e[wini+1:])

        if False:
            import matplotlib.pyplot as plt
            plt.plot(winners)
            plt.plot(losers[::7])
            plt.show()

        winmean = numpy.mean(winners)
        winstd = numpy.std(winners)
        losemean = numpy.mean(losers)
        losestd = numpy.std(losers)

        return [ winmean, winstd, losemean, losestd ]

    # try to guess Hz error from phase errors.
    # mm is 79 complex 8-bin mini-FFTs.
    # if hz were exactly centered in an FFT bin, the
    # phase of each tone would be the same for all
    # occurences (but different tones usually have
    # different phases due to offset in time).
    # the signal probably isn't exactly centered in frequency
    # in an FFT bin. this induces a drift in the FFT phase.
    # guess that drift, in radians per symbol time, -pi..pi.
    # returns [ radians, hz ]
    def phase_drift(self, mm):
        last_theta = numpy.zeros(8)
        last_i = numpy.zeros(8, dtype=numpy.int32) - 1
        nbuckets = 2*phase_gran # +/- pi/100
        buckets = numpy.zeros(nbuckets, dtype=numpy.int32)
        costas = [ 2, 5, 6, 0, 4, 1, 3 ]

        gran = 1
        if coarse_fstep > 1:
            gran *= coarse_fstep
        if fine_fstep > 1:
            gran *= fine_fstep
        max_phase_drift_per_symbol = 2 * math.pi / gran

        for i in range(0, len(mm)):
            if i < 7 or (i >= 36 and i < 42) or (i >= 72):
                # a costas symbol
                maxi = costas[i % 36]
            else:
                maxi = numpy.argmax(abs(mm[i,:])) # number of strongest of 8-FSK tones
            x = mm[i,maxi]
            theta = math.atan2(x.imag, x.real)
            if last_i[maxi] >= 0:
                # the difference in phase between successive instances
                # of the same tone includes some number of complete 2*pi
                # cycles. but because hz can't be more than a fraction of
                # an FFT bin off, there's a limit to the number of 
                # complete cycles.
                maxwrap = (i - last_i[maxi]) * max_phase_drift_per_symbol
                for wrap in numpy.arange(0, maxwrap+0.001, 2*math.pi):
                    slope = (theta - last_theta[maxi] + wrap) / (i - last_i[maxi])
                    while slope >= math.pi:
                        slope -= 2*math.pi
                    while slope <= -math.pi:
                        slope += 2*math.pi
                    assert slope >= -math.pi and slope < math.pi
                    bi = int((slope/math.pi)*phase_gran) + phase_gran
                    assert bi >= 0 and bi < len(buckets)
                    buckets[bi] += 1
            last_i[maxi] = i
            last_theta[maxi] = theta

        maxb = numpy.argmax(buckets)

        # estimated phase drift, i.e. change in phase, radians per symbol time.
        radians = ((maxb - phase_gran) / float(phase_gran)) * math.pi

        # estimated frequency error in Hz.
        hz = (radians * (self.jrate / self.jblock)) / (2 * math.pi)

        return [ radians, hz ]

    # returns 174 log-likelihood values for whether each
    # bit is a zero.
    def loglikelihood(self, m58, winmean, winstd, losemean, losestd):

        # 576 (556 of 675)
        # Bayes combining rule from:
        # http://cs.wellesley.edu/~anderson/writing/naive-bayes.pdf

        wm = winmean
        ws = winstd
        lm = losemean
        ls = losestd

        n = len(m58)
        ll174 = numpy.zeros(3 * n)

        bi = 0
        for [ v0, v1 ] in [
                # symbol numbers that make this bit zero and one.
                # most-significant bit first.
                [ [ 0, 1, 2, 3 ], [ 4, 5, 6, 7 ] ],
                [ [ 0, 1, 4, 5 ], [ 2, 3, 6, 7 ] ],
                [ [ 0, 2, 4, 6 ], [ 1, 3, 5, 7 ] ],
                ]:
            # treat each of the three bits in a symbol separately.

            e0 = numpy.maximum(
                   numpy.maximum(m58[range(0,n),v0[0]], m58[range(0,n),v0[1]]),
                   numpy.maximum(m58[range(0,n),v0[2]], m58[range(0,n),v0[3]]))
            e1 = numpy.maximum(
                   numpy.maximum(m58[range(0,n),v1[0]], m58[range(0,n),v1[1]]),
                   numpy.maximum(m58[range(0,n),v1[2]], m58[range(0,n),v1[3]]))

            # start with measured a-priori bit probabilities.
            pone = apriori174[bi::3]
            pzero = 1.0 - pone

            # P(zero)P(e0|zero)P(e1|zero)
            a = pzero * vproblt(e0, wm, ws) * vprobgt(e1, lm, ls)

            # P(one)P(e0|one)P(e1|one)
            b = pone * vprobgt(e0, lm, ls) * vproblt(e1, wm, ws)

            ab = a + b
            p0 = numpy.divide(a, ab, out=numpy.repeat(0.5, len(a)), where=ab!=0)

            # log likelihood of t0 being the correct symbol.
            # ll0 = log(p0 / (1 - p0))
            # log(148) = 4.99
            dd = numpy.divide(p0, (1.0 - p0), out=numpy.repeat(148.0, len(p0)), where=p0<0.99)
            ll = numpy.log(dd, out=numpy.repeat(-5.0, len(dd)), where=dd>0)

            ll = numpy.maximum(ll, -5.0)
            ll = numpy.minimum(ll, 5.0)

            ll174[bi::3] = ll
            bi += 1


        return ll174

    # demodulate using phase as well as amplitude.
    # returns a 79x8 vector with scalars, indicating
    # how close each tone is to what we received.
    # values can be negative.
    # direction is 1 or -1.
    # syms is just for debugging (it's the 79 correct tone numbers).
    # sadly, I have not been able to make this beat abs().
    # I think the problem is that, with eight tones, there's a good
    # chance that a wrong tone randomly has a good-looking phase.
    # plus, if the amplitudes are weak, phase_drift() won't work well.
    def phase_demodulate(self, m79complex):
        out = numpy.zeros((79, 8))

        # pd[0] is phase drift in radians per symbol time.
        # pd[1] is frequency error in hz, i.e. distance from FFT bin center.
        pd = self.phase_drift(m79complex)
        estimated_drift = pd[0]

        costas = [ 2, 5, 6, 0, 4, 1, 3 ]

        # each tone generally has a different characteristic phase
        # if the offset is wrong (which it generally is).
        # predict phase from nearest Costas tone.
        # guesses[symbol_number][tone] is the phase prediction.
        guesses = numpy.zeros((79,8))
        for ci in range(0, len(costas)):
            tone = costas[ci]
            for [ cj, i0, i1 ] in [ [ 0, 0, 25 ], [ 36, 25, 52 ], [ 72, 52, 79 ] ]:
                refi = cj + ci
                x = m79complex[refi][tone]
                theta = math.atan2(x.imag, x.real)
                for k in range(i0, i1):
                    guesses[k,tone] = theta + estimated_drift*(k-refi)

        for i in range(0, len(m79complex)):
            meda = numpy.median(abs(m79complex[i]))
            a = abs(m79complex[i])
            strength = numpy.copy(a)
            s7 = strength[7] # set up to treat tone 7 specially, since no expected phase.
            expected_phase = guesses[i]
            n = numpy.cos(expected_phase) + 1j*numpy.sin(expected_phase)
            v = m79complex[i] / a
            dot = (n.imag*v.imag) + (n.real*v.real) # dot product, -1..1
            # XXX is this the best way to combine ampl with phase?
            best = numpy.argmax(dot)
            if a[best] > meda:
                strength[best] += dot[best] * a[best] # (a[best] - meda)
            out[i] = strength
            out[i][7] = s7

        return out

    # m79 is 79 8-bucket mini FFTs, for 8-FSK demodulation.
    # m79 holds complex FFT results (with phase).
    # m79[0..79][0..8]
    # returns None or a Decode.
    # offset is just for dec and debugging.
    def process2(self, m79complex, hz, offset):
        if len(m79complex) < 79:
            return

        if False:
            # this actually works!
            # the point is that it's cheap,
            # and might give me a way to shift
            # frequency to center the signal
            # exactly in the FFT bins.
            for i in range(0, len(m79complex)):
                aaa = m79complex[i]
                bbb = numpy.fft.ifft(aaa)
                ccc = numpy.fft.fft(bbb)
                m79complex[i] = ccc

        # phase drift in radians per symbol time.
        #pd = self.phase_drift(m79complex)

        # estimated frequency error in Hz.
        # fixing hz may make subsequent subtraction better.
        # (though doesn't seem to in practice)
        # hz is usually within 0.02 Hz of correct after this
        # correction (down from 0.2 typically).
        #hz += pd[1]

        snr = self.snr(abs(m79complex))

        m79 = abs(m79complex)
        #m79 = self.phase_demodulate(m79complex)

        if True:
            # convert to S/N. this seems to help;
            # perhaps it makes successive symbols more comparable so
            # that softstats() works better.
            maxm = numpy.max(m79, 1)
            mm = numpy.median(m79, 1)
            amm = numpy.zeros(79)
            amm += mm
            amm[0:-1] += mm[1:]
            amm[1:] += mm[0:-1]
            amm[1:-1] /= 3.0
            amm[0] /= 2.0
            amm[-1] /= 2.0
            mm = amm
            mm = numpy.select( [ mm > maxm/1000 ], [ mm ], default=maxm/1000)
            # mm = numpy.select( [ mm != 0.0 ], [ mm ], default=1.0 ) # ??? how can m[i] be zero?
            sm = numpy.stack([mm,mm,mm,mm,mm,mm,mm,mm], 1)
            m79 = numpy.divide(m79, sm)

        [ winmean, winstd, losemean, losestd ] = self.softstats(m79)

        if winmean < 0.000001:
            # this happens when we look again at a signal that
            # has been subtracted by zeroing FFTCache bins.
            return None

        # drop the three 7-symbol Costas arrays.
        m58 = numpy.concatenate( [ m79[7:36], m79[43:72] ] )

        ll174 = self.loglikelihood(m58, winmean, winstd, losemean, losestd)

        # decode LDPC(174,87)
        [ ldpc_ok, a87 ] = ldpc_decode(ll174)

        if (len(a87) == 0 or ldpc_ok < 87):
            # force a CQ in and try again.
            llx = numpy.copy(ll174)
            cq = "1111101000001000001100011001"
            for i in range(0, len(cq)):
                if cq[i] == '0':
                    llx[87+i] = 4.99
                else:
                    llx[87+i] = -4.99
            [ ok1, a1 ] = ldpc_decode(llx)
            if ok1 == 87:
                ldpc_ok = ok1
                a87 = a1
        if self.restrict_hz != None and (len(a87) == 0 or ldpc_ok < 87):
            # restrict_hz means we're looking for QSO replies.
            # force an AB1HL in and try again.
            llx = numpy.copy(ll174)
            ab1hl = "0100010110101010001111001111"
            for i in range(0, len(ab1hl)):
                if ab1hl[i] == '0':
                    llx[87+i] = 4.99
                else:
                    llx[87+i] = -4.99
            [ ok1, a1 ] = ldpc_decode(llx)
            if ok1 == 87:
                ldpc_ok = ok1
                a87 = a1

        if osd_order >= 0 and (len(a87) == 0 or ldpc_ok < 87):
            d87 = osd_decode(ll174, osd_order)
            if len(d87) > 0:
                ldpc_ok = 87 # 86 limits to CQ and AB1HL, 87 allows some garbage
                a87 = d87

        if len(a87) == 0:
            # failure.
            return None

        if ldpc_ok < 50:
            # reject decodes with lots of LDPC parity check failures.
            # this does reject some messages that pass the CRC and
            # are correct, but also weeds out vast amounts of garbage.
            return None

        if check_crc(a87) == False:
            # CRC failed.
            return None

        # a87 is 75 bits of msg and 12 bits of CRC.
        # turn the first 72 bits into twelve 6-bit numbers,
        # for compatibility with FT8 unpack().
        # MSB.
        a72 = a87[0:72]
        twelve = [ ]
        for i in range(0, 72, 6):
            a = a72[i:i+6]
            x = (a[0] * 32 +
                 a[1] * 16 +
                 a[2] *  8 +
                 a[3] *  4 +
                 a[4] *  2 +
                 a[5] *  1)
            twelve.append(x)

        msg = self.unpack(twelve)

        if "000AAA" in msg:
            return None

        if ldpc_ok < 87:
            # some of the LDPC parity checks failed.
            # the CRC sometimes succeeds even for garbage.
            # so filter out syntactically broken decodes.
            # only accept CQ ... and AB1HL ...
            m1 = re.match(r'^ *CQ[ D].* [A-R][A-R][0-9][0-9] *$', msg)
            m2 = re.match(r'^ *AB1HL ', msg)
            if m1 == None and m2 == None:
                return None

        if False and ldpc_ok == 87:
            # remember codeword bits in order to figure out
            # a-priori bit value probabilities.
            # python bprob.py < ft8bits

            # re-encode
            n87 = numpy.copy(a87)
            cksum = crc(numpy.append(n87[0:72], numpy.zeros(4, dtype=numpy.int32)),
                        crc12poly)
            n87[-12:] = cksum
            n174 = ldpc_encode(n87)

            if False:
                for i in range(0, 10):
                    sys.stdout.write("%4.1f " % (ll174[i]))
                sys.stdout.write("\n")
                for i in range(0, 10):
                    sys.stdout.write("%4.1f " % (n174[i]))
                sys.stdout.write("\n")

            f = open("ft8bits", "a")
            for i in range(0, 174):
                f.write("%d" % (n174[i]))
            f.write("\n")
            f.close()

        dec = Decode([hz,hz], msg, snr, twelve, time.time())
        dec.errs = 87 - ldpc_ok
        dec.start = offset
        return dec

    # convert packed character to Python string.
    # 0..9 a..z space
    def charn(self, c):
        if c >= 0 and c <= 9:
            return chr(ord('0') + c)
        if c >= 10 and c < 36:
            return chr(ord('A') + c - 10)
        if c == 36:
            return ' '
        # sys.stderr.write("jt65 charn(%d) bad\n" % (c))
        return '?'

    # x is an integer, e.g. nc1 or nc2, containing all the
    # call sign bits from a packed message.
    # 28 bits.
    def unpackcall(self, x):
        a = [ 0, 0, 0, 0, 0, 0 ]
        a[5] = self.charn((x % 27) + 10) # + 10 b/c only alpha+space
        x = int(x / 27)
        a[4] = self.charn((x % 27) + 10)
        x = int(x / 27)
        a[3] = self.charn((x % 27) + 10)
        x = int(x / 27)
        a[2] = self.charn(x%10) # digit only
        x = int(x / 10)
        a[1] = self.charn(x % 36) # letter or digit
        x = int(x / 36)
        a[0] = self.charn(x)
        return ''.join(a)

    # extract maidenhead locator
    def unpackgrid(self, ng):
        if ng == NGBASE+1:
            return "    "
        if ng >= NGBASE+1 and ng < NGBASE+31:
            return " -%02d" % (ng - (NGBASE+1)) # sig str, -01 to -30 DB
        if ng >= NGBASE+31 and ng < NGBASE+62:
            return "R-%02d" % (ng - (NGBASE+31))
        if ng == NGBASE+62:
            return "RO  "
        if ng == NGBASE+63:
            return "RRR "
        if ng == NGBASE+64:
            return "73  "

        lat = (ng % 180) - 90
        ng = int(ng / 180)
        lng = (ng * 2) - 180

        g = "%c%c%c%c" % (ord('A') + int((179-lng)/20),
                          ord('A') + int((lat+90)/10),
                          ord('0') + int(((179-lng)%20)/2),
                          ord('0') + (lat+90)%10)

        if g[0:2] == "KA":
            # really + signal strength
            sig = int(g[2:4]) - 50
            return "+%02d" % (sig)

        if g[0:2] == "LA":
            # really R+ signal strength
            sig = int(g[2:4]) - 50
            return "R+%02d" % (sig)

        return g

    def unpack(self, a):
        # a[] has 12 0..63 symbols, or 72 bits.
        # turn them into the original human-readable message.
        # unpack([61, 37, 30, 28, 9, 27, 61, 58, 26, 3, 49, 16]) -> "G3LTF DL9KR JO40"
        nc1 = 0 # 28 bits of first call
        nc1 |= a[4] >> 2 # 4 bits
        nc1 |= a[3] << 4 # 6 bits
        nc1 |= a[2] << 10 # 6 bits
        nc1 |= a[1] << 16 # 6 bits
        nc1 |= a[0] << 22 # 6 bits

        nc2 = 0 # 28 bits of second call
        nc2 |= (a[4] & 3) << 26 # 2 bits
        nc2 |= a[5] << 20 # 6 bits
        nc2 |= a[6] << 14 # 6 bits
        nc2 |= a[7] << 8 # 6 bits
        nc2 |= a[8] << 2 # 6 bits
        nc2 |= a[9] >> 4 # 2 bits

        ng = 0 # 16 bits of grid
        ng |= (a[9] & 15) << 12 # 4 bits
        ng |= a[10] << 6 # 6 bits
        ng |= a[11]

        if ng >= 32768:
            txt = self.unpacktext(nc1, nc2, ng)
            return txt

        if nc1 == NBASE+1:
            c2 = self.unpackcall(nc2)
            grid = self.unpackgrid(ng)
            return "CQ %s %s" % (c2, grid)

        if nc1 >= 267649090 and nc1 <= 267698374:
            # CQ with suffix (e.g. /QRP)
            n = nc1 - 267649090
            sf = self.charn(n % 37)
            n /= 37
            sf = self.charn(n % 37) + sf
            n /= 37
            sf = self.charn(n % 37) + sf
            n /= 37
            c2 = self.unpackcall(nc2)
            grid = self.unpackgrid(ng)
            return "CQ %s/%s %s" % (c2, sf, grid)

        c1 = self.unpackcall(nc1)
        if c1 == "CQ9DX ":
            c1 = "CQ DX "
        m = re.match(r'^ *E9([A-Z][A-Z]) *$', c1)
        if m != None:
            c1 = "CQ " + m.group(1)
        c2 = self.unpackcall(nc2)
        grid = self.unpackgrid(ng)
        return "%s %s %s" % (c1, c2, grid)

    def unpacktext(self, nc1, nc2, nc3):
        c = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?"

        nc3 &= 32767
        if (nc1 & 1) != 0:
            nc3 += 32768
        nc1 >>= 1
        if (nc2 & 1) != 0:
            nc3 += 65536
        nc2 >>= 1

        msg = [""] * 22

        for i in range(4, -1, -1):
            j = nc1 % 42
            msg[i] = c[j]
            nc1 = nc1 // 42

        for i in range(9, 4, -1):
            j = nc2 % 42
            msg[i] = c[j]
            nc2 = nc2 // 42

        for i in range(12, 9, -1):
            j = nc3 % 42
            msg[i] = c[j]
            nc3 = nc3 // 42

        return ''.join(msg)

very_first_time = True
profiling = False

class FT8Send:
    def __init__(self):
        pass

    # convert a character into a number; order is
    # 0..9 A..Z space
    def nchar(self, ch):
        if ch >= '0' and ch <= '9':
            return ord(ch) - ord('0')
        if ch >= 'A' and ch <= 'Z':
            return ord(ch) - ord('A') + 10
        if ch == ' ':
            return 36
        print("NT65Send.nchar(%s) oops" % (ch))
        return 0

    # returns a 28-bit number.
    # we need call to be:
    #   lds lds d ls ls ls
    # l-etter, d-igit, s-pace
    # 28-bit number's high bits correspond to first call sign character.
    def packcall(self, call):
        call = call.strip()
        call = call.upper()

        if call == "CQ":
            return NBASE + 1
        if call == "QRZ":
            return NBASE + 2
        if call == "DE":
            return 267796945

        if len(call) > 2 and len(call) < 6 and not call[2].isdigit():
            call = " " + call
        while len(call) < 6:
            call = call + " "

        if re.search(r'^[A-Z0-9 ][A-Z0-9 ][0-9][A-Z ][A-Z ][A-Z ]$', call) == None:
            return -1

        x = 0
        x += self.nchar(call[0])

        x *= 36
        x += self.nchar(call[1])

        x *= 10
        x += self.nchar(call[2])

        x *= 27
        x += self.nchar(call[3]) - 10

        x *= 27
        x += self.nchar(call[4]) - 10

        x *= 27
        x += self.nchar(call[5]) - 10

        return x

    # returns 16-bit number.
    # g is maidenhead grid, or signal strength, or 73.
    def packgrid(self, g):
        g = g.strip()
        g = g.upper()

        if g[0] == '-':
            snr = int(g[1:])
            if snr == 0:
                snr = 1
            if snr > 29:
                snr = 29
            return NGBASE + 1 + snr
        if g[0:2] == 'R-':
            snr = int(g[2:])
            if snr == 0:
                snr = 1
            if snr > 29:
                snr = 29
            return NGBASE + 31 + snr
        if g == "RO":
            return NGBASE + 62
        if g == "RRR":
            return NGBASE + 63
        if g == "73":
            return NGBASE+64

        if re.match(r'^[A-R][A-R][0-9][0-9]$', g) == None:
            return -1

        lng = (ord(g[0]) - ord('A')) * 20
        lng += (ord(g[2]) - ord('0')) * 2
        lng = 179 - lng

        lat = (ord(g[1]) - ord('A')) * 10
        lat += (ord(g[3]) - ord('0')) * 1
        lat -= 90

        x = (lng + 180) / 2
        x *= 180
        x += lat + 90

        return x

    # turn three numbers into 12 6-bit symbols.
    def pack3(self, nc1, nc2, g):
        a = [0] * 12
        a[0] = (nc1 >> 22) & 0x3f
        a[1] = (nc1 >> 16) & 0x3f
        a[2] = (nc1 >> 10) & 0x3f
        a[3] = (nc1 >> 4) & 0x3f
        a[4] = ((nc1 & 0xf) << 2) | ((nc2 >> 26) & 0x3)
        a[5] = (nc2 >> 20) & 0x3f
        a[6] = (nc2 >> 14) & 0x3f
        a[7] = (nc2 >> 8) & 0x3f
        a[8] = (nc2 >> 2) & 0x3f
        a[9] = ((nc2 & 0x3) << 4) | ((g >> 12) & 0xf)
        a[10] = (g >> 6) & 0x3f
        a[11] = (g >> 0) & 0x3f
        return a

    def pack(self, msg):
        msg = msg.strip()
        msg = re.sub(r'  *', ' ', msg)
        msg = re.sub(r'^CQ DX ', 'CQ9DX ', msg)

        # try CALL CALL GRID
        a = msg.split(' ')
        if len(a) == 3:
            nc1 = self.packcall(a[0])
            nc2 = self.packcall(a[1])
            g = self.packgrid(a[2])
            if nc1 >= 0 and nc2 >= 0 and g >= 0:
                return self.pack3(nc1, nc2, g)

        # never finished this -- no text &c.
        sys.stderr.write("FT8Send.pack(%s) -- cannot parse\n" % (msg))
        # sys.exit(1)
        return [0] * 12

    def testpack(self):
        r = FT8()
        for g in [ "FN42", "-22", "R-01", "RO", "RRR", "73", "AA00", "RR99" ]:
            pg = self.packgrid(g)
            upg = r.unpackgrid(pg)
            if g != upg.strip():
                print("packgrid oops %s" % (g))
        for call in [ "AB1HL", "K1JT", "M0TRJ", "KK4BMV", "2E0CIN", "HF9D",
                      "6Y4K", "D4Z", "8P6DR", "ZS2I", "3D2RJ",
                      "WB3D", "S59GCD", "T77C", "4Z5AD", "A45XR", "OJ0V",
                      "6Y6N", "S57V", "3Z0R" ]:
            # XXX 3XY1T doesn't work
            pc = self.packcall(call)
            upc = r.unpackcall(pc)
            if call != upc.strip():
                print("packcall oops %s %d %s" % (call, pc, upc))
        for msg in [ "AB1HL K1JT FN42", "CQ DX CO3HMR EL82", "KD6HWI PY7VI R-12",
                     "KD5RBW TU 73", "CQ N5OSK EM25", "PD9BG KG7EZ RRR",
                     "W1JET KE0HQZ 73", "WB3D OM4SX -16", "WA3ETR IZ2QGB RR73",
                     "BG THX JOE 73"]:
            pm = self.pack(msg)
            upm = r.unpack(pm)
            upm = re.sub(r'  *', ' ', upm)
            if msg != upm.strip():
                print("pack oops %s %s %s" % (msg, pm, upm))

    # twelve[] is 12 6-bit symbols, the result of pack().
    # returns an array of 79 symbols 0..8, ready for FSK.
    def make_symbols(self, twelve):
        # turn the 72 bits in twelve into an array of bits,
        # most significant bit first.
        # three zero bits at the end, for 75.
        # and room for 12 CRC bits.
        a87 = numpy.zeros(87, dtype=numpy.int32)
        i = 0
        for x in twelve:
            a87[i + 0] = (x >> 5) & 1
            a87[i + 1] = (x >> 4) & 1
            a87[i + 2] = (x >> 3) & 1
            a87[i + 3] = (x >> 2) & 1
            a87[i + 4] = (x >> 1) & 1
            a87[i + 5] = (x >> 0) & 1
            i += 6

        # CRC12
        cksum = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
                    crc12poly)
        a87[-12:] = cksum

        # LDPC(174,87)
        a174 = ldpc_encode(a87)

        # turn array of 174 bits into 58 3-bit symbols,
        # most significant bit first.
        dsymbols = numpy.zeros(58, dtype=numpy.int32)
        for i in range(0, 58):
            ii = i * 3
            dsymbols[i] = (a174[ii+0] << 2) | (a174[ii+1]<<1) | (a174[ii+2]<<0)

        # insert three 7-symbol Costas arrays.
        costas = numpy.array([ 2, 5, 6, 0, 4, 1, 3 ], dtype=numpy.int32)
        symbols = numpy.zeros(79, dtype=numpy.int32)
        symbols[0:7] = costas
        symbols[7:36] = dsymbols[0:29]
        symbols[36:43] = costas
        symbols[43:72] = dsymbols[29:]
        symbols[72:] = costas

        return symbols

    # twelve[] is 12 6-bit symbols, the result of pack().
    # tone is Hz of lowest tone.
    # returns an array of audio samples.
    def send12(self, twelve, tone, rate):
        symbols = self.make_symbols(twelve)

        samples_per_symbol = int(round(rate * (1920 / 12000.0)))
        samples = weakutil.fsk(symbols, [tone, tone], 6.25, rate, samples_per_symbol)

        return samples

    def testsend(self):
        random.seed(0)
        rate = 12000

        # G3LTF DL9KR JO40)
        x1 = self.send12([61, 37, 30, 28, 9, 27, 61, 58, 26, 3, 49, 16], 1000, rate)
        x1 = numpy.concatenate(([0]*1,  x1, [0]*(8192-1) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x1 = x1 * rv

        # RA3Y VE3NLS 73
        x2 = self.send12([46, 6, 32, 22, 55, 20, 11, 32, 53, 23, 59, 16], 1050, rate)
        x2 = numpy.concatenate(([0]*4096,  x2, [0]*(8192-4096) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x2 = x2 * rv

        # CQ DL7ACA JO40
        x3 = self.send12([62, 32, 32, 49, 37, 27, 59, 2, 30, 19, 49, 16], 1100, rate)
        x3 = numpy.concatenate(([0]*5120,  x3, [0]*(8192-5120) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x3 = x3 * rv

        # VA3UG   F1HMR 73
        x4 = self.send12([52, 54, 60, 12, 55, 54, 7, 19, 2, 23, 59, 16], 1150, rate)
        x4 = numpy.concatenate(([0]*1,  x4, [0]*(8192-1) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x4 = x4 * rv

        x = 3*x1 + 2*x2 + 1.0*x3 + 0.5*x4

        x += numpy.random.rand(len(x)) * 1.0
        x *= 1000.0

        x = numpy.append([0]*(rate // 2), x)
        x = numpy.append(x, [0]*rate)

        r = FT8()
        r.cardrate = rate
        r.process(x, 0)

if False and __name__ == '__main__':
    r = FT8()
    syms = numpy.array([ [ 500, 1000, 1500, 1450, 700, 100, 300, 1000 ] ], dtype=numpy.float64)
    wm = 1000.0
    ws = 100.0
    lm = 1500.0
    ls = 300.0
    x = r.loglikelihood(syms, wm, ws, lm, ls)
    print(x)
    sys.exit(0)

if False:
    s = FT8Send()
    r = FT8()
    plain = [ ]
    for i in range(0, 87):
        plain.append(random.randint(0, 1))

    cw = ldpc_encode(plain)

    # turn hard bits into 0.99 vs 0.01 log-likelihood,
    # log( P(0) / P(1) )
    # log base e.
    two = numpy.array([ 4.6, -4.6 ])
    ll174 = two[cw]

    d = ldpc_decode(ll174)

    assert numpy.array_equal(d, plain)

    sys.exit(1)

if False:
    s = FT8Send()
    s.testsend()
    sys.exit(1)

if False:
    s = FT8Send()
    s.testpack()
    sys.exit(1)

if False:
    # test decoding sequence on known correct symbols,
    # from wsjt-x's ft8sim.
    # should yield K1ABC W9XYZ EN37
    r = FT8()

    # 79 3-bit 8-FSK symbols, including the Costas arrays.
    a79 = "2560413335544231617326364127543164332560413756060434371356756660051002662560413"
    b79 = [ int(x) for x in a79 ]
    assert len(b79) == 79

    # get rid of the three 7-symbol Costas arrays.
    a58 = b79[7:36] + b79[43:72]
    assert len(a58) == 58

    # turn 3-bits into 1-bits.
    # most-significant bit first.
    z = [ [ (x>>2)&1, (x>>1)&1, x&1 ] for x in a58 ]
    a174 = numpy.concatenate(z)
    assert len(a174) == 174

    if True:
        # flip some bits, for testing.
        a174[17] ^= 1
        a174[30] ^= 1
        a174[31] ^= 1
        a174[102] ^= 1

    # turn hard bits into 0.99 vs 0.01 log-likelihood,
    # log( P(0) / P(1) )
    # log base e.
    two = numpy.array([ 4.6, -4.6 ])
    ll174 = two[a174]

    # decode LDPC(174,87)
    a87 = ldpc_decode(ll174)

    # failure -> numpy.array([])
    assert len(a87) == 87

    # CRC12
    # this mimics the way the sender computes the 12-bit checksum:
    c = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
            crc12poly)
    assert numpy.array_equal(c, a87[-12:])

    # a87 is 72 bits of msg and 12 bits of CRC.
    # turn the 72 bits into twelve 6-bit numbers,
    # for compatibility with FT8 unpack().
    # MSB.
    a72 = a87[0:72]
    twelve = [ ]
    for i in range(0, 72, 6):
        a = a72[i:i+6]
        x = (a[0] * 32 +
             a[1] * 16 +
             a[2] *  8 +
             a[3] *  4 +
             a[4] *  2 +
             a[5] *  1)
        twelve.append(x)

    msg = r.unpack(twelve)
    assert msg == " K1ABC  W9XYZ EN37"

    sys.exit(0)

def usage():
    sys.stderr.write("Usage: ft8.py -card CARD CHAN\n")
    sys.stderr.write("       ft8.py -file fff [-chan xxx]\n")
    sys.stderr.write("       ft8.py -bench ft8files/xxx.txt\n")
    sys.stderr.write("       ft8.py -opt ft8files/xxx.txt\n")
    # list sound cards
    weakaudio.usage()
    sys.exit(1)

if False:
    # check that we can decode a perfect signal. checking that
    # the highest-ranked hz/offset is the desired one is a
    # pretty good diagnostic.

    rate = 12000
    #hz = (107 * 6.25) + 0.4
    #hz = (random.random() * 2400) + 100
    #hz = 100 * 6.25 - 1.56
    hz = 100 * 6.25
    hz -= 0.78

    npad = 0.5
    #npad += (random.random() * 1.0) - 0.5
    npad = int(rate * npad)
    npad -= 120

    s = FT8Send()
    twelve = s.pack("CQ W1HZ BM12")

    if True:
        x1 = s.send12(twelve, hz, rate)

    if False:
        # 30 yields reported SNR of -19, and 100% decodes with abs().
        # 40 yields -21, and about 50% decodes with abs().
        x1 += 40.0 * (numpy.random.rand(len(x1)) - 0.5)

    if False:
        symbols = s.make_symbols(twelve)
        x1 = numpy.zeros(79 * 1920)
        bin0 = int(round(hz / 6.25))
        for i in range(0, 79):
            off = i * 1920
            bins = numpy.zeros(961, dtype=numpy.complex128)
            for ii in range(bin0-10, bin0+18):
                # random complex numbers with magnitude one.
                x = random.random() + 1j*random.random()
                x /= abs(x)
                bins[ii] = x
            x = 0 + 1j
            x /= abs(x) # same amplitude as garbage signals
            if (i % 4) != 0:
                x *= 1.35
            bins[bin0 + symbols[i]] = x
            block2 = numpy.fft.irfft(bins)
            x1[off:off+1920] = block2
        x1 = x1 / numpy.mean(abs(x1))
        weakutil.writewav1(x1, "b.wav", 12000)

    x1 = numpy.append(numpy.random.rand(npad) - 0.5, x1)
    x1 = numpy.append(x1, numpy.random.rand(rate) - 0.5)

    r = FT8()
    r.cardrate = rate
    r.verbose = True
    r.process(x1, 0)

    msgs = r.get_msgs()
    if len(msgs) > 0:
        dec = msgs[0]

    sys.exit(0)

def set_start_adj(wsjtfile):
    global start_adj

    # time apparently wrong on laptop when I had wsjt-x record these files.
    if "ft8-40" in wsjtfile:
        start_adj = 0.5
    if "ft8-20" in wsjtfile:
        start_adj = 0.5
    if "ft8files" in wsjtfile:
        start_adj = 0.8

def benchmark(wsjtfile, verbose):
    dir = os.path.dirname(wsjtfile)
    minutes = { } # keyed by hhmmss
    wsjtf = open(wsjtfile, "r")
    for line in wsjtf:
        # 161230 -15  0.2 1779 ~  CQ W8MSC EN82 !U.S.A.
        # 161230 -16  0.8 2352 ~  VE2FON KM4MDT R-09
        # 161245 -21  0.3  538 ~  K3OWX KG5AUW -03
        # 161245   2  0.1  955 ~  KJ1J NS9I -06
        line = re.sub(r'\xA0', ' ', line) # 0xA0 -> space
        line = re.sub(r'[\r\n]', '', line)
        m = re.match(r'^([0-9]{6}) +.*$', line)
        if m == None:
            print("oops: " + line)
            continue
        hhmmss = m.group(1)
        if not hhmmss in minutes:
            minutes[hhmmss] = ""
        minutes[hhmmss] += line + "\n"
    wsjtf.close()

    info = [ ]
    for hhmmss in sorted(minutes.keys()):
        ff = [ x for x in os.listdir(dir) if re.match('......_' + hhmmss + '.wav', x) != None ]
        if len(ff) == 1:
            filename = ff[0]
            info.append([ True, filename, minutes[hhmmss] ])
        elif len(ff) == 0:
            sys.stderr.write("could not find .wav file in %s for %s\n" % (dir, hhmmss))
        else:
            sys.stderr.write("multiple files in %s for %s: %s\n" % (dir, hhmmss, ff))

    return benchmark1(dir, info, verbose)

def benchmark1(dir, bfiles, verbose):
    global chan
    chan = 0
    crcok = 0 # how many we decoded
    jtscore = 0 # how many we decoded that wsjt-x also decoded
    jtwanted = 0 # how many wsjt-x decoded
    for bf in bfiles:
        if not bf[0]: # only the short list
            continue
        if verbose:
            print(bf[1])
        filename = dir + "/" + bf[1]
        r = FT8()
        r.verbose = False
        if False:
            r.restrict_hz = [ 1500, 1750 ]
        r.gowav(filename, chan)
        all = r.get_msgs()
        crcok += len(all)
        got = { } # did wsjt-x see this? indexed by msg.
        any_no = False

        wsa = bf[2].split("\n")
        for wsx in wsa:
            # 161245 -21  0.3  538 ~  K3OWX KG5AUW -03
            # 161245   2  0.1  955 ~  KJ1J NS9I -06
            wsx = wsx.strip()
            if wsx != "":
                jtwanted += 1
                wsx = re.sub(r'  *', ' ', wsx)
                found = None
                for dec in all:
                    mymsg = dec.msg
                    mymsg = mymsg.strip()
                    mymsg = re.sub(r'  *', ' ', mymsg)
                    if mymsg in wsx:
                        found = dec
                        got[dec.msg] = True

                wa = wsx.split(' ')
                wmsg = ' '.join(wa[5:8])
                whz = float(wa[3])
                if whz >= 10 and whz < 11:
                    whz = (whz - 10.1387) * 1000000.0
                elif whz >= 14 and whz < 15:
                    whz = (whz - 14.0956) * 1000000.0
                elif whz < 1.0:
                    whz = whz * 1000000.0

                if found != None:
                    jtscore += 1
                    if verbose:
                        print("yes %4.0f %s (%.1f %.1f) %s" % (float(whz), wa[2], found.hz(), found.dt, wmsg))
                else:
                    any_no = True
                    if verbose:
                        print("no  %4.0f %s %s" % (float(whz), wa[2], wmsg))
                sys.stdout.flush()
        extras = [ ]
        for dec in all:
            if not (dec.msg in got) and not (dec.msg in extras):
                extras.append(dec.msg)
                if verbose:
                    print("EXTRA: %6.1f %s" % (dec.hz(), dec.msg))
        if False and any_no:
            # emit lines only for files in which we
            # some decodes that wsjt-x got.
            print(bf[2])
    if verbose:
        print("score %d (%d of %d)" % (crcok, jtscore, jtwanted))
    return [ crcok, jtscore, jtwanted ]

vars = [
    [ "fine_fstep", [ 8, 4, 2 ] ],
    [ "fine_tstep", [ 8, 4, 2 ] ],
    [ "coarse_fstep", [ 8, 4, 2, 1 ] ],
    [ "coarse_tstep", [ 8, 4, 2, 1 ] ],
    [ "already_o", [ 0, 1, 2, 3, 4 ] ],
    [ "already_f", [ 0, 1, 2, 3, 4 ] ],
    [ "ldpc_iters", [ 10, 12, 15, 18, 20, 22, 25, 30 ] ],
    [ "coarse_no", [ 1, 2, 3, 4 ] ],
    [ "contrast_weight", [ 0.2, 0.5, 0.75, 1.0, 1.5, 2.0, 0 ] ],
    [ "osd_crc", [ True, False ] ],
    [ "osd_order", [ -1, 0, 1, 2 ] ],
    [ "do_subtract", [ 0, 1, 2, 3, 4 ] ],
    [ "substeps", [ 12, 16, 20, 24, 32 ] ],
    [ "subpasses", [ 0, 1, 2, 3 ] ],
    [ "top_down", [ True, False ] ],
    [ "bottom_slow", [ True, False ] ],
    [ "top_high_order", [ 0, 6, 7, 9, 13 ] ],
    [ "top_low_order", [ 0, 6, 7, 9, 13 ] ],
    [ "bottom_low_order", [ 0, 6, 7, 9, 13 ] ],
    [ "coarse_tminus", [ 1.3, 1.4, 1.5, 1.6 ] ],
    [ "coarse_tplus", [ 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0 ] ],
    [ "budget", [ 2, 4, 11 ] ],
    [ "noise_factor", [ 1.0/28, 1.0/14, 1.0/7, 1.0/3.5, 1.0/2 ] ],
    [ "start_adj", [ 0.3, 0.4, 0.5, 0.6, 0.7 ] ],
    [ "weakutil.which_fft", [ "\"numpy\"", "\"scipy\"", "\"fftw\"" ] ],
    [ "down200", [ True, False ] ],
    # [ "phase_gran", [ 200, 100, 50, 25 ] ],
    # [ "subgap", [ 0.7, 0.8, 0.9, 1.0, 1.2, 1.25, 1.3, 1.4 ] ],
    # [ "softboost", [ 0, 0.125, 0.25, 0.33, 0.5, 1.0, 1.5, 2.0 ] ],
    ]

def printvars():
    s = ""
    for v in vars:
        s += "%s=%s " % (v[0], eval(v[0]))
    return s

def optimize(wsjtfile):
    set_start_adj(wsjtfile)

    sys.stdout.write("# %s %s\n" % (opt, printvars()))

    # warm up any caches, JIT, &c.
    r = FT8()
    r.verbose = False
    r.gowav("ft8files/170717_161300.wav", 0)

    for v in vars:
        for val in v[1]:
            old = None
            if "." in v[0]:
                xglob = ""
            else:
                xglob = "global %s ; " % (v[0])
            exec("%sold = %s" % (xglob, v[0]))
            exec("%s%s = %s" % (xglob, v[0], val))

            [ crcok, jtscore, jtwanted ] = benchmark(wsjtfile, False)
            exec("%s%s = old" % (xglob, v[0]))
            sys.stdout.write("%s=%s : " % (v[0], val))
            sys.stdout.write("%d %d %d\n" % (crcok, jtscore, jtwanted))
            sys.stdout.flush()

filename = None
card = None
bench = None
opt = None

def main():
    global filename, card, bench, opt, very_first_time
    i = 1
    while i < len(sys.argv):
        if sys.argv[i] == "-card":
            card = [ sys.argv[i+1], sys.argv[i+2] ]
            i += 3
        elif sys.argv[i] == "-file":
            filename = sys.argv[i+1]
            i += 2
        elif sys.argv[i] == "-bench":
            bench = sys.argv[i+1]
            i += 2
        elif sys.argv[i] == "-opt":
            opt = sys.argv[i+1]
            i += 2
        else:
            usage()

    if False:
        xr = FT8()
        xr.test_guess_offset()
        sys.exit(0)

    if bench != None:
        set_start_adj(bench)
        sys.stdout.write("# %s %s\n" % (bench, printvars()))
        benchmark(bench, True)
        sys.exit(0)

    if opt != None:
        optimize(opt)
        sys.exit(0)

    if filename != None and card == None:
        very_first_time = False # don't warm up, since only single call
        set_start_adj(filename)
        r = FT8()
        r.verbose = True
        r.gowav(filename, 0)
    elif filename == None and card != None:
        r = FT8()
        r.verbose = True
        r.opencard(card)
        r.gocard()
    else:
        usage()

weakutil.init_fft([1920,1920//2,1920//4,32])

if __name__ == '__main__':
    if len(sys.argv) > 1 and sys.argv[1] == '-p':
        sys.argv = sys.argv[1:]
        profiling = True
        pfile = "cprof.out"
        import cProfile
        import pstats
        cProfile.run('main()', pfile)
        p = pstats.Stats(pfile)
        p.strip_dirs().sort_stats('time')
        p.print_callers()
    else:
        main()
