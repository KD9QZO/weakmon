#!/usr/local/bin/python

#
# decode FT8
#
# Robert Morris, AB1HL
#

import numpy
import wave
import scipy
import scipy.signal
import sys
import os
import math
import time
import copy
import calendar
import subprocess
import multiprocessing
import threading
import re
import random
from scipy.signal import lfilter
import ctypes
import weakaudio
import weakutil
import ctypes

#
# tuning parameters.
#
budget = 2 # max seconds of time for decoding.
coarse_fstep = 0.33 # coarse search granularity, FFT bins
coarse_tstep = 0.25 # coarse search granularity, symbol times
coarse_tslop = 1.75 # coarse search, +/- start time of 0.5 seconds, in seconds
coarse_no    = 2 # number of best offsets to use per hz
fine_tslop = 1.0 # fraction of coarse_tstep, for offset fine-tuning
fine_tstep = 0.5 # fraction of fine_tslop
fine_fslop = 0.0 # fraction of coarse_fstep, for hz fine-tuning
fine_fstep = 0.5 # fraction of fine_fslop
start_adj = 0.5 # signals seem on avg to start this many seconds late.
ldpc_iters = 25

# FT8 modulation and protocol definitions.
# 1920-point FFT at 12000 samples/second
#   yields 6.25 Hz spacing, 0.16 seconds/symbol
# encode chain:
#   75 bits
#   append 12 bits CRC (for 87 bits)
#   LDPC(174,87) yields 174 bits
#   that's 58 3-bit FSK-8 symbols
#   insert three 7-symbol Costas sync arrays
#     at symbol #s 0, 36, 72 of final signal
#   thus: 79 FSK-8 symbols
# total transmission time is 12.64 seconds
nsymbols = 79 # 79 FSK symbols per msg

# LDPC(174,87) parameters from WSJT-X.
# this is an indirection table that moves a
# codeword's 87 systematic (message) bits to the end.
colorder = [
  0, 1, 2, 3, 30, 4, 5, 6, 7, 8, 9, 10, 11, 32, 12, 40, 13, 14, 15, 16,
  17, 18, 37, 45, 29, 19, 20, 21, 41, 22, 42, 31, 33, 34, 44, 35, 47,
  51, 50, 43, 36, 52, 63, 46, 25, 55, 27, 24, 23, 53, 39, 49, 59, 38,
  48, 61, 60, 57, 28, 62, 56, 58, 65, 66, 26, 70, 64, 69, 68, 67, 74,
  71, 54, 76, 72, 75, 78, 77, 80, 79, 73, 83, 84, 81, 82, 85, 86, 87,
  88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103,
  104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117,
  118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131,
  132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145,
  146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
  160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173
  ]

# this is the LDPC(174,87) parity check matrix.
# 87 rows.
# each row describes one parity check.
# each number is an index into the codeword (1-origin).
# the codeword bits mentioned in each row must xor to zero.
# From WSJT-X's bpdecode174.f90.
Nm = [
    [ 1,   30,  60,  89,   118,  147,  0 ],
    [ 2,   31,  61,  90,   119,  147,  0 ],
    [ 3,   32,  62,  91,   120,  148,  0 ],
    [ 4,   33,  63,  92,   121,  149,  0 ],
    [ 2,   34,  64,  93,   122,  150,  0 ],
    [ 5,   33,  65,  94,   123,  148,  0 ],
    [ 6,   34,  66,  95,   124,  151,  0 ],
    [ 7,   35,  67,  96,   120,  152,  0 ],
    [ 8,   36,  68,  97,   125,  153,  0 ],
    [ 9,   37,  69,  98,   126,  152,  0 ],
    [ 10,  38,  70,  99,   127,  154,  0 ],
    [ 11,  39,  71,  100,  126,  155,  0 ],
    [ 12,  40,  61,  101,  128,  145,  0 ],
    [ 10,  33,  60,  95,   128,  156,  0 ],
    [ 13,  41,  72,  97,   126,  157,  0 ],
    [ 13,  42,  73,  90,   129,  156,  0 ],
    [ 14,  39,  74,  99,   130,  158,  0 ],
    [ 15,  43,  75,  102,  131,  159,  0 ],
    [ 16,  43,  71,  103,  118,  160,  0 ],
    [ 17,  44,  76,  98,   130,  156,  0 ],
    [ 18,  45,  60,  96,   132,  161,  0 ],
    [ 19,  46,  73,  83,   133,  162,  0 ],
    [ 12,  38,  77,  102,  134,  163,  0 ],
    [ 19,  47,  78,  104,  135,  147,  0 ],
    [ 1,   32,  77,  105,  136,  164,  0 ],
    [ 20,  48,  73,  106,  123,  163,  0 ],
    [ 21,  41,  79,  107,  137,  165,  0 ],
    [ 22,  42,  66,  108,  138,  152,  0 ],
    [ 18,  42,  80,  109,  139,  154,  0 ],
    [ 23,  49,  81,  110,  135,  166,  0 ],
    [ 16,  50,  82,  91,   129,  158,  0 ],
    [ 3,   48,  63,  107,  124,  167,  0 ],
    [ 6,   51,  67,  111,  134,  155,  0 ],
    [ 24,  35,  77,  100,  122,  162,  0 ],
    [ 20,  45,  76,  112,  140,  157,  0 ],
    [ 21,  36,  64,  92,   130,  159,  0 ],
    [ 8,   52,  83,  111,  118,  166,  0 ],
    [ 21,  53,  84,  113,  138,  168,  0 ],
    [ 25,  51,  79,  89,   122,  158,  0 ],
    [ 22,  44,  75,  107,  133,  155,  172 ],
    [ 9,   54,  84,  90,   141,  169,  0 ],
    [ 22,  54,  85,  110,  136,  161,  0 ],
    [ 8,   37,  65,  102,  129,  170,  0 ],
    [ 19,  39,  85,  114,  139,  150,  0 ],
    [ 26,  55,  71,  93,   142,  167,  0 ],
    [ 27,  56,  65,  96,   133,  160,  174 ],
    [ 28,  31,  86,  100,  117,  171,  0 ],
    [ 28,  52,  70,  104,  132,  144,  0 ],
    [ 24,  57,  68,  95,   137,  142,  0 ],
    [ 7,   30,  72,  110,  143,  151,  0 ],
    [ 4,   51,  76,  115,  127,  168,  0 ],
    [ 16,  45,  87,  114,  125,  172,  0 ],
    [ 15,  30,  86,  115,  123,  150,  0 ],
    [ 23,  46,  64,  91,   144,  173,  0 ],
    [ 23,  35,  75,  113,  145,  153,  0 ],
    [ 14,  41,  87,  108,  117,  149,  170 ],
    [ 25,  40,  85,  94,   124,  159,  0 ],
    [ 25,  58,  69,  116,  143,  174,  0 ],
    [ 29,  43,  61,  116,  132,  162,  0 ],
    [ 15,  58,  88,  112,  121,  164,  0 ],
    [ 4,   59,  72,  114,  119,  163,  173 ],
    [ 27,  47,  86,  98,   134,  153,  0 ],
    [ 5,   44,  78,  109,  141,  0,    0 ],
    [ 10,  46,  69,  103,  136,  165,  0 ],
    [ 9,   50,  59,  93,   128,  164,  0 ],
    [ 14,  57,  58,  109,  120,  166,  0 ],
    [ 17,  55,  62,  116,  125,  154,  0 ],
    [ 3,   54,  70,  101,  140,  170,  0 ],
    [ 1,   36,  82,  108,  127,  174,  0 ],
    [ 5,   53,  81,  105,  140,  0,    0 ],
    [ 29,  53,  67,  99,   142,  173,  0 ],
    [ 18,  49,  74,  97,   115,  167,  0 ],
    [ 2,   57,  63,  103,  138,  157,  0 ],
    [ 26,  38,  79,  112,  135,  171,  0 ],
    [ 11,  52,  66,  88,   119,  148,  0 ],
    [ 20,  40,  68,  117,  141,  160,  0 ],
    [ 11,  48,  81,  89,   146,  169,  0 ],
    [ 29,  47,  80,  92,   146,  172,  0 ],
    [ 6,   32,  87,  104,  145,  169,  0 ],
    [ 27,  34,  74,  106,  131,  165,  0 ],
    [ 12,  56,  84,  88,   139,  0,    0 ],
    [ 13,  56,  62,  111,  146,  171,  0 ],
    [ 26,  37,  80,  105,  144,  151,  0 ],
    [ 17,  31,  82,  113,  121,  161,  0 ],
    [ 28,  49,  59,  94,   137,  0,    0 ],
    [ 7,   55,  83,  101,  131,  168,  0 ],
    [ 24,  50,  78,  106,  143,  149,  0 ],
]

# Mn from WSJT-X's bpdecode174.f90.
# each row corresponds to a codeword bit.
# the numbers indicate which three parity
# checks (rows in Nm) refer to the codeword bit.
# 1-origin.
Mn = [
  [ 1, 25, 69 ],
  [ 2, 5, 73 ],
  [ 3, 32, 68 ],
  [ 4, 51, 61 ],
  [ 6, 63, 70 ],
  [ 7, 33, 79 ],
  [ 8, 50, 86 ],
  [ 9, 37, 43 ],
  [ 10, 41, 65 ],
  [ 11, 14, 64 ],
  [ 12, 75, 77 ],
  [ 13, 23, 81 ],
  [ 15, 16, 82 ],
  [ 17, 56, 66 ],
  [ 18, 53, 60 ],
  [ 19, 31, 52 ],
  [ 20, 67, 84 ],
  [ 21, 29, 72 ],
  [ 22, 24, 44 ],
  [ 26, 35, 76 ],
  [ 27, 36, 38 ],
  [ 28, 40, 42 ],
  [ 30, 54, 55 ],
  [ 34, 49, 87 ],
  [ 39, 57, 58 ],
  [ 45, 74, 83 ],
  [ 46, 62, 80 ],
  [ 47, 48, 85 ],
  [ 59, 71, 78 ],
  [ 1, 50, 53 ],
  [ 2, 47, 84 ],
  [ 3, 25, 79 ],
  [ 4, 6, 14 ],
  [ 5, 7, 80 ],
  [ 8, 34, 55 ],
  [ 9, 36, 69 ],
  [ 10, 43, 83 ],
  [ 11, 23, 74 ],
  [ 12, 17, 44 ],
  [ 13, 57, 76 ],
  [ 15, 27, 56 ],
  [ 16, 28, 29 ],
  [ 18, 19, 59 ],
  [ 20, 40, 63 ],
  [ 21, 35, 52 ],
  [ 22, 54, 64 ],
  [ 24, 62, 78 ],
  [ 26, 32, 77 ],
  [ 30, 72, 85 ],
  [ 31, 65, 87 ],
  [ 33, 39, 51 ],
  [ 37, 48, 75 ],
  [ 38, 70, 71 ],
  [ 41, 42, 68 ],
  [ 45, 67, 86 ],
  [ 46, 81, 82 ],
  [ 49, 66, 73 ],
  [ 58, 60, 66 ],
  [ 61, 65, 85 ],
  [ 1, 14, 21 ],
  [ 2, 13, 59 ],
  [ 3, 67, 82 ],
  [ 4, 32, 73 ],
  [ 5, 36, 54 ],
  [ 6, 43, 46 ],
  [ 7, 28, 75 ],
  [ 8, 33, 71 ],
  [ 9, 49, 76 ],
  [ 10, 58, 64 ],
  [ 11, 48, 68 ],
  [ 12, 19, 45 ],
  [ 15, 50, 61 ],
  [ 16, 22, 26 ],
  [ 17, 72, 80 ],
  [ 18, 40, 55 ],
  [ 20, 35, 51 ],
  [ 23, 25, 34 ],
  [ 24, 63, 87 ],
  [ 27, 39, 74 ],
  [ 29, 78, 83 ],
  [ 30, 70, 77 ],
  [ 31, 69, 84 ],
  [ 22, 37, 86 ],
  [ 38, 41, 81 ],
  [ 42, 44, 57 ],
  [ 47, 53, 62 ],
  [ 52, 56, 79 ],
  [ 60, 75, 81 ],
  [ 1, 39, 77 ],
  [ 2, 16, 41 ],
  [ 3, 31, 54 ],
  [ 4, 36, 78 ],
  [ 5, 45, 65 ],
  [ 6, 57, 85 ],
  [ 7, 14, 49 ],
  [ 8, 21, 46 ],
  [ 9, 15, 72 ],
  [ 10, 20, 62 ],
  [ 11, 17, 71 ],
  [ 12, 34, 47 ],
  [ 13, 68, 86 ],
  [ 18, 23, 43 ],
  [ 19, 64, 73 ],
  [ 24, 48, 79 ],
  [ 25, 70, 83 ],
  [ 26, 80, 87 ],
  [ 27, 32, 40 ],
  [ 28, 56, 69 ],
  [ 29, 63, 66 ],
  [ 30, 42, 50 ],
  [ 33, 37, 82 ],
  [ 35, 60, 74 ],
  [ 38, 55, 84 ],
  [ 44, 52, 61 ],
  [ 51, 53, 72 ],
  [ 58, 59, 67 ],
  [ 47, 56, 76 ],
  [ 1, 19, 37 ],
  [ 2, 61, 75 ],
  [ 3, 8, 66 ],
  [ 4, 60, 84 ],
  [ 5, 34, 39 ],
  [ 6, 26, 53 ],
  [ 7, 32, 57 ],
  [ 9, 52, 67 ],
  [ 10, 12, 15 ],
  [ 11, 51, 69 ],
  [ 13, 14, 65 ],
  [ 16, 31, 43 ],
  [ 17, 20, 36 ],
  [ 18, 80, 86 ],
  [ 21, 48, 59 ],
  [ 22, 40, 46 ],
  [ 23, 33, 62 ],
  [ 24, 30, 74 ],
  [ 25, 42, 64 ],
  [ 27, 49, 85 ],
  [ 28, 38, 73 ],
  [ 29, 44, 81 ],
  [ 35, 68, 70 ],
  [ 41, 63, 76 ],
  [ 45, 49, 71 ],
  [ 50, 58, 87 ],
  [ 48, 54, 83 ],
  [ 13, 55, 79 ],
  [ 77, 78, 82 ],
  [ 1, 2, 24 ],
  [ 3, 6, 75 ],
  [ 4, 56, 87 ],
  [ 5, 44, 53 ],
  [ 7, 50, 83 ],
  [ 8, 10, 28 ],
  [ 9, 55, 62 ],
  [ 11, 29, 67 ],
  [ 12, 33, 40 ],
  [ 14, 16, 20 ],
  [ 15, 35, 73 ],
  [ 17, 31, 39 ],
  [ 18, 36, 57 ],
  [ 19, 46, 76 ],
  [ 21, 42, 84 ],
  [ 22, 34, 59 ],
  [ 23, 26, 61 ],
  [ 25, 60, 65 ],
  [ 27, 64, 80 ],
  [ 30, 37, 66 ],
  [ 32, 45, 72 ],
  [ 38, 51, 86 ],
  [ 41, 77, 79 ],
  [ 43, 56, 68 ],
  [ 47, 74, 82 ],
  [ 40, 52, 78 ],
  [ 54, 61, 71 ],
  [ 46, 58, 69 ],
]

# LDPC generator matrix, from wsjt-x's encode174.f90 and ldpc_174_87_params.f90
# 87 rows, 87 columns.
# generates first 87 codeword bits; second 87 are the 87 bits of plain-text.
# i'th codeword bit is xor of plain bits and gen[i].
gen = [
    [ 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1 ],
    [ 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0 ],
    [ 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1 ],
    [ 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1 ],
    [ 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0 ],
    [ 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 ],
    [ 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1 ],
    [ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0 ],
    [ 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0 ],
    [ 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1 ],
    [ 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0 ],
    [ 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0 ],
    [ 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0 ],
    [ 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0 ],
    [ 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1 ],
    [ 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0 ],
    [ 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0 ],
    [ 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1 ],
    [ 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0 ],
    [ 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1 ],
    [ 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1 ],
    [ 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0 ],
    [ 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0 ],
    [ 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1 ],
    [ 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0 ],
    [ 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0 ],
    [ 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0 ],
    [ 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0 ],
    [ 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1 ],
    [ 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1 ],
    [ 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0 ],
    [ 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1 ],
    [ 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0 ],
    [ 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1 ],
    [ 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1 ],
    [ 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0 ],
    [ 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0 ],
    [ 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1 ],
    [ 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0 ],
    [ 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1 ],
    [ 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1 ],
    [ 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0 ],
    [ 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1 ],
    [ 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1 ],
    [ 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1 ],
    [ 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1 ],
    [ 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1 ],
    [ 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1 ],
    [ 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0 ],
    [ 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0 ],
    [ 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0 ],
    [ 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1 ],
    [ 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1 ],
    [ 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0 ],
    [ 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0 ],
    [ 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1 ],
    [ 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1 ],
    [ 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0 ],
    [ 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ],
    [ 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0 ],
    [ 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0 ],
    [ 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0 ],
    [ 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0 ],
    [ 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0 ],
    [ 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1 ],
    [ 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0 ],
    [ 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1 ],
    [ 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1 ],
    [ 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1 ],
    [ 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1 ],
    [ 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0 ],
    [ 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0 ],
    [ 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1 ],
    [ 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1 ],
    [ 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1 ],
    [ 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1 ],
    [ 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 1 ],
    [ 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0 ],
    [ 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1 ],
    [ 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1 ],
    [ 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1 ],
    [ 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0 ],
    [ 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0 ],
    [ 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1 ],
]

# plain is 87 bits of plain-text.
# returns a 174-bit codeword.
# mimics wsjt-x's encode174.f90.
def ldpc_encode(plain):
    cw = numpy.zeros(174, dtype=numpy.int32)
    for i in range(0, 87):
        x = numpy.multiply(plain, gen[i])
        cw[i] = numpy.sum(x) % 2
    cw[87:] = plain

    cw1 = numpy.zeros(174, dtype=numpy.int32)
    for i in range(0, 174):
        cw1[colorder[i]] = cw[i]

    return cw1

# given a 174-bit codeword as an array of log-likelihood of zero,
# return a 87-bit plain text, or zero-length array.
# this is an implementation of the sum-product algorithm
# from Sarah Johnson's Iterative Error Correction book.
# codeword[i] = log ( P(x=0) / P(x=1) )
def ldpc_decode_python(codeword):
    # 174 codeword bits
    # 87 parity checks

    mnx = numpy.array(Mn, dtype=numpy.int32)
    nmx = numpy.array(Nm, dtype=numpy.int32)

    # Mji
    # each codeword bit i tells each parity check j
    # what the bit's log-likelihood of being 0 is
    # based on information *other* than from that
    # parity check.
    m = numpy.zeros((87, 174))

    for i in range(0, 174):
        for j in range(0, 87):
            m[j][i] = codeword[i]

    for iter in range(0, ldpc_iters):
        # Eji
        # each check j tells each codeword bit i the
        # log likelihood of the bit being zero based
        # on the *other* bits in that check.
        e = numpy.zeros((87, 174))

        # messages from checks to bits.
        # for each parity check
        #for j in range(0, 87):
        #    # for each bit mentioned in this parity check
        #    for i in Nm[j]:
        #        if i <= 0:
        #            continue
        #        a = 1
        #        # for each other bit mentioned in this parity check
        #        for ii in Nm[j]:
        #            if ii != i:
        #                a *= math.tanh(m[j][ii-1] / 2.0)
        #        e[j][i-1] = math.log((1 + a) / (1 - a))
        for i in range(0, 7):
            a = numpy.ones(87)
            for ii in range(0, 7):
                if ii != i:
                    x1 = numpy.tanh(m[range(0, 87), nmx[:,ii]-1] / 2.0)
                    x2 = numpy.where(numpy.greater(nmx[:,ii], 0.0), x1, 1.0)
                    a = a * x2
            # avoid divide by zero, i.e. a[i]==1.0
            # XXX why is a[i] sometimes 1.0?
            b = numpy.where(numpy.less(a, 0.99999), a, 0.99)
            c = numpy.log((b + 1.0) / (1.0 - b))
            # have assign be no-op when nmx[a,b] == 0
            d = numpy.where(numpy.equal(nmx[:,i], 0),
                            e[range(0,87), nmx[:,i]-1],
                            c)
            e[range(0,87), nmx[:,i]-1] = d

        # decide if we are done -- compute the corrected codeword,
        # see if the parity check succeeds.
        # sum the three log likelihoods contributing to each codeword bit.
        e0 = e[mnx[:,0]-1, range(0,174)]
        e1 = e[mnx[:,1]-1, range(0,174)]
        e2 = e[mnx[:,2]-1, range(0,174)]
        ll = codeword + e0 + e1 + e2
        # log likelihood > 0 => bit=0.
        cw = numpy.select( [ ll < 0 ], [ numpy.ones(174, dtype=numpy.int32) ])
        if ldpc_check(cw):
            # success!
            # it's a systematic code, though the plain-text bits are scattered.
            # collect them.
            decoded = cw[colorder]
            decoded = decoded[-87:]
            return decoded

        # messages from bits to checks.
        for j in range(0, 3):
            # for each column in Mn.
            ll = codeword
            if j != 0:
                e0 = e[mnx[:,0]-1, range(0,174)]
                ll = ll + e0
            if j != 1:
                e1 = e[mnx[:,1]-1, range(0,174)]
                ll = ll + e1
            if j != 2:
                e2 = e[mnx[:,2]-1, range(0,174)]
                ll = ll + e2
            m[mnx[:,j]-1, range(0,174)] = ll
                

    # could not decode.
    return numpy.array([])

# given a 174-bit codeword as an array of log-likelihood of zero,
# return a 87-bit plain text, or zero-length array.
# this is an implementation of the bit-flipping algorithm
# from Sarah Johnson's Iterative Error Correction book.
# codeword[i] = log ( P(x=0) / P(x=1) )
def ldpc_decode_flipping(codeword):
    # turn log-likelihood into hard bits.
    # > 0 means bit=0, < 0 means bit=1.
    hard = numpy.less(codeword, 0.0)
    hard = numpy.array(hard, dtype=numpy.int32) # T/F -> 1/0
    two = numpy.array([0, 1], dtype=numpy.int32)
    cw = two[hard]

    for iter in range(0,100):
        # for each codeword bit,
        # count of votes for 0 and 1.
        votes = numpy.zeros((len(codeword), 2))

        # for each parity check equation.
        for e in Nm:
            # for each codeword bit mentioned in e.
            for bi in e:
                if bi == 0:
                    continue
                # value for bi implied by remaining bits.
                x = 0
                for i in e:
                    if i != bi:
                        x ^= cw[i-1]
                # the other bits in the equation suggest that
                # bi must have value x.
                votes[(bi-1),x] += 1

        for i in range(0, len(cw)):
            if cw[i] == 0 and votes[i][1] > votes[i][0]:
                cw[i] = 1
            elif cw[i] == 1 and votes[i][0] > votes[i][1]:
                cw[i] = 0

        if ldpc_check(cw):
            # success!
            # it's a systematic code, though the plain-text bits are scattered.
            # collect them.
            decoded = cw[colorder]
            decoded = decoded[-87:]
            return decoded
        
    return numpy.array([])

# does a 174-bit codeword pass the LDPC parity checks?
def ldpc_check(codeword):
    for e in Nm:
        x = 0
        for i in e:
            if i != 0:
                x ^= codeword[i-1]
        if x != 0:
            return False
    return True

libldpc = None
try:
    libldpc = ctypes.cdll.LoadLibrary("libldpc/libldpc.so")
except:
    libldpc = None
    sys.stderr.write("ft8: using the Python LDPC decoder, not the C decoder.\n")

def ldpc_test():
    tt = 0.0
    niters = 200
    ok = 0
    for iter in range(0, niters):
        # ldpc_encode() takes 87 bits.
        a87 = numpy.random.randint(0, 2, 87)
        a174 = ldpc_encode(a87)
        
        # turn hard bits into 0.99 vs 0.01 log-likelihood,
        # log( P(0) / P(1) )
        # log base e.
        two = numpy.array([ 4.6, -4.6 ], dtype=numpy.int32)
        ll174 = two[a174]

        # wreck some bits
        for junk in range(0, 70):
            ll174[random.randint(0, len(ll174)-1)] = (random.random() - 0.5) * 4

        t0 = time.time()
        
        # decode LDPC(174,87)
        d87 = ldpc_decode(ll174)

        t1 = time.time()
        tt += t1 - t0

        if numpy.array_equal(a87, d87):
            ok += 1

    print("success %.2f" % (ok / float(niters)))
    print("%.6f per call" % (tt / niters))
    # success 0.88
    # 0.019423 per call

# codeword is 174 log-likelihoods.
# return is 87 bits.
def ldpc_decode_c(codeword):
    double174 = ctypes.c_double * 174
    int87 = ctypes.c_int * 87

    c174 = double174()
    for i in range(0, 174):
        c174[i] = codeword[i]

    c87 = int87()
    for i in range(0, 87):
        c87[i] = -1;

    ok = ctypes.c_int()
    ok.value = -1

    libldpc.ldpc_decode(c174, ldpc_iters, c87, ctypes.byref(ok))

    if ok == 0:
        return numpy.array([], dtype=numpy.int32);

    plain = numpy.zeros(87, dtype=numpy.int32);
    for i in range(0, 87):
        plain[i] = c87[i];

    return plain

def ldpc_decode(codeword):
    if libldpc != None:
        return ldpc_decode_c(codeword)
    else:
        return ldpc_decode_python(codeword)

if False:
    ldpc_test()
    sys.exit(1)

# the CRC-12 polynomial, from wsjt-x's 0xc06.
crc12poly = [ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 ]

# information about one decoded signal.
class Decode:
    def __init__(self,
                 hza,
                 msg,
                 snr,
                 twelve,
                 decode_time):
        self.hza = hza
        self.msg = msg
        self.snr = snr
        self.twelve = twelve # the 72 bits, as 12 6-bit numbers
        self.decode_time = decode_time # unix time of decode
        self.minute = None # cycle number
        self.start = None # sample number
        self.dt = None # dt in seconds
        self.drift = self.hz() - hza[0] # Hz per minute

    def hz(self):
        return numpy.mean(self.hza)


# Normal function integrated from -Inf to x. Range: 0-1.
# x in units of std dev.
# mean is zero.
def normal(x):
    y = 0.5 + 0.5*math.erf(x / 1.414213)
    return y

# how much of the distribution is < x?
def problt(x, mean, std):
    if std != 0.0:
        y = normal((x - mean) / std)
    else:
        y = 0.5
    return y

# how much of the distribution is > x?
def probgt(x, mean, std):
    if std != 0.0:
        y = 1.0 - normal((x - mean) / std)
    else:
        y = 0.5
    return y

def bit_reverse(x, width):
    y = 0
    for i in range(0, width):
        z = (x >> i) & 1
        y <<= 1
        y |= z
    return y

# turn an array of bits into a number.
# most significant bit first.
def bits2num(bits):
    assert len(bits) < 32
    n = 0
    for i in range(0, len(bits)):
        n *= 2
        n += bits[i]
    return n

#
# thank you, evan sneath.
# https://gist.github.com/evansneath/4650991
#
# generate with x^3 + x + 1:
#   >>> xc.crc([1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1])
#   array([1, 0, 0])
# check:
#   >>> xc.crc([1, 1, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0], [1, 0, 1, 1], [1, 0, 0])
#   array([0, 0, 0])
#
# 0xc06 is really 0x1c06 or [ 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0 ]
#
def crc(msg, div, code=None):
    """Cyclic Redundancy Check
    Generates an error detecting code based on an inputted message
    and divisor in the form of a polynomial representation.
    Arguments:
        msg: The input message of which to generate the output code.
        div: The divisor in polynomial form. For example, if the polynomial
            of x^3 + x + 1 is given, this should be represented as '1011' in
            the div argument.
        code: This is an option argument where a previously generated code may
            be passed in. This can be used to check validity. If the inputted
            code produces an outputted code of all zeros, then the message has
            no errors.
    Returns:
        An error-detecting code generated by the message and the given divisor.
    """

    # Append the code to the message. If no code is given, default to '000'
    if code is None:
        code = numpy.zeros(len(div)-1, dtype=numpy.int32)
    assert len(code) == len(div) - 1
    msg = numpy.append(msg, code)

    # Loop over every message bit (minus the appended code)
    for i in range(len(msg)-len(code)):
        # If that messsage bit is 1, perform modulo 2 multiplication
        if msg[i] == 1:
            for j in range(len(div)):
                # Perform modulo 2 multiplication on each index of the divisor
                msg[i+j] = (msg[i+j] + div[j]) % 2

    # Output the last error-checking code portion of the message generated
    return msg[-len(code):]

# gadget that returns FFT buckets of a fixed set of
# original samples, with required (inter-bucket)
# frequency, drift, and offset.
class FFTCache:
    def __init__(self, samples, jrate, jblock):
        self.jrate = jrate
        self.jblock = jblock
        self.samples = samples
        self.memo = { }
        self.bin_granules = 4
        self.block_granules = 4

    def make(self, binkey, blockkey):
        key = str(blockkey) + "-" + str(binkey)
        if key in self.memo:
            return self.memo[key]
        # do all the FFTs for the indicated frequency and time shift.
        # m[1..79ish][0..fftsize]
        m = numpy.zeros((len(self.samples) // self.jblock, (self.jblock // 2) + 1))
        self.memo[key] = m
        bin_hz = self.jrate / float(self.jblock)
        freq_off = binkey * (bin_hz / self.bin_granules)
        ss = weakutil.freq_shift(self.samples, -freq_off, 1.0/self.jrate)
        bi = 0
        while True:
            off = (bi * self.jblock) + (blockkey * (self.jblock / self.block_granules))
            if off + self.jblock > len(ss):
                break
            a = numpy.fft.rfft(ss[off:off+self.jblock])
            a = abs(a)
            m[bi] = a
            bi += 1
        return m

    # return bins[symbol][bin] -- i.e. a mini-FFT per symbol.
    def get(self, hz, start):
        bin_hz = self.jrate / float(self.jblock)
        bin = int(hz / bin_hz)
        m = self.getall(hz, start)
        return m[start // self.jblock : , bin : bin+8]

    # return the complete set of FFTs, m[symbol][bin]
    # hz and start just cause a sub-bin and sub-symbol shift.
    # that is, the returned array starts near hz=0
    # and offset=0.
    def getall(self, hz, start):
        # which quarter-bin?
        bin_hz = self.jrate / float(self.jblock)
        bin = int(hz / bin_hz)
        binfrac = (hz / bin_hz) - bin
        binkey = int(binfrac / (1.0 / self.bin_granules))
        
        # which eighth-block?
        blockoff = start % self.jblock
        blockkey = int(blockoff / (self.jblock / self.block_granules))

        m = self.make(binkey, blockkey)
        
        return m

    # subtract a decoded signal, reconstituted from decoded message,
    # which may help decodes of buried signals.
    def subtract(self, hz, start, symbols):
        bin_hz = self.jrate / float(self.jblock)
        hzgran = bin_hz / self.bin_granules
        offgran = self.jblock // self.block_granules
        for binkey in range(0, self.bin_granules):
            for blockkey in range(0, self.block_granules):
                key = str(blockkey) + "-" + str(binkey)
                if key in self.memo:
                    m = self.memo[key]
                    # m[0..79ish][0..fftsize]
                    block0 = (start - offgran*blockkey) // self.jblock
                    bin0 = int(round((hz - hzgran*binkey) / bin_hz))
                    #for i in range(0, len(symbols)):
                    #    m[block0+i][bin0+symbols[i]] = 0
                    m[range(block0,block0+len(symbols)),symbols+bin0] = 0

    def len(self):
        return len(self.samples)

# for unpack() &c.
NBASE = 37*36*10*27*27*27
# start of special grid locators for sig strength &c.
NGBASE = 180*180

class FT8:
  debug = False

  offset = 0

  def __init__(self):
      self.msgs_lock = threading.Lock()
      self.msgs = [ ]
      self.verbose = False
      self.enabled = True

      self.jrate = 12000 # sample rate for processing (FFT &c)
      self.jblock = 1920 # samples per symbol

      # set self.start_time to the UNIX time of the start
      # of the last UTC minute.
      now = int(time.time())
      gm = time.gmtime(now)
      self.start_time = now - gm.tm_sec

  def close(self):
      pass

  # seconds per cycle
  def cycle_seconds(self):
      return 15

  # return the minute number for t, a UNIX time in seconds.
  # truncates down, so best to pass a time mid-way through a minute.
  # returns only even minutes.
  def minute(self, t):
      dt = t - self.start_time
      return int(dt / 15.0)

  # convert cycle number to UNIX time.
  def minute2time(self, m):
      return (m * 15) + self.start_time

  # seconds since minute(), 0..15
  def second(self, t):
      dt = t - self.start_time
      dt /= 15.0
      return 15.0 * (dt - int(dt))

  def seconds_left(self, t):
      return 15 - self.second(t)

  # printable UTC timestamp, e.g. "07/07/15 16:31:00"
  # dd/mm/yy hh:mm:ss
  # t is unix time.
  def ts(self, t):
      gm = time.gmtime(t)
      return "%02d/%02d/%02d %02d:%02d:%02d" % (gm.tm_mday,
                                                gm.tm_mon,
                                                gm.tm_year - 2000,
                                                gm.tm_hour,
                                                gm.tm_min,
                                                gm.tm_sec)

  def openwav(self, filename):
    self.wav = wave.open(filename)
    self.wav_channels = self.wav.getnchannels()
    self.wav_width = self.wav.getsampwidth()
    self.cardrate = self.wav.getframerate()

  def readwav(self, chan):
    z = self.wav.readframes(8192)
    if self.wav_width == 1:
      zz = numpy.fromstring(z, numpy.int8)
    elif self.wav_width == 2:
      if (len(z) % 2) == 1:
        return numpy.array([])
      zz = numpy.fromstring(z, numpy.int16)
    else:
      sys.stderr.write("oops wave_width %d" % (self.wav_width))
      sys.exit(1)
    if self.wav_channels == 1:
      return zz
    elif self.wav_channels == 2:
      return zz[chan::2] # chan 0/1 => left/right
    else:
      sys.stderr.write("oops wav_channels %d" % (self.wav_channels))
      sys.exit(1)

  def gowav(self, filename, chan):
    self.openwav(filename)
    bufbuf = [ ]
    while True:
      buf = self.readwav(chan)
      if buf.size < 1:
        break
      bufbuf.append(buf)
    samples = numpy.concatenate(bufbuf)

    # trim trailing zeroes that wsjt-x adds to .wav files.
    i = len(samples)
    while i > 1000 and numpy.max(samples[i-1:]) == 0.0:
        if numpy.max(samples[i-1000:]) == 0.0:
            i -= 1000
        elif numpy.max(samples[i-100:]) == 0.0:
            i -= 100
        elif numpy.max(samples[i-10:]) == 0.0:
            i -= 10
        else:
            i -= 1
    samples = samples[0:i]

    self.process(samples, 0)

  def opencard(self, desc):
      self.cardrate = 12000
      self.audio = weakaudio.new(desc, self.cardrate)

  def gocard(self):
      bufbuf = [ ]
      nsamples = 0
      while True:
          [ buf, buf_time ] = self.audio.read()

          bufbuf.append(buf)
          nsamples += len(buf)
          samples_time = buf_time

          if len(buf) > 0:
              mx = numpy.max(numpy.abs(buf))
              if mx > 30000:
                  sys.stderr.write("!")

          if len(buf) == 0:
              sec = self.second(samples_time)
              if sec < 12:
                  time.sleep(1)
              else:
                  time.sleep(0.1)

          # an FT8 frame starts on second 0.5, and takes 12.64 seconds.
          sec = self.second(samples_time)
          if sec >= 13.14 and nsamples >= 13.14*self.cardrate:
              # we have >= 13.14 seconds of samples,
              # and second of minute is >= 13.14.

              samples = numpy.concatenate(bufbuf)

              # sample # of start of 15-second interval.
              i0 = len(samples) - self.cardrate * self.second(samples_time)
              i0 = int(i0)
              i0 = max(i0, 0)
              t = samples_time - (len(samples)-i0) * (1.0/self.cardrate)

              self.process(samples[i0:], t)

              bufbuf = [ ]
              nsamples = 0

  # received a message, add it to the list.
  # offset in seconds.
  # drift in hz/minute.
  def got_msg(self, dec):
      self.msgs_lock.acquire()
      self.msgs.append(dec)
      self.msgs_lock.release()

  # someone wants a list of all messages received,
  # as array of Decode.
  def get_msgs(self):
      self.msgs_lock.acquire()
      a = self.msgs
      self.msgs = [ ]
      self.msgs_lock.release()
      return a

  # run the FT8 decode in a separate process. this yields
  # much more parallelism for multiple receivers than
  # Python's threads.
  def process(self, samples, samples_time):
      global very_first_time
      if very_first_time:
          # warm things up.
          very_first_time = False
          thunk = (lambda dec : self.got_msg(dec))
          self.process0(samples, samples_time, thunk)
          return

      sys.stdout.flush()
      rpipe, spipe = multiprocessing.Pipe(False)

      proc = multiprocessing.Process(target=self.process00,
                                     args=[samples, samples_time, spipe])
      proc.start()
      spipe.close()

      while True:
          try:
              dec = rpipe.recv()
              self.got_msg(dec)
          except:
              break

      proc.terminate()
      proc.join(2.0)
      rpipe.close()

  def process00(self, samples, samples_time, spipe):
      thunk = (lambda dec : spipe.send(dec))
      self.process0(samples, samples_time, thunk)
      spipe.close()

  def process0(self, samples, samples_time, thunk):
    global budget

    if self.enabled == False:
        return

    # samples_time is UNIX time that samples[0] was
    # sampled by the sound card.
    samples_minute = self.minute(samples_time + 1)

    t0 = time.time()

    assert self.cardrate == self.jrate

    # nominal signal start time is half a second into samples[].
    # prepend an extra second of padding.
    # and ensure a 1.5 seconds of pad at the end,
    start_pad = int(2.5 * self.jrate)
    end_pad = int(2.5 * self.jrate)
    sm = numpy.mean(samples[12000:20000]) # pad with plausible signal levels
    sd = numpy.std(samples[12000:20000])
    sd /= 4.0
    samples = numpy.append(numpy.random.normal(sm, sd, start_pad - self.jrate//2), samples)
    wanted = 79*self.jblock + start_pad + end_pad - len(samples)
    if wanted > 0:
        samples = numpy.append(samples, numpy.random.normal(sm, sd, wanted))

    bin_hz = self.jrate / float(self.jblock)

    xf = FFTCache(samples, self.jrate, self.jblock)

    # I think signals should start 0.5 seconds into the minute,
    # at offset start_pad. But it seems like they generally start
    # later, captured by start_adj.
    nominal_start = start_pad + int(self.jrate * start_adj)

    coarse_rank = self.coarse(xf, nominal_start)

    # suppress duplicate message decodes,
    # indexed by message text.
    already = { }

    for rr in coarse_rank:
        if time.time() - t0 >= budget:
            break

        # rr is [ hz, offset, strength ]
        hz = rr[0]
        offset = rr[1]

        if offset < 0 or (offset+79*self.jblock) > len(samples):
            continue

        if fine_tslop > 0.0001:
            # improve the starting offset.
            offslop = int(self.jblock * coarse_tstep * fine_tslop)
            offstep = int(offslop * fine_tstep)
            # [ [ offset, strength ], ... ]
            offs = self.best_offsets(xf, hz, offset, offslop, offstep)
            [ offset, strength ] = offs[0]
        if fine_fslop > 0.0001:
            # improve the starting hz.
            hzslop = coarse_fstep * bin_hz * fine_fslop
            hzstep = hzslop * fine_fstep
            [ hz, strength ] = self.best_freq(xf, hz, offset, hzslop, hzstep)

        ss = xf.get(hz, offset)
        # ss has 79 8-bucket mini-FFTs.

        dec = self.process1(ss[0:79], hz)

        if False:
            if dec != None:
                print("%.1f %s %s" % (time.time() - t0, rr, dec.msg))
            else:
                print("%.1f %s" % (time.time() - t0, rr))

        if dec != None:
            dec.minute = samples_minute
            dec.dt = ((offset - start_pad) / float(self.jrate))
            dec.start = offset
            self.subtract(dec, xf)
            if not dec.msg in already:
                already[dec.msg] = True
                if self.verbose:
                    print("%6.1f %5d %.1f %.0f %s" % (hz, dec.start, dec.dt, dec.snr, dec.msg))
                # self.got_msg(dec)
                thunk(dec)

  # subtract a decoded signal, which may help decodes of buried signals.
  def subtract(self, dec, xf):
      snd = FT8Send()
      s79 = snd.make_symbols(dec.twelve)
      xf.subtract(dec.hz(), dec.start, s79)
    
  # find hz with best Costas sync at offset=start.
  # look at frequencies midhz +/ slop,
  # at granule hz increments.
  # returns [ hz, strength ]
  def best_freq(self, xf, midhz, start, slop, granule):
      start = int(start)
      bin_hz = self.jrate / float(self.jblock)
      
      # a Costas sync array.
      costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
      costas_array = numpy.ones((7, 8)) * (-1 / 7.0)
      for i in range(0, len(costas_symbols)):
          costas_array[i][costas_symbols[i]] = 1

      hz0 = midhz - slop
      hz1 = midhz + slop

      corrs = [ ]
      for hz in numpy.arange(hz0, hz1, granule):
          ss = xf.get(hz, start)
          if len(ss) < 79:
              continue
          # ss has 79 8-bucket mini-FFTs.

          a = ss[0:7] + ss[36:43] + ss[72:79]
          norm = numpy.sum(a)
          b = a * costas_array
          c = numpy.sum(b)
          c = c / norm
          corr = c

          corrs.append([hz, corr])

      corrs = sorted(corrs, key = lambda e : - e[1])
      return corrs[0]

  # find offset with best Costas sync at hz.
  # looks at offsets at start +/- slop,
  # at granule offset increments.
  # returns [ [ start, strength ], ... ]
  def best_offsets(self, xf, hz, start, slop, granule):
      start = int(start)
      slop = int(slop)
      granule = int(granule)
      bin_hz = self.jrate / float(self.jblock)
      
      # a Costas sync array.
      costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
      costas_array = numpy.ones((7, 8)) * (-1 / 7.0)
      for i in range(0, len(costas_symbols)):
          costas_array[i][costas_symbols[i]] = 1

      off0 = start - slop
      off1 = start + slop
      corrs = [ ]
      for off in range(off0, off1, granule):
          if off + 79 * self.jblock > xf.len():
              continue
          ss = xf.get(hz, off)
          if len(ss) < 79:
              continue
          # ss has 79 8-bucket mini-FFTs.

          a = ss[0:7] + ss[36:43] + ss[72:79]
          norm = numpy.sum(a)
          b = a * costas_array
          c = numpy.sum(b)
          c = c / norm # we care about strength of correlation, not sig ampl
          corr = c

          corrs.append([off, corr])

      corrs = sorted(corrs, key = lambda e : - e[1])
      return corrs

  def coarse1(self, xf, nominal_start, hzoff, offoff):
      # prepare a template for 2d correlation containing
      # the three Costas arrays.
      costas = [ 2, 5, 6, 0, 4, 1, 3 ]
      template = numpy.zeros((79, 8))
      for i0 in [ 0, 36, 72 ]:
          for i1 in range(0, 7):
              template[i0+i1,:] = -1 / 7.0
              template[i0+i1,costas[i1]] = 1

      # m[symbol][bin]
      m = xf.getall(hzoff, offoff)

      min_hz = 200
      max_hz = 2500

      bin_hz = self.jrate / float(self.jblock)
      min_hz_bin = int(min_hz / bin_hz)
      max_hz_bin = int(max_hz / bin_hz)

      min_sym = int((nominal_start - self.jrate*coarse_tslop) / self.jblock)
      max_sym = int((nominal_start + self.jrate*coarse_tslop) / self.jblock)

      m = m[min_sym:79+max_sym,min_hz_bin:max_hz_bin]
      
      # for each frequency bin, the total signal level for
      # it and the next eight bins up. we'll divide by this
      # in order to emphasize the correlation, not the
      # signal (or noise) level.
      binsum = numpy.sum(m, axis=0)
      norm = numpy.zeros(len(binsum))
      for i in range(0, 8):
          norm[0:len(norm)-i] += binsum[i:]

      c = scipy.signal.correlate2d(m, template, mode='valid')

      if False:
          h = [ [ (bi+min_hz_bin) * bin_hz,
                  (si+min_sym) * self.jblock,
                  c[si,bi] / norm[bi]
                ]
                for si in range(0, c.shape[0]) for bi in range(0, c.shape[1]) ]
      elif True:
          # best few starting symbol indices for each frequency bin.
          # so we only return a few elements per bin, not
          # one element per bin per starting symbol index.
          max_si = numpy.argsort(-c, axis=0)
          h = [ ]
          for mi in range(0, coarse_no):
              h += [ [ (bi+min_hz_bin) * bin_hz + hzoff,
                      (max_si[mi][bi]+min_sym) * self.jblock + offoff,
                      c[max_si[mi][bi],bi] / norm[bi]
                    ]
                    for bi in range(0, max_si.shape[1]) ]
      else:
          # best starting symbol index for each frequency bin.
          # so we only return one element per bin, not
          # one element per bin per starting symbol index.
          max_si = numpy.argmax(c, axis=0)
          h = [ [ (bi+min_hz_bin) * bin_hz + hzoff,
                  (max_si[bi]+min_sym) * self.jblock + offoff,
                  c[max_si[bi],bi] / norm[bi]
                ]
                for bi in range(0, len(max_si)) ]

      return h

  def coarse(self, xf, nominal_start):
      bin_hz = self.jrate / float(self.jblock)

      h = [ ]
      for hzoff in numpy.arange(0.0, bin_hz, bin_hz * coarse_fstep):
          for offoff in range(0, self.jblock, int(self.jblock * coarse_tstep)):
              hx = self.coarse1(xf, nominal_start, hzoff, offoff)
              h += hx

      h = sorted(h, key = lambda e : -e[2])

      return h

  # m79 is 79 8-bucket mini FFTs, for 8-FSK demodulation.
  # m79[0..79][0..8]
  # returns None or a Decode.
  def process1(self, m79, hz):
    if len(m79) < 79:
        return

    if False:
        # AGC so that win/lose mean/std are more meaningful.
        agcinc = 40
        for i in range(0, 79, agcinc):
            i0 = max(i-agcinc//2, 0)
            i1 = min(i+agcinc+agcinc//2, 79)
            avg = numpy.mean(m79[i0:i1])
            m79[i:i+agcinc] /= avg

    # mean and std dev of winning and non-winning
    # FFT bins, to help compute probabilities of
    # symbol values for soft decoding.
    if True:
        # just look at Costas arrays, where we know
        # which symbols are correct.
        winners = numpy.zeros(3*7)
        losers = numpy.zeros(3*7*7)
        costas_symbols = [ 2, 5, 6, 0, 4, 1, 3 ]
        wi = 0
        li = 0
        for i0 in [ 0, 36, 72 ]:
            for i1 in range(0, 7):
                cs = costas_symbols[i1]
                winners[wi] = m79[i0+i1][cs]
                wi += 1
                losers[li:li+cs] = m79[i0+i1][0:cs]
                losers[li+cs:li+7] = m79[i0+i1][cs+1:]
                li += 7
    else:
        # XXX assume strongest symbol is what was
        #     sent, though often not true.
        winners = numpy.zeros(len(m79))
        losers = numpy.zeros(len(m79) * 7)
        for mi in range(0, len(m79)):
            e = m79[mi]
            wini = numpy.argmax(e) # guess the winning tone.
            winners[mi] = e[wini]
            li = mi * 7
            losers[li:li+wini] = e[0:wini]
            losers[li+wini:li+7] = e[wini+1:]

    winmean = numpy.mean(winners)
    winstd = numpy.std(winners)
    losemean = numpy.mean(losers)
    losestd = numpy.std(losers)

    # estimate SNR.
    # mimics wsjt-x code, but the results are not very close.
    sigi = numpy.argmax(m79, axis=1)
    noisei = numpy.mod(sigi + 4, 8)
    noises = m79[range(0, 79), noisei]
    noise = numpy.mean(noises * noises) # square yields power
    sigs = numpy.amax(m79, axis=1) # guess correct tone
    sig = numpy.mean(sigs * sigs)
    rawsnr = sig / noise
    rawsnr -= 1 # turn (s+n)/n into s/n
    if rawsnr < 0.1:
        rawsnr = 0.1
    rawsnr /= (2500.0 / 2.7) # 2.7 hz noise b/w -> 2500 hz b/w
    snr = 10 * math.log10(rawsnr)
    snr += 3

    # get rid of the three 7-symbol Costas arrays.
    m58 = numpy.concatenate( [ m79[7:36], m79[43:72] ] )

    if True:
        # soft: estimate probability of 0 for each bit.
        ll174 = [ ]
        for i in range(0, len(m58)):
            e = m58[i]

            # tone numbers sorted loudest first.
            tones = sorted(range(0, 8), key = lambda i : -e[i])

            # set up for Bayes on two loudest tones.
            # XXX should do Bayes over all eight tones.
            
            # if tones[0] were sent, how likely is e[tones[0]]?
            p00 = problt(e[tones[0]], winmean, winstd)
            # if tones[1] were sent, how likely is e[tones[0]]?
            p01 = probgt(e[tones[0]], losemean, losestd)

            # if tones[0] were sent, how likely is e[tones[1]]?
            p10 = probgt(e[tones[1]], losemean, losestd)
            # if tones[1] were sent, how likely is e[tones[1]]?
            p11 = problt(e[tones[1]], winmean, winstd)

            # Bayes' rule, for P(tones[0] was sent)
            a = 0.5 * p00 * p10
            b = 0.5*p00*p10 + 0.5*p01*p11
            if b == 0:
                p0 = 0.5
            else:
                p0 = a / b
       
            # log likelihood of tones[0] being the correct symbol.
            if p0 > 0.99:
                ll0 = 5.0
            else:
                ll0 = math.log(p0 / (1 - p0))

            # extract the three bits from this symbol,
            # most-significant bit first.
            # XXX the probability for each bit has a complex relationship
            #     to the probability the tone is correct, since second-best
            #     tone might leave some bits the same as best tone.
            if ((tones[0]>>2) & 1) == 0:
                ll174.append(ll0)
            else:
                ll174.append(-ll0)
            if ((tones[0]>>1) & 1) == 0:
                ll174.append(ll0)
            else:
                ll174.append(-ll0)
            if ((tones[0]>>0) & 1) == 0:
                ll174.append(ll0)
            else:
                ll174.append(-ll0)
    else:
        # hard: strongest FFT bucket yields symbol.
        s58 = [ numpy.argmax(x) for x in m58 ]
        
        # turn each 3-bit symbol into three bits.
        # most-significant bit first.
        z = [ [ (x>>2)&1, (x>>1)&1, x&1 ] for x in s58 ]
        a174 = numpy.concatenate(z)

        # turn hard bits into 0.99 vs 0.01 log-likelihood,
        # log_e( P(bit=0) / P(bit=1) )
        two = numpy.array([ 4.6, -4.6 ], dtype=numpy.int32)
        ll174 = two[a174]

    # decode LDPC(174,87)
    a87 = ldpc_decode(ll174)
    if len(a87) == 0:
        # failure.
        return None

    # a87 is 75 bits of msg and 12 bits of CRC.
    # turn the first 72 bits into twelve 6-bit numbers,
    # for compatibility with FT8 unpack().
    # MSB.
    a72 = a87[0:72]
    twelve = [ ]
    for i in range(0, 72, 6):
        a = a72[i:i+6]
        x = (a[0] * 32 +
             a[1] * 16 +
             a[2] *  8 + 
             a[3] *  4 +
             a[4] *  2 +
             a[5] *  1)
        twelve.append(x)

    msg = self.unpack(twelve)

    # check the CRC-12
    cksum = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
                crc12poly)
    if numpy.array_equal(cksum, a87[-12:]) == False:
        # CRC failed. this is pretty rare.
        # print("CRC failed %s" % (msg))
        return None

    if "000AAA" in msg:
        return None

    dec = Decode([hz,hz], msg, snr, twelve, time.time())
    return dec

  # convert packed character to Python string.
  # 0..9 a..z space
  def charn(self, c):
    if c >= 0 and c <= 9:
      return chr(ord('0') + c)
    if c >= 10 and c < 36:
      return chr(ord('A') + c - 10)
    if c == 36:
      return ' '
    # sys.stderr.write("jt65 charn(%d) bad\n" % (c))
    return '?'

  # x is an integer, e.g. nc1 or nc2, containing all the
  # call sign bits from a packed message.
  # 28 bits.
  def unpackcall(self, x):
    a = [ 0, 0, 0, 0, 0, 0 ]
    a[5] = self.charn((x % 27) + 10) # + 10 b/c only alpha+space
    x = int(x / 27)
    a[4] = self.charn((x % 27) + 10)
    x = int(x / 27)
    a[3] = self.charn((x % 27) + 10)
    x = int(x / 27)
    a[2] = self.charn(x%10) # digit only
    x = int(x / 10)
    a[1] = self.charn(x % 36) # letter or digit
    x = int(x / 36)
    a[0] = self.charn(x)
    return ''.join(a)

  # extract maidenhead locator
  def unpackgrid(self, ng):
    if ng == NGBASE+1:
        return "    "
    if ng >= NGBASE+1 and ng < NGBASE+31:
      return " -%02d" % (ng - (NGBASE+1)) # sig str, -01 to -30 DB
    if ng >= NGBASE+31 and ng < NGBASE+62:
      return "R-%02d" % (ng - (NGBASE+31))
    if ng == NGBASE+62:
      return "RO  "
    if ng == NGBASE+63:
      return "RRR "
    if ng == NGBASE+64:
      return "73  "
      
    lat = (ng % 180) - 90
    ng = int(ng / 180)
    lng = (ng * 2) - 180

    g = "%c%c%c%c" % (ord('A') + int((179-lng)/20),
                      ord('A') + int((lat+90)/10),
                      ord('0') + int(((179-lng)%20)/2),
                      ord('0') + (lat+90)%10)

    if g[0:2] == "KA":
        # really + signal strength
        sig = int(g[2:4]) - 50
        return "+%02d" % (sig)

    if g[0:2] == "LA":
        # really R+ signal strength
        sig = int(g[2:4]) - 50
        return "R+%02d" % (sig)

    #print "lat %d, long %d, %s" % (lat, lng, g)
    return g

  def unpack(self, a):
    # a[] has 12 0..63 symbols, or 72 bits.
    # turn them into the original human-readable message.
    # unpack([61, 37, 30, 28, 9, 27, 61, 58, 26, 3, 49, 16]) -> "G3LTF DL9KR JO40"
    nc1 = 0 # 28 bits of first call
    nc1 |= a[4] >> 2 # 4 bits
    nc1 |= a[3] << 4 # 6 bits
    nc1 |= a[2] << 10 # 6 bits
    nc1 |= a[1] << 16 # 6 bits
    nc1 |= a[0] << 22 # 6 bits

    nc2 = 0 # 28 bits of second call
    nc2 |= (a[4] & 3) << 26 # 2 bits
    nc2 |= a[5] << 20 # 6 bits
    nc2 |= a[6] << 14 # 6 bits
    nc2 |= a[7] << 8 # 6 bits
    nc2 |= a[8] << 2 # 6 bits
    nc2 |= a[9] >> 4 # 2 bits

    ng = 0 # 16 bits of grid
    ng |= (a[9] & 15) << 12 # 4 bits
    ng |= a[10] << 6 # 6 bits
    ng |= a[11]

    if ng >= 32768:
      txt = self.unpacktext(nc1, nc2, ng)
      return txt

    if nc1 == NBASE+1:
      c2 = self.unpackcall(nc2)
      grid = self.unpackgrid(ng)
      return "CQ %s %s" % (c2, grid)

    if nc1 >= 267649090 and nc1 <= 267698374:
        # CQ with suffix (e.g. /QRP)
        n = nc1 - 267649090
        sf = self.charn(n % 37)
        n /= 37
        sf = self.charn(n % 37) + sf
        n /= 37
        sf = self.charn(n % 37) + sf
        n /= 37
        c2 = self.unpackcall(nc2)
        grid = self.unpackgrid(ng)
        return "CQ %s/%s %s" % (c2, sf, grid)

    c1 = self.unpackcall(nc1)
    if c1 == "CQ9DX ":
        c1 = "CQ DX "
    c2 = self.unpackcall(nc2)
    grid = self.unpackgrid(ng)
    return "%s %s %s" % (c1, c2, grid)

  def unpacktext(self, nc1, nc2, nc3):
    c = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ +-./?"

    nc3 &= 32767
    if (nc1 & 1) != 0:
      nc3 += 32768
    nc1 >>= 1
    if (nc2 & 1) != 0:
      nc3 += 65536
    nc2 >>= 1
      
    msg = [""] * 22

    for i in range(4, -1, -1):
      j = nc1 % 42
      msg[i] = c[j]
      nc1 = nc1 // 42

    for i in range(9, 4, -1):
      j = nc2 % 42
      msg[i] = c[j]
      nc2 = nc2 // 42

    for i in range(12, 9, -1):
      j = nc3 % 42
      msg[i] = c[j]
      nc3 = nc3 // 42

    return ''.join(msg)

very_first_time = True

class FT8Send:
    def __init__(self):
        pass

    # convert a character into a number; order is
    # 0..9 A..Z space
    def nchar(self, ch):
        if ch >= '0' and ch <= '9':
            return ord(ch) - ord('0')
        if ch >= 'A' and ch <= 'Z':
            return ord(ch) - ord('A') + 10
        if ch == ' ':
            return 36
        print("NT65Send.nchar(%s) oops" % (ch))
        return 0

    # returns a 28-bit number.
    # we need call to be:
    #   lds lds d ls ls ls
    # l-etter, d-igit, s-pace
    # 28-bit number's high bits correspond to first call sign character.
    def packcall(self, call):
        call = call.strip()
        call = call.upper()

        if call == "CQ":
            return NBASE + 1
        if call == "QRZ":
            return NBASE + 2
        if call == "DE":
            return 267796945

        if len(call) > 2 and len(call) < 6 and not call[2].isdigit():
            call = " " + call
        while len(call) < 6:
            call = call + " "

        if re.search(r'^[A-Z0-9 ][A-Z0-9 ][0-9][A-Z ][A-Z ][A-Z ]$', call) == None:
            return -1

        x = 0
        x += self.nchar(call[0])

        x *= 36
        x += self.nchar(call[1])

        x *= 10
        x += self.nchar(call[2])

        x *= 27
        x += self.nchar(call[3]) - 10

        x *= 27
        x += self.nchar(call[4]) - 10

        x *= 27
        x += self.nchar(call[5]) - 10
        
        return x

    # returns 16-bit number.
    # g is maidenhead grid, or signal strength, or 73.
    def packgrid(self, g):
        g = g.strip()
        g = g.upper()

        if g[0] == '-':
            snr = int(g[1:])
            if snr == 0:
                snr = 1
            if snr > 29:
                snr = 29
            return NGBASE + 1 + snr
        if g[0:2] == 'R-':
            snr = int(g[2:])
            if snr == 0:
                snr = 1
            if snr > 29:
                snr = 29
            return NGBASE + 31 + snr
        if g == "RO":
            return NGBASE + 62
        if g == "RRR":
            return NGBASE + 63
        if g == "73":
            return NGBASE+64

        if re.match(r'^[A-R][A-R][0-9][0-9]$', g) == None:
            return -1

        lng = (ord(g[0]) - ord('A')) * 20
        lng += (ord(g[2]) - ord('0')) * 2
        lng = 179 - lng

        lat = (ord(g[1]) - ord('A')) * 10
        lat += (ord(g[3]) - ord('0')) * 1
        lat -= 90

        x = (lng + 180) / 2
        x *= 180
        x += lat + 90

        return x

    # turn three numbers into 12 6-bit symbols.
    def pack3(self, nc1, nc2, g):
        a = [0] * 12
        a[0] = (nc1 >> 22) & 0x3f
        a[1] = (nc1 >> 16) & 0x3f
        a[2] = (nc1 >> 10) & 0x3f
        a[3] = (nc1 >> 4) & 0x3f
        a[4] = ((nc1 & 0xf) << 2) | ((nc2 >> 26) & 0x3)
        a[5] = (nc2 >> 20) & 0x3f
        a[6] = (nc2 >> 14) & 0x3f
        a[7] = (nc2 >> 8) & 0x3f
        a[8] = (nc2 >> 2) & 0x3f
        a[9] = ((nc2 & 0x3) << 4) | ((g >> 12) & 0xf)
        a[10] = (g >> 6) & 0x3f
        a[11] = (g >> 0) & 0x3f
        return a
        
    def pack(self, msg):
        msg = msg.strip()
        msg = re.sub(r'  *', ' ', msg)
        msg = re.sub(r'^CQ DX ', 'CQ9DX ', msg)

        # try CALL CALL GRID
        a = msg.split(' ')
        if len(a) == 3:
            nc1 = self.packcall(a[0])
            nc2 = self.packcall(a[1])
            g = self.packgrid(a[2])
            if nc1 >= 0 and nc2 >= 0 and g >= 0:
                return self.pack3(nc1, nc2, g)

        # never finished this -- no text &c.
        sys.stderr.write("FT8Send.pack(%s) -- cannot parse\n" % (msg))
        # sys.exit(1)
        return [0] * 12

    def testpack(self):
        r = FT8()
        for g in [ "FN42", "-22", "R-01", "RO", "RRR", "73", "AA00", "RR99" ]:
            pg = self.packgrid(g)
            upg = r.unpackgrid(pg)
            if g != upg.strip():
                print("packgrid oops %s" % (g))
        for call in [ "AB1HL", "K1JT", "M0TRJ", "KK4BMV", "2E0CIN", "HF9D",
                      "6Y4K", "D4Z", "8P6DR", "ZS2I", "3D2RJ",
                      "WB3D", "S59GCD", "T77C", "4Z5AD", "A45XR", "OJ0V",
                      "6Y6N", "S57V", "3Z0R" ]:
            # XXX 3XY1T doesn't work
            pc = self.packcall(call)
            upc = r.unpackcall(pc)
            if call != upc.strip():
                print("packcall oops %s %d %s" % (call, pc, upc))
        for msg in [ "AB1HL K1JT FN42", "CQ DX CO3HMR EL82", "KD6HWI PY7VI R-12",
                     "KD5RBW TU 73", "CQ N5OSK EM25", "PD9BG KG7EZ RRR",
                     "W1JET KE0HQZ 73", "WB3D OM4SX -16", "WA3ETR IZ2QGB RR73",
                     "BG THX JOE 73"]:
            pm = self.pack(msg)
            upm = r.unpack(pm)
            upm = re.sub(r'  *', ' ', upm)
            if msg != upm.strip():
                print("pack oops %s %s %s" % (msg, pm, upm))

    # twelve[] is 12 6-bit symbols, the result of pack().
    # returns an array of 79 symbols 0..8, ready for FSK.
    def make_symbols(self, twelve):
        # turn the 72 bits in twelve into an array of bits,
        # most significant bit first.
        # three zero bits at the end, for 75.
        # and room for 12 CRC bits.
        a87 = numpy.zeros(87, dtype=numpy.int32)
        i = 0
        for x in twelve:
            a87[i + 0] = (x >> 5) & 1
            a87[i + 1] = (x >> 4) & 1
            a87[i + 2] = (x >> 3) & 1
            a87[i + 3] = (x >> 2) & 1
            a87[i + 4] = (x >> 1) & 1
            a87[i + 5] = (x >> 0) & 1
            i += 6

        # CRC12
        cksum = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
                    crc12poly)
        a87[-12:] = cksum

        # LDPC(174,87)
        a174 = ldpc_encode(a87)

        # turn array of 174 bits into 58 3-bit symbols,
        # most significant bit first.
        dsymbols = numpy.zeros(58, dtype=numpy.int32)
        for i in range(0, 58):
            ii = i * 3
            dsymbols[i] = (a174[ii+0] << 2) | (a174[ii+1]<<1) | (a174[ii+2]<<0)

        # insert three 7-symbol Costas arrays.
        costas = numpy.array([ 2, 5, 6, 0, 4, 1, 3 ], dtype=numpy.int32)
        symbols = numpy.zeros(79, dtype=numpy.int32)
        symbols[0:7] = costas
        symbols[7:36] = dsymbols[0:29]
        symbols[36:43] = costas
        symbols[43:72] = dsymbols[29:]
        symbols[72:] = costas

        return symbols

    # twelve[] is 12 6-bit symbols, the result of pack().
    # tone is Hz of lowest tone.
    # returns an array of audio samples.
    def send12(self, twelve, tone, rate):
        symbols = self.make_symbols(twelve)

        samples_per_symbol = int(round(rate * (1920 / 12000.0)))
        samples = weakutil.fsk(symbols, [tone, tone], 6.25, rate, samples_per_symbol)

        return samples

    def testsend(self):
        random.seed(0)
        rate = 12000
        
        # G3LTF DL9KR JO40)
        x1 = self.send12([61, 37, 30, 28, 9, 27, 61, 58, 26, 3, 49, 16], 1000, rate)
        x1 = numpy.concatenate(([0]*1,  x1, [0]*(8192-1) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x1 = x1 * rv

        # RA3Y VE3NLS 73
        x2 = self.send12([46, 6, 32, 22, 55, 20, 11, 32, 53, 23, 59, 16], 1050, rate)
        x2 = numpy.concatenate(([0]*4096,  x2, [0]*(8192-4096) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x2 = x2 * rv

        # CQ DL7ACA JO40
        x3 = self.send12([62, 32, 32, 49, 37, 27, 59, 2, 30, 19, 49, 16], 1100, rate)
        x3 = numpy.concatenate(([0]*5120,  x3, [0]*(8192-5120) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x3 = x3 * rv

        # VA3UG   F1HMR 73  
        x4 = self.send12([52, 54, 60, 12, 55, 54, 7, 19, 2, 23, 59, 16], 1150, rate)
        x4 = numpy.concatenate(([0]*1,  x4, [0]*(8192-1) ))
        #rv = numpy.concatenate( [ [random.random()]*4096 for i in range(0, 128) ] )
        #x4 = x4 * rv

        x = 3*x1 + 2*x2 + 1.0*x3 + 0.5*x4

        x += numpy.random.rand(len(x)) * 1.0
        x *= 1000.0

        x = numpy.append([0]*(rate // 2), x)
        x = numpy.append(x, [0]*rate)

        r = FT8()
        r.cardrate = rate
        r.process(x, 0)

if False:
    s = FT8Send()
    r = FT8()
    plain = [ ]
    for i in range(0, 87):
        plain.append(random.randint(0, 1))

    cw = ldpc_encode(plain)

    # turn hard bits into 0.99 vs 0.01 log-likelihood,
    # log( P(0) / P(1) )
    # log base e.
    two = numpy.array([ 4.6, -4.6 ], dtype=numpy.int32)
    ll174 = two[cw]

    d = ldpc_decode(ll174)

    assert numpy.array_equal(d, plain)

    sys.exit(1)

if False:
    s = FT8Send()
    s.testsend()
    sys.exit(1)

if False:
    s = FT8Send()
    s.testpack()
    sys.exit(1)

if False:
    # test decoding sequence on known correct symbols,
    # from wsjt-x's ft8sim.
    # should yield K1ABC W9XYZ EN37
    r = FT8()

    # 79 3-bit 8-FSK symbols, including the Costas arrays.
    a79 = "2560413335544231617326364127543164332560413756060434371356756660051002662560413"
    b79 = [ int(x) for x in a79 ]
    assert len(b79) == 79

    # get rid of the three 7-symbol Costas arrays.
    a58 = b79[7:36] + b79[43:72]
    assert len(a58) == 58

    # turn 3-bits into 1-bits.
    # most-significant bit first.
    z = [ [ (x>>2)&1, (x>>1)&1, x&1 ] for x in a58 ]
    a174 = numpy.concatenate(z)
    assert len(a174) == 174

    if True:
        # flip some bits, for testing.
        a174[17] ^= 1
        a174[30] ^= 1
        a174[31] ^= 1
        a174[102] ^= 1

    # turn hard bits into 0.99 vs 0.01 log-likelihood,
    # log( P(0) / P(1) )
    # log base e.
    two = numpy.array([ 4.6, -4.6 ], dtype=numpy.int32)
    ll174 = two[a174]
    
    # decode LDPC(174,87)
    a87 = ldpc_decode(ll174)

    # failure -> numpy.array([])
    assert len(a87) == 87

    # CRC12
    # this mimics the way the sender computes the 12-bit checksum:
    c = crc(numpy.append(a87[0:72], numpy.zeros(4, dtype=numpy.int32)),
            crc12poly)
    assert numpy.array_equal(c, a87[-12:])
    
    # a87 is 72 bits of msg and 12 bits of CRC.
    # turn the 72 bits into twelve 6-bit numbers,
    # for compatibility with FT8 unpack().
    # MSB.
    a72 = a87[0:72]
    twelve = [ ]
    for i in range(0, 72, 6):
        a = a72[i:i+6]
        x = (a[0] * 32 +
             a[1] * 16 +
             a[2] *  8 + 
             a[3] *  4 +
             a[4] *  2 +
             a[5] *  1)
        twelve.append(x)

    msg = r.unpack(twelve)
    #print msg
    assert msg == " K1ABC  W9XYZ EN37"

    sys.exit(0)

def usage():
  sys.stderr.write("Usage: ft8.py -in CARD:CHAN\n")
  sys.stderr.write("       ft8.py -file fff [-chan xxx]\n")
  sys.stderr.write("       ft8.py -bench ft8files/xxx.txt\n")
  sys.stderr.write("       ft8.py -opt ft8files/xxx.txt\n")
  # list sound cards
  weakaudio.usage()
  sys.exit(1)

def benchmark(wsjtfile, verbose):
    dir = os.path.dirname(wsjtfile)
    minutes = { } # keyed by hhmmss
    wsjtf = open(wsjtfile, "r")
    for line in wsjtf:
        # 161230 -15  0.2 1779 ~  CQ W8MSC EN82 !U.S.A.
        # 161230 -16  0.8 2352 ~  VE2FON KM4MDT R-09
        # 161245 -21  0.3  538 ~  K3OWX KG5AUW -03
        # 161245   2  0.1  955 ~  KJ1J NS9I -06
        line = re.sub(r'\xA0', ' ', line) # 0xA0 -> space
        line = re.sub(r'[\r\n]', '', line)
        m = re.match(r'^([0-9]{6}) +.*$', line)
        if m == None:
            print("oops: " + line)
            continue
        hhmmss = m.group(1)
        if not hhmmss in minutes:
            minutes[hhmmss] = ""
        minutes[hhmmss] += line + "\n"
    wsjtf.close()

    info = [ ]
    for hhmmss in sorted(minutes.keys()):
        ff = [ x for x in os.listdir(dir) if re.match('......_' + hhmmss + '.wav', x) != None ]
        if len(ff) == 1:
            filename = ff[0]
            info.append([ True, filename, minutes[hhmmss] ])
        elif len(ff) == 0:
            sys.stderr.write("could not find .wav file in %s for %s\n" % (dir, hhmmss))
        else:
            sys.stderr.write("multiple files in %s for %s: %s\n" % (dir, hhmmss, ff))

    return benchmark1(dir, info, verbose)

def benchmark1(dir, bfiles, verbose):
    global chan
    chan = 0
    crcok = 0 # how many we decoded
    jtscore = 0 # how many we decoded that wsjt-x also decoded
    jtwanted = 0 # how many wsjt-x decoded
    for bf in bfiles:
        if not bf[0]: # only the short list
            continue
        if verbose:
            print(bf[1])
        filename = dir + "/" + bf[1]
        r = FT8()
        r.verbose = False
        r.gowav(filename, chan)
        all = r.get_msgs()
        crcok += len(all)
        got = { } # did wsjt-x see this? indexed by msg.
        any_no = False

        wsa = bf[2].split("\n")
        for wsx in wsa:
            # 161245 -21  0.3  538 ~  K3OWX KG5AUW -03
            # 161245   2  0.1  955 ~  KJ1J NS9I -06
            wsx = wsx.strip()
            if wsx != "":
                jtwanted += 1
                wsx = re.sub(r'  *', ' ', wsx)
                found = None
                for dec in all:
                    mymsg = dec.msg
                    mymsg = mymsg.strip()
                    mymsg = re.sub(r'  *', ' ', mymsg)
                    if mymsg in wsx:
                        found = dec
                        got[dec.msg] = True

                wa = wsx.split(' ')
                wmsg = ' '.join(wa[5:8])
                whz = float(wa[3])
                if whz >= 10 and whz < 11:
                    whz = (whz - 10.1387) * 1000000.0
                elif whz >= 14 and whz < 15:
                    whz = (whz - 14.0956) * 1000000.0
                elif whz < 1.0:
                    whz = whz * 1000000.0

                if found != None:
                    jtscore += 1
                    if verbose:
                        print("yes %4.0f %s (%.1f %.1f) %s" % (float(whz), wa[2], found.hz(), found.dt, wmsg))
                else:
                    any_no = True
                    if verbose:
                        print("no  %4.0f %s %s" % (float(whz), wa[2], wmsg))
                sys.stdout.flush()
        for dec in all:
            if not (dec.msg in got):
                if verbose:
                    print("EXTRA: %6.1f %s" % (dec.hz(), dec.msg))
    if verbose:
        print("score %d (%d of %d)" % (crcok, jtscore, jtwanted))
    return [ crcok, jtscore, jtwanted ]

vars = [
    [ "fine_tslop", [ 0, 0.33, 0.5, 1.0 ] ],
    [ "coarse_tslop", [ 0.75, 1.0, 1.5, 1.75, 2.0, 2.25 ] ],
    [ "start_adj", [ 0.33, 0.42, 0.5, 0.58, 0.66 ] ],
    [ "coarse_fstep", [ 0.25, 0.33, 0.5, 0.75, 1.0 ] ],
    [ "coarse_tstep", [ 0.12, 0.19, 0.25, 0.33, 0.5, 0.75, 1.0 ] ],
    [ "coarse_no", [ 1, 2, 3, 4 ] ],
    [ "ldpc_iters", [ 12, 20, 25, 30, 37, 50, 75, 100 ] ],
    [ "fine_fslop", [ 0, 0.1, 0.33, 0.5, 1.0 ] ],
    [ "budget", [ 2, 4, 20 ] ],
    # [ "fine_fstep", [ 0.12, 0.19, 0.25, 0.33, 0.5, 0.66, 0.99 ] ],
    # [ "fine_tstep", [ 0.12, 0.19, 0.25, 0.33, 0.5, 0.66 ] ],
    ]

def printvars():
    s = ""
    for v in vars:
        s += "%s=%s " % (v[0], eval(v[0]))
    return s

def optimize(wsjtfile):
    # warm up any caches, JIT, &c.
    r = FT8()
    r.verbose = False
    r.gowav("ft8files/170717_161300.wav", 0)

    for v in vars:
        for val in v[1]:
            old = None
            if "." in v[0]:
                xglob = ""
            else:
                xglob = "global %s ; " % (v[0])
            exec("%sold = %s" % (xglob, v[0]))
            exec("%s%s = %s" % (xglob, v[0], val))

            [ crcok, jtscore, jtwanted ] = benchmark(wsjtfile, False)
            exec("%s%s = old" % (xglob, v[0]))
            sys.stdout.write("%s=%s : " % (v[0], val))
            sys.stdout.write("%d %d %d\n" % (crcok, jtscore, jtwanted))
            sys.stdout.flush()

filename = None
card = None
bench = None
opt = None

def main():
  global filename, card, bench, opt
  i = 1
  while i < len(sys.argv):
    if sys.argv[i] == "-in":
      card = [ sys.argv[i+1], sys.argv[i+2] ]
      i += 3
    elif sys.argv[i] == "-file":
      filename = sys.argv[i+1]
      i += 2
    elif sys.argv[i] == "-bench":
      bench = sys.argv[i+1]
      i += 2
    elif sys.argv[i] == "-opt":
      opt = sys.argv[i+1]
      i += 2
    else:
      usage()
  
  if False:
    xr = FT8()
    xr.test_guess_offset()
    sys.exit(0)
  
  if bench != None:
    sys.stdout.write("# %s %s\n" % (bench, printvars()))
    benchmark(bench, True)
    sys.exit(0)

  if opt != None:
    sys.stdout.write("# %s %s\n" % (opt, printvars()))
    optimize(opt)
    sys.exit(0)
  
  if filename != None and card == None:
    r = FT8()
    r.verbose = True
    r.gowav(filename, 0)
  elif filename == None and card != None:
    r = FT8()
    r.verbose = True
    r.opencard(card)
    r.gocard()
  else:
    usage()

if __name__ == '__main__':
  if False:
    pfile = "cprof.out"
    sys.stderr.write("ft8: cProfile -> %s\n" % (pfile))
    import cProfile
    import pstats
    cProfile.run('main()', pfile)
    p = pstats.Stats(pfile)
    p.strip_dirs().sort_stats('time')
    # p.print_stats(10)
    p.print_callers()
  else:
    main()
